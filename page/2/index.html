<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="沉迷学习无法自拔"/>













  <link rel="alternate" href="/atom.xml" title="APPARITION957">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://apparition957.github.io/page/2/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  
  <script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8bd9b518a8b821a06877823fceed6cab";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>








<meta name="google-site-verification" content="OxwLY0TQSQ2wO159foQs2OK6XTDPDZA_H3N6_pCPnng" />


    <title> APPARITION957 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">APPARITION957</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">APPARITION957</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/19/有多少人工就有多少智能/">有多少人工就有多少智能</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-19
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>这个标题其实是来自于<a href="https://blog.csdn.net/dQCFKyQDXYm3F8rB0/article/details/79933707" target="_blank" rel="external">小米小爱团队负责人王刚：语音交互背后，有多少人工就有多少智能</a>这篇文章，虽然我现在的工作与人工智能没关系，但是与我现在的经历息息相关的。</p>
<p>最近在跟着老大去做页面分析的模块，现阶段有个问题在于怎么去解决网页软404问题。可行的解决方案当然有很多，HTTP 请求码、URL 的正则匹配、内容关键字匹配等。但是这么多的解决方案都需要的一个判断标准，判断跑出来的数据可不可靠，如果不可靠的话那么这个方案可能就行不通。</p>
<p>那么比较尴尬的部分来了，这个判断的过程是由人工来的，那这个活自然就落在我和其他同事身上啦。虽然知道这个是必然的过程，但是心还是不甘的，不甘于自己要去做人工筛选工作。</p>
<p><img src="http://on83riher.bkt.clouddn.com/WechatIMG128.jpeg" alt="工作成果"></p>
<p>其实单单抛弃人工智能这个前提，<strong>“有多少人工就有多少智能”</strong>这句话适用于互联网的各个领域，只要能够投入了足够的人力，那么系统的未来也会有很大的改善，以上是我现阶段的看法。</p>
<p>经历了这次人工筛选的活后，我还从这句话体会到了一点，<strong>努力提升自己的技术，别让自己成为可取代的人工。</strong>加深自己的技术栈吧，再经历多点磨难，或许能够看见更多未来。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/14/Spark - take() 算子/">Spark - take() 算子</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-14
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <blockquote>
<p>以后遇到不懂的 Spark 算子的话，我都尽可能以笔记的方式去记录它</p>
</blockquote>
<h3 id="遇到的情况"><a href="#遇到的情况" class="headerlink" title="遇到的情况"></a>遇到的情况</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rdd.map(...)	 <span class="comment">// 重要前提：数据量在 TB 级别</span></div><div class="line">   .filter(...)  <span class="comment">// 根据某些条件筛选数据</span></div><div class="line">   .take(<span class="number">100000</span>) <span class="comment">// 取当前数据的前十万条</span></div></pre></td></tr></table></figure>
<p>当时的程序大致就是这样，我的想法是根据<code>filter()</code>之后的数据直接利用<code>take()</code>拿前十万的数据，感觉方便又省事，但是实际的运行情况却是作业的运行时间很长，让人怀疑人生。而且<code>take()</code>一开始默认的分区是1，而后如果当前任务失败的话，会适当的扩增分区数来读取更多的数据。</p>
<p><img src="http://on83riher.bkt.clouddn.com/take%20%E7%AE%97%E5%AD%90%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5.png" alt=""></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>废话不多，先贴源码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">  * Take the first num elements of the RDD. It works by first scanning one partition, and use the results from that partition to estimate the number of additional partitions needed to satisfy the limit.</span></div><div class="line"><span class="comment">  *</span></div><div class="line"><span class="comment">  * @note This method should only be used if the resulting array is expected to be small, as all the data is loaded into the driver's memory.</span></div><div class="line"><span class="comment">  * 此方法被使用时期望目标数组的大小比较小，即其数组中所有数据都能够存储在 driver 的内存当中。这里的函数解释当中提及到了处理的数据量应当较小，但是没说如果处理了比较大的数据时会怎么样，还得看看继续往下看</span></div><div class="line"><span class="comment">  *</span></div><div class="line"><span class="comment">  * @note Due to complications in the internal implementation, this method will raise</span></div><div class="line"><span class="comment">  * an exception if called on an RDD of `Nothing` or `Null`.</span></div><div class="line"><span class="comment">  */</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">take</span></span>(num: <span class="type">Int</span>): <span class="type">Array</span>[<span class="type">T</span>] = withScope &#123;</div><div class="line">  <span class="comment">// scaleUpFactor 字面意思是扩增因子，看到这里我们可以结合上图的例子，不难看出分区的扩增是按照一定的倍数增长的</span></div><div class="line">  <span class="keyword">val</span> scaleUpFactor = <span class="type">Math</span>.max(conf.getInt(<span class="string">"spark.rdd.limit.scaleUpFactor"</span>, <span class="number">4</span>), <span class="number">2</span>)</div><div class="line">  <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">T</span>](<span class="number">0</span>)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">val</span> buf = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">T</span>]</div><div class="line">    <span class="keyword">val</span> totalParts = <span class="keyword">this</span>.partitions.length</div><div class="line">    <span class="keyword">var</span> partsScanned = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="comment">// 这个循环是为什么 take 失败会进行重试的关键</span></div><div class="line">    <span class="keyword">while</span> (buf.size &lt; num &amp;&amp; partsScanned &lt; totalParts) &#123;</div><div class="line">      <span class="comment">// The number of partitions to try in this iteration. It is ok for this number to be</span></div><div class="line">      <span class="comment">// greater than totalParts because we actually cap it at totalParts in runJob.</span></div><div class="line">      <span class="comment">// numPartsToTry - 此次循环迭代的分区个数，默认为1。</span></div><div class="line">      <span class="keyword">var</span> numPartsToTry = <span class="number">1</span>L</div><div class="line">      <span class="keyword">val</span> left = num - buf.size</div><div class="line">      <span class="keyword">if</span> (partsScanned &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// If we didn't find any rows after the previous iteration, quadruple and retry.</span></div><div class="line">        <span class="comment">// Otherwise, interpolate the number of partitions we need to try, but overestimate</span></div><div class="line">        <span class="comment">// it by 50%. We also cap the estimation in the end.</span></div><div class="line">        <span class="comment">// 重点！当在上一次迭代当中，我们没有找到任何满足条件的 row 时(至少是不满足指定数量时)，有规律的重试(quadruple and retry，翻译水平有限)</span></div><div class="line">        <span class="keyword">if</span> (buf.isEmpty) &#123;</div><div class="line">          numPartsToTry = partsScanned * scaleUpFactor</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// As left &gt; 0, numPartsToTry is always &gt;= 1</span></div><div class="line">          numPartsToTry = <span class="type">Math</span>.ceil(<span class="number">1.5</span> * left * partsScanned / buf.size).toInt</div><div class="line">          numPartsToTry = <span class="type">Math</span>.min(numPartsToTry, partsScanned * scaleUpFactor)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">val</span> p = partsScanned.until(math.min(partsScanned + numPartsToTry, totalParts).toInt)</div><div class="line">      <span class="keyword">val</span> res = sc.runJob(<span class="keyword">this</span>, (it: <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; it.take(left).toArray, p)</div><div class="line"></div><div class="line">      <span class="comment">// 每一次循环迭代都会获取新的数据加到 buf 当中，所以并不是每一次重试都是从头对数据进行遍历，那这样会没完没了</span></div><div class="line">      res.foreach(buf ++= _.take(num - buf.size))</div><div class="line">      partsScanned += p.size</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这里才是我们最终的结果</span></div><div class="line">    buf.toArray</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>take()</code>算子使用的场景是当数据量规模较小的情况，亦或者说搭配<code>filter()</code>时，<code>filter()</code>能够较快的筛选出数据来。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/01/Spark - 由 foreach 引发的思考/">Spark - 由 foreach 引发的思考</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-01
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>废话不说，先贴代码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> numbers = sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>))</div><div class="line"><span class="keyword">val</span> map = scala.collection.mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Int</span>]()</div><div class="line"></div><div class="line">numbers.foreach(l =&gt; &#123;map.put(l,l)&#125;)</div><div class="line">println(map.size) <span class="comment">// 此时 map 的存储了几个键值对</span></div></pre></td></tr></table></figure>
<hr>
<p>首先我们先说个概念 —— <strong>闭包</strong></p>
<p>闭包是 Scala 中的特性，用通俗易懂的话讲就是函数内部的运算或者说函数返回值可由外部的变量所控制，用个例子解释就是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> factor = <span class="number">10</span></div><div class="line"><span class="comment">// multiplier 函数的返回值有有两个决定因素，输入参数变量 i 以及外部变量 factor。输入参数变量 i 是由我们调用该函数时决定的，相较于 factor 是可控的，而 factor 则是外部变量所定义，相较于 i 是不可控的</span></div><div class="line"><span class="keyword">val</span> multiplier = (i: <span class="type">Int</span>) =&gt; i * factor </div><div class="line">println(multiplier(<span class="number">1</span>)) <span class="comment">// 10</span></div><div class="line"></div><div class="line">factor = <span class="number">20</span></div><div class="line">println(multiplier(<span class="number">1</span>)) <span class="comment">// 20</span></div></pre></td></tr></table></figure>
<p>根据上述提及的闭包可知，刚才所写的代码中<code>l =&gt; {map.put(1,1)}</code>其所定义的函数就是一个闭包</p>
<hr>
<p>既然标题中提到了 Spark，那就要说明闭包与 Spark 的关系了</p>
<p>在 Spark 中，用户自定义闭包函数并传递给相应的 RDD 所定义好的方法（如<code>foreach</code>、<code>map</code>）。<strong>Spark 在运行作业时会检查 DAG 中每个 RDD 所涉及的闭包，如是否可序列化、是否引用外部变量等。若存在引用外部变量的情况，则会将它们的副本复制到相应的工作节点上，保证程序运行的一致性</strong></p>
<blockquote>
<p>下面是 Spark 文档中解释的：</p>
<h3 id="Shared-Variables"><a href="#Shared-Variables" class="headerlink" title="Shared Variables"></a>Shared Variables</h3><p>Normally, when a function passed to a Spark operation (such as <code>map</code> or <code>reduce</code>) is executed on a remote cluster node, it works on separate copies of all the variables used in the function. These variables are copied to each machine, and no updates to the variables on the remote machine are propagated back to the driver program. Supporting general, read-write shared variables across tasks would be inefficient. However, Spark does provide two limited types of <em>shared variables</em> for two common usage patterns: broadcast variables and accumulators.</p>
<h3 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h3><p>通常情况下，当有函数传递给在远端集群节点上执行的 Spark 的算子（如<code>map</code>或<code>reduce</code>）时，Spark 会将所有在该函数内部所需要的用到的变量分别复制到相应的节点上。这些副本变量会被复制到每个节点上，且在算子执行结束后这些变量并不会回传给驱动程序（driver program）。</p>
<p>Normally, when a function passed to a Spark operation (such as <code>map</code> or <code>reduce</code>) is executed on a remote cluster node, it works on separate copies of all the variables used in the function. These variables are copied to each machine, and no updates to the variables on the remote machine are propagated back to the driver program. </p>
</blockquote>
<hr>
<p>总结，如果直接运行一开始所提及的程序时，那么所获得的答案是0，因为我们知道<code>map</code>变量会被拷贝多份至不同的工作节点上，而我们操作的也仅仅只是副本罢了</p>
<p>从编译器的角度来说，这段代码是一个闭包函数，而其调用了外部变量，代码上没问题。但是从运行结果中，这是错误操作方式，因为 Spark 会将其所调用的外部变量进行拷贝，并复制到相应的工作节点中，而不会对真正的变量产生任何影响</p>
<p>相应的解决方案有</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> numbers = sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>))</div><div class="line"><span class="keyword">val</span> map = scala.collection.mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Int</span>]()</div><div class="line"></div><div class="line">numbers.collect().foreach(l =&gt; &#123;map.put(l,l)&#125;)</div><div class="line">println(map.size)</div></pre></td></tr></table></figure>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://spark.apache.org/docs/2.1.0/programming-guide.html#shared-variables" target="_blank" rel="external">http://spark.apache.org/docs/2.1.0/programming-guide.html#shared-variables</a></li>
</ol>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/24/列式存储 - HBase vs Parquet/">列式存储 - HBase vs Parquet</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-24
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <blockquote>
<p>虽然两者在使用场景上没有可比性，HBase 是非关系型数据库，而 Parquet 是数据存储格式，但是两者却存在相似的概念——列式存储。我在了解 Parquet 的时候，因为列式存储这个概念与 HBase 混淆时，所以特意坐下笔记，记录两者的区别</p>
</blockquote>
<p>让我们直入正题，什么是列式存储？相比行式存储又有什么优势呢？</p>
<p><img src="http://on83riher.bkt.clouddn.com/%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%A1%8C%E5%BC%8F%E5%AD%98%E5%82%A8%20%E5%AF%B9%E6%AF%94%E5%9B%BE.png" alt=""></p>
<blockquote>
<p>图源来自 <a href="http://zhuanlan.51cto.com/art/201703/535729.htm" target="_blank" rel="external">http://zhuanlan.51cto.com/art/201703/535729.htm</a></p>
</blockquote>
<hr>
<p>首选先从 HBase 开始讲述。HBase是一个分布式的、面向列的非关系型数据库。它的架构设计如下：</p>
<p><img src="http://on83riher.bkt.clouddn.com/HBase%20%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt=""></p>
<p>简单说明一下：</p>
<ul>
<li>HMaster：HBase 主/从架构的主节点。通常在一个 HBase 集群中允许存在多个 HMaster 节点，其中一个节点被选举为 Active Master，而剩余节点为 Backup Master。其主要作用在于：<ul>
<li>管理和分配 HRegionServer 中的 Region</li>
<li>管理 HRegionServer 的负载均衡</li>
</ul>
</li>
<li>HRegionServer：HBase 主/从架构的从节点。主要负责响应 Client 端的 I/O 请求，并向底层文件存储系统 HDFS 中读写数据</li>
<li>HRegion：HBase 通过表中的 RowKey 将表进行水平切割后，会生成多个 HRegion。每个 HRegion 都会被安排到 HRegionServer 中</li>
<li>Store：每一个 HRegion 有一个或多个 Store 组成，Store 相对应表中的 Column Family（列族）。每个 Store 都由一个 MemStore 以及多个 StoreFile 组成</li>
<li>MemStore：MemStore 是一块内存区域，其将 Client 对 Store 的所有操作进行存储，并到达一定的阈值时会进行 flush 操作</li>
<li>StoreFile：MemStore 中的数据写入文件后就成为了 StoreFile，而 StoreFile 底层是以 HFile 为存储格式进行保存的</li>
<li>HFile：HBase 中 Key-Value 数据的存储格式，是 Hadoop 的二进制文件。其中 Key-Value 的格式为（Table, RowKey, Family, Qualifier, Timestamp）- Value</li>
</ul>
<p>HBase 的主要读写方式可以通过以下流程进行：</p>
<p><img src="http://on83riher.bkt.clouddn.com/HBase%20%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.png" alt=""></p>
<p>可以从上述的架构讲述看出，HBase 并非严格意义上的列式存储，而是基于“列族”存储的，所以其是列族的角度进行列式存储。</p>
<hr>
<p>Parquet 是面向分析型业务的列式存储格式，其不与某一特定语言绑定，也不与任何一种数据处理框架绑定在一起，其性质类似于 JSON。</p>
<p>Parquet 相较于 HBase 对数据的处理方式，其将数据当做成一种嵌套数据的模型，并将其结构定义为 schema。每一个数据模型的 schema 包含多个字段，而每个字段又可以包含多个字段。每一字段都有三个属性：repetition、type 和 name，其中 repetition 可以是以下三种：required（出现1次）、optional（出现0次或1次）、repeated（出现0次或多次），而 type 可以是 group（嵌套类型）或者是 primitive（原生类型）。</p>
<p>举一个典型的例子：</p>
<p><img src="http://on83riher.bkt.clouddn.com/Parquet%20%E4%BE%8B%E5%AD%90.png" alt=""></p>
<p>在 Parquet 格式的存储当中，一个 schema 的树结构有几个叶子节点，在实际存储中就有多少个 column。例如上面 schema 的数据存储实际上有四个 column，如下所示：</p>
<p><img src="http://on83riher.bkt.clouddn.com/Parquet%20%E4%BE%8B%E5%AD%902.png" alt=""></p>
<p>从上面的图看来，与 HBase 好像没有什么区别，但这只是为了让用户更好的了解数据才这样表示，其内部实现的机制与 HBase 完全不同，而且 Parquet 是真正的基于列式存储。其能够进行列式存储归功于 Striping/Assembly 算法。</p>
<p>算法我就不详细说了，<a href="http://www.infoq.com/cn/articles/in-depth-analysis-of-parquet-column-storage-format" target="_blank" rel="external">这篇文章</a>讲的很详细，我就不献丑了。</p>
<hr>
<p>参考资料：</p>
<ol>
<li>HBase 权威指南</li>
<li><a href="http://blog.javachen.com/2013/06/15/hbase-note-about-data-structure.html" target="_blank" rel="external">HBase笔记：存储结构</a></li>
<li><a href="http://www.infoq.com/cn/articles/in-depth-analysis-of-parquet-column-storage-format" target="_blank" rel="external">深入分析Parquet列式存储格式</a></li>
</ol>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/19/Scala - identity() 函数/">Scala - identity() 函数</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-19
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>最近在写 Spark 作业的时候，使用到了 <code>groupBy</code>和<code>sortBy</code>，在查找文档的时候，发现有的文档中的代码有着<code>groupBy(identity)</code>这样奇怪的写法。</p>
<p>在 Scala 文档中，<a href="http://www.scala-lang.org/api/current/scala/Predef$.html#identityA:A" target="_blank" rel="external">identity 函数</a>的作用就是将传入的参数“直接”当做返回值回传给调用者，这在正常使用中，可以说是毫无作用，但他在<code>groupBy</code>和<code>sortBy</code>等函数中的作用，在于避免程序员书写相同且容易出错的逻辑，原因如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 前提条件：</span></div><div class="line"><span class="keyword">val</span> array = <span class="type">Array</span>(<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">// 统计 array 中每个元素出现的次数</span></div><div class="line"><span class="comment">// 正常逻辑：</span></div><div class="line">array.groupBy(n =&gt; n)</div><div class="line"><span class="comment">// scala.collection.immutable.Map[Int,Array[Int]] = Map(5 -&gt; Array(5), 1 -&gt; Array(1, 1), 6 -&gt; Array(6), 9 -&gt; Array(9, 9), 2 -&gt; Array(2, 2), 7 -&gt; Array(7), 3 -&gt; Array(3), 4 -&gt; Array(4))</span></div><div class="line"></div><div class="line"><span class="comment">// 使用 identity</span></div><div class="line">array.groupBy(identity)</div><div class="line"></div><div class="line"><span class="comment">// 将 array 进行排序(升序)</span></div><div class="line"><span class="comment">// 正常逻辑：</span></div><div class="line">array.sortBy(n =&gt; n)</div><div class="line"><span class="comment">// Array[Int] = Array(1, 1, 2, 2, 3, 4, 5, 6, 7, 9, 9)</span></div><div class="line"></div><div class="line"><span class="comment">// 使用 identity 或者简化版本</span></div><div class="line">array.sortBy(identity)</div><div class="line">array.sorted</div></pre></td></tr></table></figure>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/06/分布式爬虫架构/">分布式爬虫架构</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-06
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>最近突然对爬虫框架很感兴趣，但一直无奈于没有服务器能让我捣鼓捣鼓，所以脑子就一直想如何去设计这个框架。翻了很多篇资料，总结了挺多经验，然后就画了下面这张架构图。个人认为很不成熟，但毕竟也是一种想法。希望能力提升后能够想到更加全面完善的架构。</p>
<p><img src="http://on83riher.bkt.clouddn.com/%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E6%9E%B6%E6%9E%84.png" alt="分布式爬虫架构"></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/01/22/大三上学期总结/">大三上学期总结</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-22
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p><strong>今天是周一（2018/01/22），是我正式作为小米实习生的第一天，也是我第一次远离熟悉的地方来到北京闯荡。</strong>经历过这学期磨人的课程后，经历过让人背书背的头大的毛概后，经历过曾经一度让人绝望的面试后，经历过令人心寒的租房后，终于可以安下心来好好写我的学期总结。</p>
<p>下面我就这学期的比较重要的方向进行总结吧。</p>
<ul>
<li><strong>学习</strong></li>
</ul>
<p>这学期课程真的比以往的多，几乎每天都要上至少两节课，甚至还得上整天，真让人疲惫不堪，但是真正觉得心累的，还是宿舍的氛围，还是像大二那样过一天是一天，不到找工作/临近考试的时候不会去努力。这学期我就尝试着每晚都去图书馆，但是就算是十点半回到宿舍还是无法得到一片宁静，因为十点半的时候，有个宿友准点吃鸡，而且很吵，吵到连看美剧都没心情。当时也怪自己没肯直说吧，暂时不说了，不想开始就写一长篇的抱怨。</p>
<p>虽然这学期很累，但是过得也算充实，毕竟我认清自己的学习方向了，之前在大二中我接触的是Web开发，偏向于云计算/微服务方面，但是每次接触的工程都只是学习工具，学习如何使用，然后反复造轮子，跟着规整的MVC架构来搭建项目，我对这一过程心生厌恶，觉得自己不能这样。于是乎我寻找了另一个兴趣点——大数据进行学习。大数据既是现在的热点，也是我最感兴趣的地方，每次都能借好多书走，学习到很多新的内容，新的架构。</p>
<p>这也是为什么我在找岗位的时候，想要寻找大数据方面的职位，一是充实自己，提高技能；二是在实际开发工程中，切身体会到如何真正的运用大数据来进行对数据分析。</p>
<ul>
<li><strong>简历</strong></li>
</ul>
<p>当初写简历的时候觉得还很自信，秉持着简约的风格的简历外加上整齐规格的排版，一定能够在一月份前拿到一份心满意足的offer。经历过整整三个星期都没有一通面试电话时，我真的很绝望，发自心底的绝望，认为这三年学的东西是不是白学了。后来经过很多同学的指点过后，<strong>我才发现一份简约的简历，要遵循以下几个点：</strong></p>
<ul>
<li>只能是一页纸，不能够再多</li>
<li>只写有用的话（姓名，联系电话，工作/校园经历）</li>
<li>排版要规整，粗细得体</li>
</ul>
<p>在这里真的要讲一句真心话，在正式修改了简历后，过没两天实习僧上的公司就真的给我面试电话通知了，而且后面陆陆续续也来了不少电话。</p>
<ul>
<li><strong>租房（注意粗体部分）</strong></li>
</ul>
<p>租房是个出来漂的首要大事啊，自从拿到offer后我就投入了租房这件事了，但是租房并不像想象中那么容易（除非你运气真的超级超级棒）。<strong>既要小心租房中遇到的中介/二房东/代理，还要小心合同中会不会收取额外的费用（中介费/物业管理费/燃气费/服务费），更要小心同住的人是否有良好的习惯。</strong>我几乎每晚回到宿舍都要花上二十分钟到半个小时，<strong>途径有豆瓣/自如（等各大互联网租房平台）/闲鱼/暖房（自动爬虫机制的网站，感觉还行）</strong>，其中遇到了有让人觉得恶心的中介，也遇到了聊得上天的转租大哥，但是由于自己不在北京的缘故，无法确切的看到实际房子的状况，所以一直犹豫着要不要直接租房（实际原因是没看到让人一眼看中的房子，或者碍于价格太高了）。</p>
<p>出于以上原因，我决定了考完试后联系好之前找好的中介/转租房东一一探寻房子。当时我是提前购买了凌晨到北京的机票，打算在机场中睡一觉就赶过去，所以我就在前一天晚上急忙去联系人预约看房，等到凌晨6点时就赶了过去，从西二旗地铁口出发后，暴走3公里后到达下榻酒店（暴走的原因是因为<strong>要亲自熟悉周边的环境，才好对房子进行更加深刻的评估</strong>），放下行李就跟着中介出去跑了。</p>
<p>真的是比较幸运，在早上十点钟时，中介带我找到了一个不错的房子，房子空间很大，内部装饰还行，价格中等偏上（相当于拿出一半的实习工资还多）。自己当时就想下定决心去签合同，不过出于谨慎，还是与家里人详细沟通了一下。在得到家里人的赞成后，我当时就和中介签的合同了（还是很<strong>比较谨慎的，看了好多回合同才肯签字，生怕有什么坑自己没注意</strong>）。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/11/27/聊聊log4j/">聊聊log4j</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-11-27
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><blockquote>
<p>最近在学习 Zookeeper 的时候，遇到了不少问题，想要在控制台中查看日志但是记录却死活不显示，于是找到了 /etc/zookeeper/log4j.properties 文件，但发现配置选项看不懂，想到之前在写 Web 应用的时候也是拿来就用，都没涉及到日志配置文件这一层面，所以打算整理一番。</p>
</blockquote>
<p>log4j 是一个用 Java 编写的可靠，快速和灵活的日志框架（API），它在 Apache 软件许可下发布。log4j 是高度可配置的，并可通过在运行时的外部文件配置。它根据记录的优先级别，并提供机制，以指示记录信息到许多的目的地，诸如：数据库，文件，控制台，UNIX 系统日志等。</p>
<h2 id="与-slf4j-的关系"><a href="#与-slf4j-的关系" class="headerlink" title="与 slf4j 的关系"></a>与 slf4j 的关系</h2><p>在实际开发当中，常常有人提醒我们，要使用 slf4j 来记录日志，为什么呢？</p>
<p>下面是 sl4fj 官网的介绍。</p>
<blockquote>
<p>The Simple Logging Facade for Java (SLF4J) serves as a simple facade or abstraction for various logging frameworks (e.g. java.util.logging, logback, log4j) allowing the end user to plug in the desired logging framework at deployment time.</p>
</blockquote>
<p>slf4j（Simple Logging Facade For Java，Java 简易日志门面）是一套封装 Logging 框架的抽象层，而 log4j 是 slf4j 下一个具体实现的日志框架，其中还有许许多多的成熟的日志框架，如 logback 等，也是从属于 slf4j。</p>
<p>使用 slf4j 可以在应用层中屏蔽底层的日志框架，而不需理会过多的日志配置、管理等操作。</p>
<h2 id="如何配置"><a href="#如何配置" class="headerlink" title="如何配置"></a>如何配置</h2><p>log4j 配置文件的基本格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#配置根Logger</div><div class="line">log4j.rootLogger = [level], appenderName1, appenderName2, ...</div><div class="line"></div><div class="line">#配置日志信息输出目的地 Appender</div><div class="line">log4j.appender.appenderName = fully.qualified.name.of.appender.class </div><div class="line">log4j.appender.appenderName.option1 = value1 </div><div class="line">log4j.appender.appenderName.optionN = valueN </div><div class="line"></div><div class="line">#配置日志信息的格式（布局）</div><div class="line">log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class</div><div class="line">log4j.appender.appenderName.layout.option1 = value1 </div><div class="line">log4j.appender.appenderName.layout.optionN = valueN</div></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>[level] - 日志输出级别，可分为以下级别（级别程度从上到下递增）：</li>
</ul>
<table>
<thead>
<tr>
<th>级别</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ALL</strong></td>
<td>所有级别，包括定制级别。</td>
</tr>
<tr>
<td><strong>TRACE</strong></td>
<td>比 DEBUG 级别的粒度更细。</td>
</tr>
<tr>
<td><strong>DEBUG</strong></td>
<td>指明细致的事件信息，对调试应用最有用。</td>
</tr>
<tr>
<td><strong>INFO</strong></td>
<td>指明描述信息，从粗粒度上描述了应用运行过程。</td>
</tr>
<tr>
<td><strong>WARN</strong></td>
<td>指明潜在的有害状况。</td>
</tr>
<tr>
<td><strong>ERROR</strong></td>
<td>指明错误事件，但应用可能还能继续运行。</td>
</tr>
<tr>
<td><strong>FATAL</strong></td>
<td>指明非常严重的错误事件，可能会导致应用终止执行。</td>
</tr>
<tr>
<td><strong>OFF</strong></td>
<td>最高级别，用于关闭日志。</td>
</tr>
</tbody>
</table>
<ul>
<li>Appender - 日志输出目的地，常用的 Appender 有以下几种：</li>
</ul>
<table>
<thead>
<tr>
<th>Appender</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>org.apache.log4j.ConsoleAppender</strong></td>
<td>输出至控制台</td>
</tr>
<tr>
<td><strong>org.apache.log4j.FileAppender</strong></td>
<td>输出至文件</td>
</tr>
<tr>
<td><strong>org.apache.log4j.DailyRollingFileAppender</strong></td>
<td>每天产生一个日志文件</td>
</tr>
<tr>
<td><strong>org.apache.log4j.RollingFileAppender</strong></td>
<td>文件容量到达指定大小时产生一个新的文件</td>
</tr>
<tr>
<td><strong>org.apache.log4j.WriterAppender</strong></td>
<td>将日志信息以输出流格式发送到任意指定地方</td>
</tr>
</tbody>
</table>
<ul>
<li>Layout - 日志输出格式，常用的 Layout 有以下几种：</li>
</ul>
<table>
<thead>
<tr>
<th>Layout</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>org.apache.log4j.HTMLLayout</strong></td>
<td>以 HTML 表格形式布局</td>
</tr>
<tr>
<td><strong>org.apache.log4j.PatternLauout</strong>（常用）</td>
<td>以格式化的方式定制布局</td>
</tr>
<tr>
<td><strong>org.apache.log4j.SimpleLayout</strong></td>
<td>包含日志信息的级别和信息字符串</td>
</tr>
<tr>
<td><strong>org.apache.log4j.TTCCLayout</strong></td>
<td>包含日志所在线程、产生时间、类名和日志内容等</td>
</tr>
</tbody>
</table>
<ul>
<li>打印参数（格式化输出格式，一般对应于 org.apache.log4j.PatternLauout）</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>%m</strong></td>
<td>输出代码中指定的消息</td>
</tr>
<tr>
<td><strong>%p</strong></td>
<td>输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL</td>
</tr>
<tr>
<td><strong>%r</strong></td>
<td>输出自应用启动到输出该log信息耗费的毫秒数</td>
</tr>
<tr>
<td><strong>%c</strong></td>
<td>输出所属的类目，通常就是所在类的全名。%c{1} 可取当前类名称</td>
</tr>
<tr>
<td><strong>%t</strong></td>
<td>输出产生该日志事件的线程名</td>
</tr>
<tr>
<td><strong>%n </strong></td>
<td>输出一个回车换行符，Windows平台为“\r\n”，Unix平台为“\n”</td>
</tr>
<tr>
<td><strong>%d</strong></td>
<td>输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式。标准格式为 %d{yyyy-MM-dd HH:mm:ss}</td>
</tr>
<tr>
<td><strong>%l </strong></td>
<td>输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。</td>
</tr>
</tbody>
</table>
<ul>
<li>option - 可选配置。一般来说每个 Appender 或者 Layout 都有默认配置，用户使用自定义日志配置，如指定输出地点等。常用的 option 有以下几种：</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>file</strong></td>
<td>日志输出至指定文件</td>
</tr>
<tr>
<td><strong>thresold</strong></td>
<td>定制日志消息的输出在不同 level 时的行为，</td>
</tr>
<tr>
<td><strong>append</strong></td>
<td>是否追加至日志文件中</td>
</tr>
</tbody>
</table>
<hr>
<p>参考资料：</p>
<p><a href="http://wiki.jikexueyuan.com/project/log4j/overview.html" target="_blank" rel="external">Log4J 教程 - 极客学院</a></p>
<p><a href="http://www.cnblogs.com/ITEagle/archive/2010/04/23/1718365.html" target="_blank" rel="external">log4j.properties配置详解</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/11/26/SpringMVC源码分析-DispatcherServlet请求处理过程/">SpringMVC源码分析 - DispatcherServlet请求处理过程</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-11-26
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><img src="http://on83riher.bkt.clouddn.com/DispatcherServlet%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A6%81.png" alt=""></p>
<blockquote>
<p>这张图在网上搜到的，但是实际的来源处实在找不到了，如果后面找到一定补上链接。</p>
</blockquote>
<p>上图的流程可用以下文字进行描述：</p>
<ol>
<li>DispatcherServelt 作为前端控制器，拦截所有的请求。</li>
<li>DispatcherServlet 接收到 http 请求之后， 根据访问的路由以及 HandlerMapping，获取一个 HandlerExecutionChain 对象。</li>
<li>DispatcherServlet 将 Handler 对象交由 HandlerAdapter，调用处理器 Controller 对应功能处理方法。</li>
<li>HandlerAdapter 返回 ModelAndView 对象，DispatcherServlet 将 view 交由 ViewResolver 进行解析，得到相应的视图，并用 Model 对 View 进行渲染。</li>
<li>返回响应结果。</li>
</ol>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>源码部分我打算通过流程图的形式来分析，源代码部分还是根据流程图来一步步看会更好，否则会被陌生且复杂的源代码给搞混（欲哭无泪）。</p>
<p><img src="http://on83riher.bkt.clouddn.com/DispatcherServlet%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82.png" alt=""></p>
<blockquote>
<p>DEBUG大法是真的好！</p>
</blockquote>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/11/26/SpringMVC源码分析-DispatcherServlet初始化过程/">SpringMVC源码分析 - DispatcherServlet初始化过程</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-11-26
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h2><p><img src="http://on83riher.bkt.clouddn.com/DispatcherServlet%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB.png" alt=""></p>
<p>从 DispatcherServlet 继承体系来看（蓝色部分），DispatcherServlet 继承自 FrameworkServlet，而 FrameworkServlet 又继承自 HttpServletBean ，最终 HttpSevletBean 继承了 HttpServlet 。通过这一步步继承封装之后，才构成了如今的 DispatcherSevlet 架构基础。</p>
<p>下面将自上到下来说明 DispatcherServlet 的初始化过程。</p>
<h2 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h2><p>HttpServletBean 继承自 Servlet 架构中的 HttpServlet 类，并重写了<code>init()</code>方法。</p>
<blockquote>
<p>Servlet 生命周期从创建到销毁的过程中，有三个重要的方法：</p>
<ul>
<li>init() - 负责初始化 Servlet 对象。在 Servlet 生命周期中只会调用一次。</li>
<li>service() - 负责响应客户的请求。每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service 方法中两个参数，分别是 ServletRequest 和 ServletResponse，用于传递 http 请求和回写。</li>
<li>destory() - 负责销毁 Servlet 对象。在 Servlet 生命周期中只会调用一次。</li>
</ul>
</blockquote>
<p>从 Servlet 的生命周期可知，在 <code>init()</code>方法中，我们可以进行初始化工作，HttpServletBean 正是也做了这样的工作。源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">      logger.debug(<span class="string">"Initializing servlet '"</span> + getServletName() + <span class="string">"'"</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// Set bean properties from init parameters.</span></div><div class="line">   <span class="comment">// 加载 Servlet 的配置文件(一般指 web.xml)</span></div><div class="line">   PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</div><div class="line">   <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">         BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</div><div class="line">         ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</div><div class="line">         bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</div><div class="line">         initBeanWrapper(bw); <span class="comment">// 上面做了这么多的工作，到这里却是一个空方法，而它的子类都没有去重写这个方法，个人认为这是想让开发者自定义如何管理 Servlet 配置吧</span></div><div class="line">         bw.setPropertyValues(pvs, <span class="keyword">true</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</div><div class="line">         <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</div><div class="line">            logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">throw</span> ex;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// Let subclasses do whatever initialization they like.</span></div><div class="line">   <span class="comment">// 交由子类(FrameworkServlet)来进行其特有的初始化工作</span></div><div class="line">   initServletBean();</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">      logger.debug(<span class="string">"Servlet '"</span> + getServletName() + <span class="string">"' configured successfully"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h2><p>FrameworkServlet 继承自 HttpServletBean，实现了<code>initServletBean()</code>方法。FrameworkServlet 在继承体系结构中，在 Servlet 与 SpringMVC 起到了承上启下的作用，它负责初始化 WebApplicationContext，还负责重写了 Servlet 生命周期中另外两个重要方法——<code>service()</code>和<code>destory()</code>，并改写了<code>doGet()</code>、<code>doPost()</code>等 http 方法，统一调用<code>processHandler()</code>方法来处理所有 http 请求。</p>
<blockquote>
<p>ApplicationContext 是 Spring 的核心，相当于 Spring 环境中的上下文。而在WebApplicationContext 继承自 ApplicationContext，充当了在 Web 环境中使用 Spring 的上下文。在 Web 环境中，WebApplicationContext 实例需要 ServletContext，即它必须拥有 Web 容器才能够完成启动的工作。</p>
</blockquote>
<p>下面重点讲<code>initServletBean()</code>方法，源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">   <span class="comment">// do sth</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// 初始化 WebApplicationContext</span></div><div class="line">      <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</div><div class="line">      initFrameworkServlet();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">catch</span> (ServletException ex) &#123;</div><div class="line">      <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</div><div class="line">      <span class="keyword">throw</span> ex;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">catch</span> (RuntimeException ex) &#123;</div><div class="line">      <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</div><div class="line">      <span class="keyword">throw</span> ex;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// initServletBean()转而调用了initWebApplicationContext()，所以重点工作在这里</span></div><div class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</div><div class="line">   WebApplicationContext rootContext =</div><div class="line">         WebApplicationContextUtils.getWebApplicationContext(getServletContext());</div><div class="line">   WebApplicationContext wac = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// A context instance was injected at construction time -&gt; use it</span></div><div class="line">      wac = <span class="keyword">this</span>.webApplicationContext;</div><div class="line">      <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</div><div class="line">         ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</div><div class="line">         <span class="keyword">if</span> (!cwac.isActive()) &#123;</div><div class="line">            <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</div><div class="line">               cwac.setParent(rootContext);</div><div class="line">            &#125;</div><div class="line">            configureAndRefreshWebApplicationContext(cwac);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></div><div class="line">      <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></div><div class="line">      <span class="comment">// that the parent context (if any) has already been set and that the</span></div><div class="line">      <span class="comment">// user has performed any initialization such as setting the context id</span></div><div class="line">      wac = findWebApplicationContext();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></div><div class="line">      wac = createWebApplicationContext(rootContext);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</div><div class="line">      <span class="comment">// DispatcherSevlet 初始化工作的入口就在这里！</span></div><div class="line">      onRefresh(wac);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// do sth</span></div><div class="line">   <span class="keyword">return</span> wac;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p>在进行下一步代码分析之前，先看下 DispatcherSevrlet 的静态代码块部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_STRATEGIES_PATH = <span class="string">"DispatcherServlet.properties"</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">   <span class="comment">// Load default strategy implementations from properties file.</span></div><div class="line">   <span class="comment">// This is currently strictly internal and not meant to be customized</span></div><div class="line">   <span class="comment">// by application developers.</span></div><div class="line">   <span class="comment">// 加载所有默认配置，用于后面的初始化工作</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">      ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);</div><div class="line">      defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not load '"</span> + DEFAULT_STRATEGIES_PATH + <span class="string">"': "</span> + ex.getMessage());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>DispatcherServlet.properties</code>配置文件中定义了DispatcherServlet各组件中的配置实现形式，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># Default implementation classes for DispatcherServlet&apos;s strategy interfaces.</div><div class="line"># Used as fallback when no matching beans are found in the DispatcherServlet context.</div><div class="line"># Not meant to be customized by application developers.</div><div class="line"></div><div class="line">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</div><div class="line">   org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</div><div class="line"></div><div class="line">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</div><div class="line">   org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</div><div class="line">   org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</div><div class="line"></div><div class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\</div><div class="line">   org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</div><div class="line">   org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</div><div class="line"></div><div class="line">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</div></pre></td></tr></table></figure>
<p>回到正题，在<code>onRefresh()</code>方法，调用了<code>initStrategies()</code>，所以重点部分就在于<code>initStrategies()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">   initStrategies(context);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">  	<span class="comment">// 初始化多媒体解析器</span></div><div class="line">    initMultipartResolver(context);</div><div class="line">    <span class="comment">// 初始化位置解析器</span></div><div class="line">    initLocaleResolver(context);</div><div class="line">  	<span class="comment">// 初始化主题解析器</span></div><div class="line">    initThemeResolver(context);</div><div class="line">  	<span class="comment">// 初始化 HandlerMappings</span></div><div class="line">    initHandlerMappings(context);</div><div class="line">  	<span class="comment">// 初始化 HandlerAdapters</span></div><div class="line">    initHandlerAdapters(context);</div><div class="line">  	<span class="comment">// 初始化异常处理解析器</span></div><div class="line">    initHandlerExceptionResolvers(context);</div><div class="line">  	<span class="comment">// 初始化请求到视图名转换器</span></div><div class="line">    initRequestToViewNameTranslator(context);</div><div class="line">  	<span class="comment">// 初始化视图解析器</span></div><div class="line">    initViewResolvers(context);</div><div class="line">  	<span class="comment">// 初始化 FlashMapManager</span></div><div class="line">    initFlashMapManager(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面以<code>initHandlerMappings()</code>方法为例，分析如何加载 HandlerMapping。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.handlerMappings = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;</div><div class="line">      <span class="comment">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span></div><div class="line">      Map&lt;String, HandlerMapping&gt; matchingBeans =</div><div class="line">            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">      <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</div><div class="line">         <span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());</div><div class="line">         <span class="comment">// We keep HandlerMappings in sorted order.</span></div><div class="line">         AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">         HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</div><div class="line">         <span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</div><div class="line">         <span class="comment">// Ignore, we'll add a default HandlerMapping later.</span></div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// Ensure we have at least one HandlerMapping, by registering</span></div><div class="line">   <span class="comment">// a default HandlerMapping if no other mappings are found.</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</div><div class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">         logger.debug(<span class="string">"No HandlerMappings found in servlet '"</span> + getServletName() + <span class="string">"': using default"</span>);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的源码注释解释的十分清楚了，值得注意一点的是，为了确保 DispatcherServlet 中至少有一个 HandlerMapping，它会从上面所述的默认配置项中加载所有默认组件，如 HandlerMapping 默认组件为 BeanNameUrlHandlerMapping、RequestMappingHandlerMapping。</p>
<hr>
<p>参考资料：</p>
<p><a href="http://www.cnblogs.com/klguang/p/4748922.html" target="_blank" rel="external">servlet清晰理解</a></p>
<p><a href="http://blog.csdn.net/zhulinu/article/details/7305247" target="_blank" rel="external">WebApplicationContext初始化</a></p>
<p><a href="http://wujiu.iteye.com/blog/2170778" target="_blank" rel="external">Spring MVC之DispatcherServlet初始化</a></p>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    
    
      <a class="next" href="/page/3/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:jianpeng957@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">jianpeng957</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
