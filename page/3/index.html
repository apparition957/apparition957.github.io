<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="APPARITION957" type="application/atom+xml">






<meta name="description" content="沉迷学习无法自拔">
<meta property="og:type" content="website">
<meta property="og:title" content="APPARITION957">
<meta property="og:url" content="http://apparition957.github.io/page/3/index.html">
<meta property="og:site_name" content="APPARITION957">
<meta property="og:description" content="沉迷学习无法自拔">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="APPARITION957">
<meta name="twitter:description" content="沉迷学习无法自拔">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://apparition957.github.io/page/3/">





  <title>APPARITION957</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">APPARITION957</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://apparition957.github.io/2017/11/26/SpringMVC源码分析-DispatcherServlet初始化过程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jianpeng957">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="APPARITION957">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/26/SpringMVC源码分析-DispatcherServlet初始化过程/" itemprop="url">SpringMVC源码分析 - DispatcherServlet初始化过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-26T23:58:09+08:00">
                2017-11-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h2><p><img src="http://on83riher.bkt.clouddn.com/DispatcherServlet%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB.png" alt=""></p>
<p>从 DispatcherServlet 继承体系来看（蓝色部分），DispatcherServlet 继承自 FrameworkServlet，而 FrameworkServlet 又继承自 HttpServletBean ，最终 HttpSevletBean 继承了 HttpServlet 。通过这一步步继承封装之后，才构成了如今的 DispatcherSevlet 架构基础。</p>
<p>下面将自上到下来说明 DispatcherServlet 的初始化过程。</p>
<h2 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h2><p>HttpServletBean 继承自 Servlet 架构中的 HttpServlet 类，并重写了<code>init()</code>方法。</p>
<blockquote>
<p>Servlet 生命周期从创建到销毁的过程中，有三个重要的方法：</p>
<ul>
<li>init() - 负责初始化 Servlet 对象。在 Servlet 生命周期中只会调用一次。</li>
<li>service() - 负责响应客户的请求。每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service 方法中两个参数，分别是 ServletRequest 和 ServletResponse，用于传递 http 请求和回写。</li>
<li>destory() - 负责销毁 Servlet 对象。在 Servlet 生命周期中只会调用一次。</li>
</ul>
</blockquote>
<p>从 Servlet 的生命周期可知，在 <code>init()</code>方法中，我们可以进行初始化工作，HttpServletBean 正是也做了这样的工作。源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Initializing servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">   <span class="comment">// 加载 Servlet 的配置文件(一般指 web.xml)</span></span><br><span class="line">   PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">   <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">         ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">         bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">         initBeanWrapper(bw); <span class="comment">// 上面做了这么多的工作，到这里却是一个空方法，而它的子类都没有去重写这个方法，个人认为这是想让开发者自定义如何管理 Servlet 配置吧</span></span><br><span class="line">         bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">            logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">   <span class="comment">// 交由子类(FrameworkServlet)来进行其特有的初始化工作</span></span><br><span class="line">   initServletBean();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Servlet '"</span> + getServletName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h2><p>FrameworkServlet 继承自 HttpServletBean，实现了<code>initServletBean()</code>方法。FrameworkServlet 在继承体系结构中，在 Servlet 与 SpringMVC 起到了承上启下的作用，它负责初始化 WebApplicationContext，还负责重写了 Servlet 生命周期中另外两个重要方法——<code>service()</code>和<code>destory()</code>，并改写了<code>doGet()</code>、<code>doPost()</code>等 http 方法，统一调用<code>processHandler()</code>方法来处理所有 http 请求。</p>
<blockquote>
<p>ApplicationContext 是 Spring 的核心，相当于 Spring 环境中的上下文。而在WebApplicationContext 继承自 ApplicationContext，充当了在 Web 环境中使用 Spring 的上下文。在 Web 环境中，WebApplicationContext 实例需要 ServletContext，即它必须拥有 Web 容器才能够完成启动的工作。</p>
</blockquote>
<p>下面重点讲<code>initServletBean()</code>方法，源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">   <span class="comment">// do sth</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化 WebApplicationContext</span></span><br><span class="line">      <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">      initFrameworkServlet();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initServletBean()转而调用了initWebApplicationContext()，所以重点工作在这里</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   WebApplicationContext rootContext =</span><br><span class="line">         WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">   WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">      wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line">      <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">         ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">         <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">               cwac.setParent(rootContext);</span><br><span class="line">            &#125;</span><br><span class="line">            configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">      <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">      <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">      <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">      wac = findWebApplicationContext();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">      wac = createWebApplicationContext(rootContext);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line">      <span class="comment">// DispatcherSevlet 初始化工作的入口就在这里！</span></span><br><span class="line">      onRefresh(wac);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// do sth</span></span><br><span class="line">   <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p>在进行下一步代码分析之前，先看下 DispatcherSevrlet 的静态代码块部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_STRATEGIES_PATH = <span class="string">"DispatcherServlet.properties"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">   <span class="comment">// Load default strategy implementations from properties file.</span></span><br><span class="line">   <span class="comment">// This is currently strictly internal and not meant to be customized</span></span><br><span class="line">   <span class="comment">// by application developers.</span></span><br><span class="line">   <span class="comment">// 加载所有默认配置，用于后面的初始化工作</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);</span><br><span class="line">      defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not load '"</span> + DEFAULT_STRATEGIES_PATH + <span class="string">"': "</span> + ex.getMessage());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DispatcherServlet.properties</code>配置文件中定义了DispatcherServlet各组件中的配置实现形式，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Default implementation classes for DispatcherServlet&apos;s strategy interfaces.</span><br><span class="line"># Used as fallback when no matching beans are found in the DispatcherServlet context.</span><br><span class="line"># Not meant to be customized by application developers.</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span><br><span class="line">   org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span><br><span class="line">   org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span><br><span class="line">   org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\</span><br><span class="line">   org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</span><br><span class="line">   org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</span><br></pre></td></tr></table></figure>
<p>回到正题，在<code>onRefresh()</code>方法，调用了<code>initStrategies()</code>，所以重点部分就在于<code>initStrategies()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">   initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 初始化多媒体解析器</span></span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    <span class="comment">// 初始化位置解析器</span></span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">  	<span class="comment">// 初始化主题解析器</span></span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">  	<span class="comment">// 初始化 HandlerMappings</span></span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">  	<span class="comment">// 初始化 HandlerAdapters</span></span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">  	<span class="comment">// 初始化异常处理解析器</span></span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">  	<span class="comment">// 初始化请求到视图名转换器</span></span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">  	<span class="comment">// 初始化视图解析器</span></span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">  	<span class="comment">// 初始化 FlashMapManager</span></span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面以<code>initHandlerMappings()</code>方法为例，分析如何加载 HandlerMapping。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.handlerMappings = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line">      <span class="comment">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">      Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class="line">         <span class="comment">// We keep HandlerMappings in sorted order.</span></span><br><span class="line">         AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</span><br><span class="line">         <span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">         <span class="comment">// Ignore, we'll add a default HandlerMapping later.</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Ensure we have at least one HandlerMapping, by registering</span></span><br><span class="line">   <span class="comment">// a default HandlerMapping if no other mappings are found.</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"No HandlerMappings found in servlet '"</span> + getServletName() + <span class="string">"': using default"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的源码注释解释的十分清楚了，值得注意一点的是，为了确保 DispatcherServlet 中至少有一个 HandlerMapping，它会从上面所述的默认配置项中加载所有默认组件，如 HandlerMapping 默认组件为 BeanNameUrlHandlerMapping、RequestMappingHandlerMapping。</p>
<hr>
<p>参考资料：</p>
<p><a href="http://www.cnblogs.com/klguang/p/4748922.html" target="_blank" rel="noopener">servlet清晰理解</a></p>
<p><a href="http://blog.csdn.net/zhulinu/article/details/7305247" target="_blank" rel="noopener">WebApplicationContext初始化</a></p>
<p><a href="http://wujiu.iteye.com/blog/2170778" target="_blank" rel="noopener">Spring MVC之DispatcherServlet初始化</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://apparition957.github.io/2017/11/14/Executor 框架 - 线程池/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jianpeng957">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="APPARITION957">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/14/Executor 框架 - 线程池/" itemprop="url">Executor 框架 - 线程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-14T12:25:11+08:00">
                2017-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>线程池（Thread Pool）是一种线程使用模式。当线程使用不当，创建过多时会带来调度的开销，进而影响缓存局部性和整体性能。而线程池维护着若干个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。</p>
<h2 id="重要成员"><a href="#重要成员" class="headerlink" title="重要成员"></a>重要成员</h2><p>在 Java 中，线程池一般都是通过 ThreadPoolExecutor 来构建的，下面将介绍 ThreadPoolExecutor 的构造函数部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>corePoolSize</td>
<td>线程池中所保存的核心线程数。线程池启动时默认是空的，只有任务来临时才会创建线程以处理请求。在 corePoolSize 范围内已创建的线程即使处于空闲状态，除非设置了 allowCoreThreadTimeOut，否则不会被销毁</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>线程池允许创建的最大线程数。</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>当线程池中的线程超过了 corePoolSize 的范围时，终止过多的空闲线程的时间</td>
</tr>
<tr>
<td>unit</td>
<td>keepAliveTime 的时间单位</td>
</tr>
<tr>
<td>workQueue</td>
<td>用于容纳所有待执行的任务的工作队列。该工作队列只能够容纳实通过 execute() 方法提交的实现 Runnable 接口的任务</td>
</tr>
<tr>
<td>threadFactory</td>
<td>用于 executor 如何创建一个线程（一般使用默认线程工厂DefaultThreadFactory）</td>
</tr>
<tr>
<td>handler</td>
<td>当线程池与工作队列的容量已满时，任务提交被拒绝时所采取的拒绝策略。</td>
</tr>
</tbody>
</table>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>以下流程为向线程池中正常提交任务时的基本流程：</p>
<ol>
<li>线程池判断核心线程池（corePoolSize）里的线程是否都在执行任务，如果不是，则创建一个新的工作线程（或复用一个工作线程）来执行任务。如果核心线程池里的线程都在执行任务，则执行第二步。</li>
<li>线程池判断工作队列（workQueue）是否已经满了。如果工作队列没有满，则将新提交的任务存储到工作队列中，等待被调度执行。如果工作队列已满，则执行第三步。</li>
<li>线程池判断线程池的线程是否已经满了（maximumPoolSize）。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则根据线程池的拒绝策略来处理该任务。</li>
</ol>
<p><img src="http://on83riher.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B1.png" alt=""></p>
<p><img src="http://on83riher.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B2.png" alt=""></p>
<blockquote>
<p>以上两图均来自于这篇博客<a href="http://blog.csdn.net/fuyuwei2015/article/details/72758179" target="_blank" rel="noopener">Java线程池(ThreadPoolExecutor)原理分析与使用 - 孙_悟__空</a></p>
</blockquote>
<h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>线程池中已经定义了四种任务提交的拒绝策略（以下策略我都贴出源码部分，怕翻译有问题）：</p>
<ul>
<li>AbortPolicy ：不执行任务，并直接抛出一个运行时异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A handler <span class="keyword">for</span> rejected tasks that <span class="keyword">throws</span> a RejectedExecutionException</span><br></pre></td></tr></table></figure>
<ul>
<li>DiscardPolicy ：（silently）直接抛弃任务，其内部实现是一个空方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A handler <span class="keyword">for</span> rejected tasks that silently discards the rejected task.</span><br></pre></td></tr></table></figure>
<ul>
<li>DiscardOldestPolicy ： 从工作队列中抛弃最老的未处理的任务，并尝试重新执行该任务。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A handler <span class="keyword">for</span> rejected tasks that discards the oldest unhandled request </span><br><span class="line">and then retries &#123;<span class="meta">@code</span> execute&#125;, unless the executor is shut down, in </span><br><span class="line">which <span class="keyword">case</span> the task is discarded.</span><br></pre></td></tr></table></figure>
<ul>
<li>CallerRunsPolicy ： 线程池直接创建一个 calling 线程来执行任务。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A handler <span class="keyword">for</span> rejected tasks that runs the rejected task directly in the </span><br><span class="line">calling thread of the &#123;<span class="meta">@code</span> execute&#125; method, unless the executor has </span><br><span class="line">been shut down, in which <span class="keyword">case</span> the task is discarded.</span><br></pre></td></tr></table></figure>
<hr>
<p>参考资料</p>
<p><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0" target="_blank" rel="noopener">线程池 - 维基百科，自由的百科全书</a></p>
<p><a href="http://www.cnblogs.com/nayitian/p/3262031.html" target="_blank" rel="noopener">Java：多线程，线程池，ThreadPoolExecutor详解</a></p>
<p><a href="http://blog.csdn.net/fuyuwei2015/article/details/72758179" target="_blank" rel="noopener">Java线程池(ThreadPoolExecutor)原理分析与使用</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://apparition957.github.io/2017/11/14/Executor 框架 - 概念/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jianpeng957">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="APPARITION957">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/14/Executor 框架 - 概念/" itemprop="url">Executor 框架 - 概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-14T10:19:26+08:00">
                2017-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Executor 框架是 Java 5 中引入的，位于 java.util.concurrent 包下，其内部使用了线程池机制，可用于启动、调度和管理多个线程。通过 Executor 来启动线程比使用 Thread 的 start 方法的好处不仅在于更易于管理，效率更好，还在于有助于避免 this 逃逸问题。</p>
<blockquote>
<p>this 逃逸问题是指在构造函数返回之前其他线程就持有该对象的引用。调用尚未构造完全的对象的方法可能会引发令人疑惑的错误。this 逃逸经常发生在构造函数中启动线程或注册监听器时。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> EscapeRunnable()).start();  </span><br><span class="line">        <span class="comment">// ...  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="comment">// 通过ThisEscape.this就可以引用外围类对象, 但是此时外围类对象可能还没有构造完成, 即发生了外围类的this引用的逃逸  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><p>Executor 框架包括有以下组件：</p>
<ul>
<li><strong>任务：</strong>包含被执行任务需要实现的接口：Runnable 接口和 Callable 接口。</li>
<li><strong>任务的执行：</strong>包括任务任务机制的核心接口 Executor，以及继承自Executor 接口的 ExecutorService 接口与 CompletionService 接口。</li>
<li><strong>异步计算的结果：</strong>包括接口 Future，以及实现 Future 接口的 FutureTask 类。</li>
</ul>
<h2 id="成员介绍"><a href="#成员介绍" class="headerlink" title="成员介绍"></a>成员介绍</h2><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p><strong>Executor是一个Executor 框架的核心接口</strong>，它内部只定义了一个方法<code>void execute(Runnable command)</code>，该方法接受一个 Runnable 实例，并将其执行。</p>
<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p><strong>ExecutorService接口继承自 Executor 接口，它提供了更加丰富的管理多线程的方法</strong>，比如，ExecutorService 接口提供了关闭自己的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。</p>
<p>ExecutorService 的生命周期包括三种状态：运行、关闭、终止。</p>
<ul>
<li><strong>运行</strong>：当实现 ExecutorService 接口的类的实例被创建后，便进入运行状态。</li>
<li><strong>关闭</strong>：当调用了 ExecutorService 接口内部提供的 shutdown 方法时，便平滑地进入关闭状态。平滑过渡是指在关闭状态中，ExecutorService 会停止接收任何新的任务，并且会等待所有已经提交的任务执行完成（已经提交的任务分为两类：一类是已经在执行的，另一类是还没有开始执行的）。</li>
<li><strong>终止</strong>：在所有已提交的任务执行完毕后，便进入了终止状态。</li>
</ul>
<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p><strong>Executors 提供了一系列工厂方法用于用于创建功能不同的线程池，所有返回的线程池都实现了ExecutorService 接口。</strong>以下为四种常见的线程池类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建固定数目线程的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">// 创建一个可缓存的线程池，调用 execute 将重用以前构造的线程(如果线程可用)。如果现有线程不可用，则创建一个新线程并添加到线程池中。终止并从缓存中移除那些已有60秒未被使用的线程</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">// 创建一个单线程化的线程池</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个支持定时以及周期性的任务执行的线程池，多数情况可代替 Timer 类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="Future-FutureTask-Callable-Runnable"><a href="#Future-FutureTask-Callable-Runnable" class="headerlink" title="Future/FutureTask/Callable/Runnable"></a>Future/FutureTask/Callable/Runnable</h3><p>在 JDK5 之后，任务可分为两类：一类是实现了 Runnable 接口的类，另一类是实现了 Callable 接口的类。<strong>两者都能够被 ExecutorService 执行，但两者区别在于，Runnable 任务没有返回值，而 Callable 任务有返回值，且能够抛出检查异常（checked exception）。</strong></p>
<p><strong>Future 接口对具体提交的任务，封装并提供了获取结果，任务取消等操作。执行结果可通过调用 get() 方法来获取，该方法会阻塞直到任务返回结果。FutureTask 则是 Future 接口的具体实现类。</strong></p>
<blockquote>
<p>Future 封装的 Runnable 任务可以调用 get() 方法，但是其返回值为 null。</p>
</blockquote>
<h3 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h3><p>若通过向线程池提交了若干个任务，并通过容器保存所有 FutureTask，当需要得到执行结果的时候，可以通过循环遍历 FutureTask 的方式，调用 get() 方法获取，但是如果此时 FutureTask 尚未完成，那么此时线程便会阻塞等待至任务运行结束。由于无法准确知道哪个任务将会优先执行完成，使用循环遍历的方式效率不会很高。</p>
<p><strong>在 JDK5 中提供了 CompletionService，其内部通过 BlockingQueue 来管理若干线程。ExecutorCompletionService 为 CompletionService 接口的具体实现类。</strong></p>
<ul>
<li>take() ：获取任务结果。获取并移除下一个已完成任务的 Future。如果任务不存在，则等待。</li>
<li>poll() : 与 take() 功能相同，不同之点在于任务不存在时，直接返回 null。</li>
</ul>
<blockquote>
<p>以上两种方法特性其实就是利用了 BlockingQueue 接口的特点。</p>
</blockquote>
<hr>
<p>参考资料</p>
<p><a href="http://wiki.jikexueyuan.com/project/java-concurrency/executor.html" target="_blank" rel="noopener">并发新特性—Executor 框架与线程池</a></p>
<p><a href="http://coolxing.iteye.com/blog/1464501" target="_blank" rel="noopener">变量可见性和volatile, this逃逸, 不可变对象, 以及安全公开–Java Concurrency In Practice C03读书笔记</a></p>
<p><a href="http://www.jianshu.com/p/8826a459471f" target="_blank" rel="noopener">Executor框架简介 - 加大装益达</a></p>
<p><a href="http://www.jianshu.com/p/c4a31f914cc7" target="_blank" rel="noopener">java并发编程之CompletionService - miaoLoveCode</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://apparition957.github.io/2017/11/11/《深入理解Java虚拟机》读书笔记 - 线程安全与锁优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jianpeng957">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="APPARITION957">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/11/《深入理解Java虚拟机》读书笔记 - 线程安全与锁优化/" itemprop="url">《深入理解Java虚拟机》读书笔记 - 线程安全与锁优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-11T16:32:18+08:00">
                2017-11-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>此篇为《深入理解Java虚拟机》第十三章13.2部分的读书笔记</p>
</blockquote>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><blockquote>
<p>对于线程安全较合适的定义为：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。</p>
</blockquote>
<h3 id="Java-语言中的线程安全"><a href="#Java-语言中的线程安全" class="headerlink" title="Java 语言中的线程安全"></a>Java 语言中的线程安全</h3><p>按照线程安全的“安全程度”由强至弱来排序，我们可以将 Java 语言中各种操作共享的数据分为以下5类：不可变、线程绝对安全、相对线程安全、线程兼容和线程对立。</p>
<ul>
<li>不可变</li>
</ul>
<p><strong>在 Java 中不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采用任何的线程安全保障措施。</strong>如果共享数据是一个基本数据类型，那么只要在定义时使用 final 关键字修饰它就可以保证它的不可变性；如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响，如 String。</p>
<ul>
<li>绝对线程安全</li>
</ul>
<p>在 Java 中要求一个类如同开头的定义一般，不管运行环境如何，调用者都不需要任何额外的同步措施。<strong>这种做法虽然是安全可用的，但是这往往都会付出很大的、甚至是不切实际的代价。</strong></p>
<ul>
<li>相对线程安全</li>
</ul>
<p><strong>相对的线程安全就是我们通常意义上的所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要额外的保证措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段保证调用的正确性。</strong>例如 Vector、Hashtable、Collections.synchronizedCollection() 方法包装的集合等。</p>
<blockquote>
<p>特别说明，Vector 内部函数都使用 synchronized 关键字修饰，看上去很安全，但如果调用者的操作不当，仍会出现不可避免的错误。即在查询一个元素的时候，某个线程就已经将这个元素删除了，那就会抛出 ArrayIndexOutOfBoundsException 异常。</p>
</blockquote>
<ul>
<li>线程兼容</li>
</ul>
<p><strong>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境下中可以安全使用。</strong>例如 Java API 中大部分的类都属于线程兼容，如与前面 Vector、Hashtable 内部所使用的就是 ArrayList 和 HashMap 等。</p>
<ul>
<li>线程对立</li>
</ul>
<p><strong>线程对立是指无论调用端是否采用了同步措施，都无法在多线程环境中并发使用的代码。</strong>由于 Java 语言天生具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常是有害的，应当尽量避免。比如 Thread 类中的 suspend() 和 resume() 方法，suspend() 试图中断线程，resume() 试图恢复线程，如果并发进行的话，会存在很大的死锁风险，所以这两个方法已被抛弃（@Depreacted）使用。</p>
<h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><blockquote>
<p>P390</p>
</blockquote>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>自 JDK1.5之后，HotSpot 虚拟机针对多线程并发花了十分的精力，去实现各种锁优化技术，如适应性自选（Adaptive Spinning）、锁清除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等。</p>
<h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>在线程互斥同步的时候，由于需要实现线程互斥，被阻塞线程需要由运行态转入阻塞态，而挂起线程和恢复线程的操作都需要从用户态转入到内核态中完成，这些操作给系统的并发性能带来了很大的压力。而往往线程并发时，线程共享数据的锁定状态只会持续很短的一段时间，为了这段时间选择去挂起和恢复线程是不值得的。</p>
<p><strong>那么就引出了自旋锁的作用：如果在同一时刻中有两个以上的线程并行执行，我们可以让后面请求锁的线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快地就会释放锁。但持有锁的线程依旧不放弃锁，那么为了最大化降低 CPU 的消耗，将正在自旋等待的线程使用传统的方式进行挂起阻塞等待。上面所述中，为了让线程等待，我们只需要让线程执行一个忙循环（自旋）即可。</strong></p>
<p>而在 JDK1.6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p><strong>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</strong>锁消除的主要判定依据来源于逃逸分析的数据支持。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p><strong>锁粗化是指虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，那将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</strong>例如，在 for 循环中进行对字符串拼接的任务进行加锁，那么锁粗化就会将这一操作外提至 for 循环外。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><strong>轻量级锁是相对于传统的锁机制操作而言的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁同步代码所带来的性能消耗。</strong>轻量级锁本质上是一种乐观锁的实现。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><strong>偏向锁是指在无竞争情况下，这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。</strong>如果轻量级锁是在无竞争情况下使用 CAS 操作去消除同步的互斥量，那么偏向锁就是在无竞争的情况下，把整个同步都消除掉，连 CAS 操作都不需要。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://apparition957.github.io/2017/11/06/从输入 URL 到页面加载完成的过程中都发生了什么事情/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jianpeng957">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="APPARITION957">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/06/从输入 URL 到页面加载完成的过程中都发生了什么事情/" itemprop="url">从输入 URL 到页面加载完成的过程中都发生了什么事情?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T21:00:01+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近看到了一道面试题，叫做“从输入 URL 到页面加载完成的过程中都发生了什么事情？”。当看到这道题的时候，就瞬间联想了计网中的五层模型，并想了想大致的流程，但是天真的我看了下网上的回答，发现实在太 naive 了。</p>
<p>下面总结了几篇文章，看看能不能找到时间梳理一遍。</p>
<ul>
<li><p>小白难度</p>
<p><a href="https://www.zhihu.com/question/34873227" target="_blank" rel="noopener">https://www.zhihu.com/question/34873227</a> - 知乎上评分较高的文章。</p>
</li>
<li><p>中等难度</p>
<p><a href="http://www.cnblogs.com/panxueji/archive/2013/05/12/3073924.html" target="_blank" rel="noopener">http://www.cnblogs.com/panxueji/archive/2013/05/12/3073924.html</a> - 翻译自网上一篇不错的科普文章。</p>
</li>
<li><p>地狱难度</p>
<p><a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="noopener">http://fex.baidu.com/blog/2014/05/what-happen/</a> - 对不起，这全篇我都没看懂，只想放上来纪念一下。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://apparition957.github.io/2017/11/06/HTTPS 机制原理分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jianpeng957">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="APPARITION957">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/06/HTTPS 机制原理分析/" itemprop="url">HTTPS 机制原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T20:29:51+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>超文本传输安全协议（Hypertext Transfer Protocol Secure，HTTPS） 是一种通过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司在1994年首次提出，随后扩展至互联网上。</p>
<p>HTTPS 顺应时代被发展出来的很大原因在于 HTTP 协议本身的不安全性，即 HTTP 协议传输的内容是不加密的，直接由明文的方式传输，在复杂的网络通信容易被黑客截取，比如<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">中间人攻击</a>等手段。所以在发展 HTTP为前提下，网景公司加入了 SSL（Secure Socket Layer，安全套接字层） ，并在随后的发展过程中，扩展了 TSL（Transport Layer Security，传输层安全），如下所示：</p>
<div align="center"><br><img src="http://on83riher.bkt.clouddn.com/HTTPS%20%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt=""><br></div>

<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><p>在了解 HTTPS 如何在信息传输过程中保证数据的安全性前，需要了解下述的一些术语解释：</p>
<ul>
<li>对称加密</li>
</ul>
<p><strong>对称加密是指对数据进行加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。</strong>对称加密优点在于算法公开，计算量小，加解密效率高，但是其明显的缺点在于若密钥在网络传输过程中被黑客截取，那么黑客就能够正确地解析数据，那么这样就无法保证数据的安全了。</p>
<ul>
<li>非对称加密</li>
</ul>
<p><strong>非对称加密，与对称加密正好相反，该算法需要两个密钥：公开密钥（public key）和私有密钥（private key）。</strong>公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。其最大的优点在于安全性大大提高，原因在于数据接收方的私钥一般处于不公开的状态，黑客在获取数据的时候，无法通过私钥正确解析数据。那么其缺点，相对于对称加密，在于计算量大，加解密时效率较低。</p>
<ul>
<li>哈希算法</li>
</ul>
<p>哈希算法是一种单向密码体制，即它是一个从明文到密文的不可逆的映射，只有加密过程，没有解密过程。同时,哈希函数可以将任意长度的输入经过变化以后得到固定长度的输出。哈希算法在 HTTPS 的应用当中起了数据校验和的作用。</p>
<ul>
<li>数字证书</li>
</ul>
<p>数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件。它是一种权威性的电子文档，具有极高的安全性和可依赖性。</p>
<ul>
<li>数字签名</li>
</ul>
<p>数字签名就是在 HTTPS 验证过程中，用指定的哈希算法将信息进行哈希华后，将所得的值附加在信息后面，用于在数据传输后，方便信息接收端对数据进行校验，确保信息没有被恶意篡改。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><div align="center"><br><img src="http://on83riher.bkt.clouddn.com/HTTPS%20%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png" alt=""><br></div>

<blockquote>
<p>图源来自于<a href="https://www.cnblogs.com/zery/p/5164795.html" target="_blank" rel="noopener">HTTPS 原理解析</a> ，这张画的实在太棒了！</p>
</blockquote>
<ol>
<li><p>客户端首先从发送一个 HTTPS 请求，将自己所支持的加密算法，通知服务器端。</p>
</li>
<li><p>服务器端从客户端发来的加密算法列表中，选出一种加密算法和 HASH 算法，并将其自身的数字证书附加选出的算法一并发回给客户端。而证书中一般包含了网站的地址，公钥，证书失效日期以及证书的颁发机构等等。</p>
</li>
<li><p>客户端在收到服务器端的响应之后，会做一下几件事：</p>
<p>1）验证证书的合法性。一般通过证书的颁发机构是否是合法的、证书是否超过失效日期、证书中所包含的网站地址是否与你正在所访问的相同等方面进行验证。若证书合法，则通过验证，否则将提示用户该证书存在风险。</p>
<p>2）生成随机密码。在证书通过验证，或用户主动信任该证书后，客户端会随机生成一串序列号，并使用服务器端传来的公钥进行加密，并生成握手消息。</p>
<p>3）HASH 算法加密信息。利用服务器端所回传的 HASH 算法将客户端生成的握手信息进行加密，并将加密后的 HASH 值附加上握手消息中，用于数据校验。</p>
</li>
<li><p>服务器端接收到客户端的请求后，同样也会做下面几件事：</p>
<p>1）使用自己的私钥来解密客户端所传来的握手消息，得到客户端生成的随机序列号。在这一部分过程中就运用了非对称加密的技术。</p>
<p>2）使用随机序列号，对握手消息进行 HASH 算法加密，并将获得的 HASH 值与从客户单一并传来的 HASH 值进行对比，查看是否一致。</p>
<p>3）最后，使用该随机序列号，再用公钥加密一段握手消息，并附加上该握手消息的 HASH 值，发回给客户端。</p>
</li>
<li><p>客户端接收到服务器端的请求后，用生成的随机序列号对握手消息进行解密，并对比传来的 HASH 值是否一致。倘若 HASH 值一直，则握手过程正式结束，之后的所有通信将由客户端所生成的随机序列号并利用加密算法对消息进行加密处理。</p>
</li>
</ol>
<hr>
<p>参考资料</p>
<p><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">超文本传输安全协议</a></p>
<p><a href="http://blog.csdn.net/zhongzh86/article/details/69389967" target="_blank" rel="noopener">深度解析HTTPS原理</a></p>
<p><a href="http://www.jianshu.com/p/650ad90bf563" target="_blank" rel="noopener">简单粗暴系列之HTTPS原理</a></p>
<p><a href="http://www.cnblogs.com/zery/p/5164795.html" target="_blank" rel="noopener">HTTPS 原理解析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://apparition957.github.io/2017/11/05/《深入理解Java虚拟机》读书笔记 - 类加载机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jianpeng957">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="APPARITION957">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/05/《深入理解Java虚拟机》读书笔记 - 类加载机制/" itemprop="url">《深入理解Java虚拟机》读书笔记 - 类加载机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-05T21:19:02+08:00">
                2017-11-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>此篇为《深入理解Java虚拟机》第七章7.2、7.3、7.4部分的读书笔记</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p>
<h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p><strong>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Loading）、准备（Loading）、解析（Loading）、初始化（Loading）、使用（Loading）、卸载（Loading）7个阶段。</strong>其中验证、准备、解析3个部分统称为连接（Linking），这7个阶段的发生顺序如下所示。</p>
<div align="center"><br><img src="http://on83riher.bkt.clouddn.com/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt=""><br></div>

<p>注意两点：</p>
<ul>
<li>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类加载过程必须按照这个顺序进行，而解析阶段因为需要支持 Java语言的运行时绑定，可以在初始化阶段之后开始。</li>
<li>类加载时，这7个阶段虽然必须是要按顺序开始，但是并不要求7个阶段按顺序结束，它们通常以交叉混合式进行的。</li>
</ul>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>“加载”是“类加载”（Class Loading）过程的一个阶段。在加载阶段，虚拟机需要完成以下3件事情：</p>
<ul>
<li><strong>通过一个类的全限定名来获取定义此类的二进制字节流。</strong></li>
<li><strong>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</strong></li>
<li><strong>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</strong></li>
</ul>
<p>注意这里不一定非要从 Class 文件中获取，在这个阶段中，既可以从以下几个不同地方获取：</p>
<ul>
<li>从ZIP 包中读取（JAR、EAR、WAR 格式的包也可以）。</li>
<li>从网络中获取。一般应用场景为RMI。</li>
<li>运行时计算生成。一般应用场景为动态代理。</li>
<li>由其他文件生成。一般应用场景为 JSP 应用。</li>
<li>从数据库中读取。</li>
<li>…</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><strong>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</strong></p>
<p>验证阶段是非常重要的，这个阶段是否严谨，直接决定了 Java 虚拟机是否能承受恶意代码的攻击，从执行性能的角度上讲，验证阶段的工作量是在虚拟机的类加载子系统中又占了相当大的一部分。</p>
<p>在验证阶段中，大致会完成下面4个阶段的校验工作：</p>
<ul>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始化值的阶段，这些变量所使用的内存都将在方法区中进行分配。</strong>这个阶段需要注意以下两点：</p>
<ul>
<li><strong>准备阶段进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。</strong></li>
<li><strong>这个阶段的初始化值，在通常情况下，是数据类型的所对应的零值</strong>，假设一个类变量的定义为：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>那变量 value 在准备阶段过后的初始值为0而不是123，真正的赋值操作将延迟到初始化阶段进行。但若上述的类变量 value 的定义变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> finla value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>那么，在编译时虚拟机将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为123。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用通常以 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等类型的常量出现。下面将解释符号引用和直接引用的关系：</p>
<ul>
<li><strong>符号引用（Symbolic References）</strong>：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。各个虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。</li>
<li><strong>直接引用（Direct References）</strong>：直接引用可以是直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经存在于内存中。</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>类初始化阶段是类加载过程的最后一步，前面的类加载过程之中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其他动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。</strong></p>
<p><strong>初始化阶段是执行类加载器<code>&lt;clinit&gt;()</code>方法的过程。</strong></p>
<ul>
<li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。</li>
</ul>
<blockquote>
<p>为什么能够赋值，但不能访问呢？个人认为在运行期间的准备阶段时，类变量已经经过了零值的初始化了，所以赋值操作是正常进行的，但是在编译期间，编译器认为这种操作是错误的（非法向前引用）。</p>
</blockquote>
<ul>
<li><code>&lt;clinit&gt;()</code>方式与类的构造函数（或者说是实例构造器<code>&lt;init&gt;()</code>方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。因此在虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类肯定是 java.lang.Object。</li>
<li>由于父类的<code>&lt;clinit&gt;()</code>方法优先执行，那么父类中的静态语句块也优先于子类执行。</li>
<li><code>&lt;clinit&gt;()</code>方法对于类和接口并不是必需的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口和类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化阶段也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</li>
<li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁，同步，如果多线程同时去初始化一个类，那么只有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>虚拟机设计团队把类加载阶段中的加载动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为”类加载器“。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在其 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立类名称空间。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由 Java 语言实现的，独立于虚拟机外部，并且全部继承自抽象类 java.lang.ClassLoader。</p>
<p>从 Java 开发人员的角度来看，绝大部分 Java 程序都会使用以下3种系统提供的类加载器：</p>
<ul>
<li><strong>启动类加载器（Bootstrap ClassLoader）</strong>：这个类加载器负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录中的，或者被<code>-Xbootclasspath</code>参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使存放在 lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接饮用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，那直接使用 null 代替即可。</li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong>：这个类加载器有<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>，目录中的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库。开发者可以直接使用扩展类加载器。</li>
<li><strong>应用程序类加载器（Application ClassLoader）</strong>：这个类加载器由<code>sun.misc.Launcher$AppClassLoader</code>实现，它负责加载用户类路径（ClassPath）上所指定的类库。开发者可以直接使用应用程序类加载器。</li>
</ul>
<p>如下图所示，<strong>以上的类加载器之间的层次关系，称之为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应当有自己的父类加载器。这里的类加载器之间的父子关系一般不会以继承的关系来实现，而都是通过组合关系来复用父类加载器的代码。</strong></p>
<div align="center"><br><img src="http://on83riher.bkt.clouddn.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt=""><br></div>

<blockquote>
<p>类加载的双亲委派模型不是虚拟机中强制性的约束模型，而是 Java 设计者推荐给开发者的一种类加载实现方式。</p>
</blockquote>
<p><strong>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试去加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（即他的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</strong></p>
<p>采用双亲委派模型的好处在于，Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。<strong>无论是哪一个类加载器要加载某个类，最终都是委派给处于模型最顶端的的启动类加载器进行加载，这样保证了 Java 类在程序的各种类加载器环境中都是同一个类。</strong></p>
<p>下面为简单解释一下实现双亲委派模型的关键代码<code>loadClass()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 首先，检查类是否已经被加载到内存中</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              	<span class="comment">// 这一步中运用了双亲委派模型。</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  </span><br><span class="line">              		<span class="comment">// 当该类加载器中存在父类加载器，那么就调用其父类加载器来响应加载类的请求</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  	<span class="comment">// 如果没有父类加载器，那么说明该类加载器为启动类加载器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line">				<span class="comment">// ...其余代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><blockquote>
<p>具体操作实现在P231。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://apparition957.github.io/2017/11/05/理解悲观锁与乐观锁/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jianpeng957">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="APPARITION957">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/05/理解悲观锁与乐观锁/" itemprop="url">理解悲观锁与乐观锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-05T14:58:26+08:00">
                2017-11-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>维基百科这样解释：在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，PCC）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作读某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。</p>
<p>悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。</p>
<p>从上述的解释可以知道，悲观锁是从一个悲观的角度看待用户操作，在用户想要操作数据时，悲观锁会“悲观”地认为其他用户也想要同时对同一数据进行操作，从而要求用户先获取锁，再进行操作，保证了用户操作的安全性。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ul>
<li>通过“先取锁后访问”的保守策略，为数据处理的安全提供了保证。</li>
</ul>
<p>缺点：</p>
<ul>
<li>对数据加锁会让数据库系统产生额外的开销，还增加了死锁的机会。</li>
<li>在只读型事务处理中由于不会产生冲突，使用悲观锁，只会增加系统负载，降低并行性。</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select status from goods where id=1 for update; # for update 用于开启排它锁</span><br><span class="line">update goods set status=2;</span><br></pre></td></tr></table></figure>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>维基百科这样解释：在关系数据库管理系统中，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，OCC）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自的那部分数据。在提交数据更新之前，每个事务都会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务更新的话，正在提交的事务会进行回滚。</p>
<p>乐观并发控制多用于数据争用不大、冲突较少的环境下，这种环境中，偶尔回滚事务的成本会低于读取数据时锁定数据的成本，因为可以获得比其他并发控制方法更高。</p>
<p>从上述的解释可以知道，相较于悲观锁，乐观锁决定从一个乐观的角度看待用户操作。在用户想要操作数据时，乐观锁会“乐观”地认为其他用户不会同时进行对同一数据进行操作的，而当用户对数据进行再次提交时，乐观锁才会对数据是否被修改进行检测，如果被修改过只能放弃当前操作。</p>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ul>
<li>乐观并发控制相信事务之间的数据竞争的概率比较小，所以在事务处理过程中不会出现任何锁，或产生死锁现象。</li>
</ul>
<p>缺点：</p>
<ul>
<li>在系统并发量大的情况下，事务发生冲突的概率会大大增加，系统可用性会降低，用户体验也会随着操作不断失败而降低。</li>
</ul>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>在乐观锁中，一般会采用以下两种机制来记录数据的唯一性：</p>
<ul>
<li>数据版本（Version）。数据版本，即为数据增加一个版本标识，一般是通过为数据库增加一个数字类型的“version”字段来实现的。当读取数据时，将 version 字段的值一同读出，数据每更新一次，对此 version 的值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的 version 值进行比对，如果数据库当前版本号与第一次取出来的 version 值相等，则予以更新，否则认为是过期数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select status, version from goods where id=1;</span><br><span class="line">update goods set status=2, version=version+1 where id=1 and version=version;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间戳（timestamp）。使用方式与数据版本相同，只是字段类型为时间戳而已。</li>
</ul>
<blockquote>
<p>顺带一提，Java并发中的 CAS 机制也是乐观锁机制。</p>
</blockquote>
<hr>
<p>参考资料</p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%82%B2%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">悲观并发控制</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">乐观并发控制</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://apparition957.github.io/2017/11/04/《深入理解Java虚拟机》读书笔记 - Java内存模型与线程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jianpeng957">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="APPARITION957">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/04/《深入理解Java虚拟机》读书笔记 - Java内存模型与线程/" itemprop="url">《深入理解Java虚拟机》读书笔记 - Java内存模型与线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-04T17:24:52+08:00">
                2017-11-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>此篇为《深入理解Java虚拟机》第十二章12.3、12.4部分的读书笔记</p>
</blockquote>
<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p><strong>Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台上都能达到一致的内存访问效果。</strong></p>
<p>定义 Java 内存模型并非一件容易的事情：这个模型必须定义得足够严谨，才能让 Java 的并发内存访问操作不会产生歧义；但是，也必须定义得足够宽松，使得虚拟机的实现有足够的自由空间去利用硬件的各种特性（寄存器，高速缓冲和指令集中某些特有的指令）来获得更好的执行速度。</p>
<h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p><strong>Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</strong>此处的变量（Variables）与 Java 编程所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效率，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。</p>
<p><strong>Java 内存模型规定了所有的变量都存储在主内存中（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</strong>线程、主内存、工作内存三者关系图如下所示。</p>
<p><div align="center"><br><img src="http://on83riher.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E3%80%81%E4%B8%BB%E5%86%85%E5%AD%98%E3%80%81%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt=""><br></div><br>这部分中与前面笔记中所记录的 Java 内存区域并不是同一层次的内存划分，两者基本上没有什么关系。</p>
<h3 id="内存间互相操作"><a href="#内存间互相操作" class="headerlink" title="内存间互相操作"></a>内存间互相操作</h3><p>这一部分中， Java 内存模型定义了8种操作来完成主内存与工作内存之间的具体变量交互工作：lock（锁定）、unlock（解锁）、 read（读取）、load（载入）、 use（使用）、assign（ 赋值）、 store（存储）、 write（ 写入），虚拟机实现时必须保证以上所有操作都是原子的、不可再分的。</p>
<blockquote>
<p>具体操作实现在P364。</p>
</blockquote>
<h3 id="对于-volatile-型变量的特殊规则"><a href="#对于-volatile-型变量的特殊规则" class="headerlink" title="对于 volatile 型变量的特殊规则"></a>对于 volatile 型变量的特殊规则</h3><p>关键字 volatile 是 Java 虚拟机所提供的轻量级同步机制。当一个变量定义为 volatile 之后，它将具备两种特性：</p>
<ul>
<li><p><strong>保证此变量对所有线程的可见性。</strong>这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递需要通过主内存来完成。例如：线程 A 修改一个普通变量的值，然后向主内存进行回写，另外一条线程 B 在线程 A 回写完成了之后再从主内存进行读取操作，新变量值才会对线程 B 可见。</p>
<blockquote>
<p>由于 volatile 变量只能保证可见性，而无法保证操作的原子性。在不符合以下两条规则的运算场景下，我们仍然需要加锁机制来保证操作原子性：</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程来修改变量的值</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
</blockquote>
</li>
<li><p><strong>禁止指令重排序优化。</strong>普通的变量仅仅会保证在该方法的执行中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作顺序与代码执行顺序一致。</p>
</li>
</ul>
<p>在于 volatile 的性能提升方面，可得出：volatile 变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入许多内存屏蔽指令保证处理器不发生乱序执行。不过即使如此，大多数场景下 volatile 的总开销仍然要比锁低，我们在 volatile 与锁之间的选择依据只取决于 volatile 是否能够满足当前场景所需的并发要求。</p>
<h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>如果 Java 内存模型中所有的有序性都仅仅依靠 volatile 和 synchronized 来完成，那么有一些操作将会变得很烦琐，但是在实际编程当中，Java 语言内部中存在一种“先行发生”（happens-before）的原则来保证代码在正常情况下的并发处理。</p>
<p>先行发生是 Java 内存模型中定义的两项操作之间的偏序关系，如果说操作 A 先行于操作 B，其实就是说在发生操作 B 之前，操作 A 产生的影响能被操作 B 观察到，“影响”包括了修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p>下面是 Java 内存模型中一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则中推导出来，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。</p>
<ul>
<li><strong>程序次序规则（Program Order Rule）</strong>：在一个线程内，按照程序代码顺序，书写在前面的操作先行于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码，因为需要考虑分支、循环等结构。</li>
<li><strong>管程锁定规则（Monitor Lock Rule）</strong>： 一个 unlock 操作先行发生于后面（特指时间顺序）对同一个锁的 lock 操作。</li>
<li><strong>volatile 变量规则（Volatile Variable Rule）</strong>： 对一个 volatile 变量的写操作先行发生于后面（特指时间顺序）对这个变量的读操作。</li>
<li><strong>线程启动规则（Thread Start Rule）</strong>：Thread 对象的 start() 方法先行发生于此线程的每一个动作。</li>
<li><strong>线程终止规则（Thread  Termination Rule）</strong>： 线程中的所有操作都先行发生于对此线程的终止检测。</li>
<li><strong>线程中断规则（Thread   Interruption Rule）</strong>： 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li>
<li><strong>对象终结规则（Finalizer Rule）</strong>：  一个对象的初始化完成（构造函数的结束）先行发生于它的 finalize() 方法的开始。</li>
<li><strong>传递性（ Transitivity）</strong>：  如果操作 A 先行发生于操作 B，而操作 B 先行发生于操作 C，那就可以推导出操作 A 先行发生于操作 C 的结论。</li>
</ul>
<h2 id="Java-与线程"><a href="#Java-与线程" class="headerlink" title="Java 与线程"></a>Java 与线程</h2><h3 id="线程创建-amp-线程调度"><a href="#线程创建-amp-线程调度" class="headerlink" title="线程创建&amp;线程调度"></a>线程创建&amp;线程调度</h3><blockquote>
<p>P379，与操作系统创建线程相同，因为 Java 线程创建与线程调度的操作就是基于操作系统的。</p>
</blockquote>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><ul>
<li><p><strong>新建（New）</strong>：创建后尚未未启动的线程。</p>
</li>
<li><p><strong>运行（Runable）</strong>：线程有可能正在运行，或也有可能正在等待CPU为它分配执行时间。</p>
</li>
<li><p><strong>无限期等待（Waiting）</strong>：不会被分配CPU执行时间，要等待被其他线程显式唤醒，以下方法会让线程处于无限期的等待状态：</p>
<ul>
<li>没有设置 Timeout 参数的 Object.wait() 方法。</li>
<li>没有设置 Timeout 参数的 Thread.join() 方法。</li>
<li>LockSupport.park() 方法。</li>
</ul>
</li>
<li><p><strong>限期等待（Timed Waiting）</strong>：不会被分配CPU执行时间，不需要等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒，以下方法会让线程处于限期的等待状态：</p>
<ul>
<li>Thread.sleep() 方法。</li>
<li>设置了 Timeout 参数的Object.wait() 方法。</li>
<li>设置了 Timeout 参数的Thread.join() 方法。</li>
<li>LockSupport.parkNanos() 方法。</li>
<li>LockSupport.parkUntil() 方法。</li>
</ul>
</li>
<li><p><strong>阻塞（Blocked）</strong>：线程被阻塞了，在等待获取一个排它锁。例如线程A和B在执行同步方法C时，线程A先拿到排它锁，那么线程B的状态就是阻塞状态，等待线程B释放排它锁。</p>
</li>
<li><p><strong>结束（Terminated）</strong>：线程执行完毕。<br><div align="center"><br><img src="http://on83riher.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB.png" alt=""><br></div><br>​</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://apparition957.github.io/2017/11/03/《深入理解Java虚拟机》读书笔记 - 垃圾回收机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jianpeng957">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="APPARITION957">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/03/《深入理解Java虚拟机》读书笔记 - 垃圾回收机制/" itemprop="url">《深入理解Java虚拟机》读书笔记 - 垃圾回收机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-03T19:08:31+08:00">
                2017-11-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>此篇为《深入理解Java虚拟机》第三章3.1、3.2、3.3部分的读书笔记</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>在垃圾收集（Garbage Collection，GC）中，我们需要考虑以下三个问题：</strong></p>
<ul>
<li><strong>哪些内存需要回收？</strong></li>
<li><strong>什么时候回收？</strong></li>
<li><strong>如何回收？</strong></li>
</ul>
<p>经过半个多世纪的发展，目前内存的动态分配与内存回收技术已经相当成熟，一切看起来都进入“自动化”时代，那为什么我们还要去了解 GC 和内存分配呢？答案很简单：当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p>
<h2 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h2><p>在堆里面存放着 Java 世界中几乎所有的对象实例，垃圾收集器在对堆进行垃圾回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。</p>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p><strong>引用计数算法是指：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</strong></p>
<p>客观地说，引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，但是，至少在主流的 Java 虚拟机里面没有选用引用计数拳算法来管理内存，其中主要的原因是<strong>它很难解决对象之间互相循环引用的问题</strong>。</p>
<p>举个例子，若 Java 堆上同时存在 objA 和 objB 两个对象，两个对象中都有字段 instance，赋值令 objA.instance = objB 以及 objB.instance = objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数不为0，于是引用计数算法无法通知 GC 收集器来回收它们。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p><strong>可达性分析算法是指：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说，就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。</strong>如下图所示，对象 object5、object6、object7虽然互相有关联，但是它们到 GC Roots 是不可达的，所以它们将会被判定为是可回收对象。</p>
<p><div align="center"><br><img src="http://on83riher.bkt.clouddn.com/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png" alt=""><br></div><br>在 Java 语言中，可作为 GC Roots 的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li>
</ul>
<h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是都存活都与“引用”有关。<strong>对于对象“引用”的准确定义，希望通过这种方式来描述：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集之后还是非常紧张，则可以抛弃这些对象。</strong>很多系统的缓存功能都符合这样的应用场景。</p>
<p>在 JDK1.2之后，Java 对引用的概念进行了补充，将引用以下四类，并且这四种引用强度自上到下依次减弱。</p>
<ul>
<li><strong>强引用（Strong Reference）。</strong>强引用就是指在程序之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li><strong>软引用（Soft Reference）。</strong>软引用是用来描述一些还有用但并非必需的对象。对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出的异常。</li>
<li><strong>弱引用（Weak Reference）。</strong>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</li>
<li><strong>虚引用（Phantom Reference）。</strong>虚引用也称为幽灵引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，<strong>要真正宣告一个对象死亡，至少要经历两次标记过程</strong>：如果对象在进行可达性分析之后，发现没有与 GC Roots 相连接的引用链，那么它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两次情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这个所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在 finalize() 方法中执行缓慢，或者发生了死循环，将很可能会导致 F-Queue 队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。</p>
<p> finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 会对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this 关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的就被回收了。</p>
<blockquote>
<p>任何一个对象的 finalize() 方法都只会被系统自动调用一次，如果面临第二次回收，那么它的 finalize()方法将不会被调用。</p>
<p>对于 finalize() 方法，应该尽可能避免使用，因为这个 Java 在较早之前对于 C/C++程序员的妥协，最主要的原因是它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。所以了解它的概念，在实际使用上忽略它的存在即可。</p>
</blockquote>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p><strong>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除“两个阶段：首先标记处所有需要回收的对象，在标记完成后，统一回收所有被标记的对象（标记过程参考上一小节）。</strong>之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。</p>
<p>它的主要不足有两个：</p>
<ul>
<li>一个是效率问题，标记和清除两个过程的效率并不高</li>
<li>一个是空间问题，标记清楚之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br><div align="center"><br><img src="http://on83riher.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt=""><br></div><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3></li>
</ul>
<p><strong>为了解决效率问题，一种称为”复制“（Copying）的收集算法出现了，他将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配即可，实现简单，运行高效。</strong>只是这种算法的代价是将内存缩小为原来的一半，分配可能过高了。</p>
<p><div align="center"><br><img src="http://on83riher.bkt.clouddn.com/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt=""><br></div><br>按照 IBM 的研究表明，新生代中的对象98%都是”朝生夕死“的。所以内存分配的常见做法是：将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。</p>
<p> 在 HotSpot 虚拟机中，默认 Eden 和 Survivor 的大小比例为8：1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被”浪费“。在 GC 回收过程中，若未使用的那块 Survivor 空间不够时，需要依赖其他内存（老年代）进行分配担保（Handle Promotion）（具体规则取决于垃圾收集器）。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p><strong>根据老年代的特点，顺应有了”标记-整理“算法，其过程与”标记-清除“算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</strong></p>
<p><div align="center"><br><img src="http://on83riher.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt=""><br></div></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用”分代收集“（Generational Collection）算法，<strong>这种算法是根据对象的存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</strong></p>
<ul>
<li>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本</li>
<li>在老年代中，因为对象存活率高，没有额外的空间对它进行分配担保，就必须使用”标记-清理“或”标记-整理“算法来进行回收</li>
</ul>
<h2 id="GC日志中的术语"><a href="#GC日志中的术语" class="headerlink" title="GC日志中的术语"></a>GC日志中的术语</h2><ul>
<li><strong>Minor GC</strong> 指发生在新生代的垃圾收集动作，非常频繁，速度较快。</li>
<li><strong>Major GC</strong>（通常与 Full GC 是等价de ）指发生发生在整个 GC 堆中的垃圾收集动作，频次较少，一般由多次 Minor GC 后，内存空间仍不满足程序运行时调用。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.jpg" alt="jianpeng957">
            
              <p class="site-author-name" itemprop="name">jianpeng957</p>
              <p class="site-description motion-element" itemprop="description">沉迷学习无法自拔</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">93</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jianpeng957</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
