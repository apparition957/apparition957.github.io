<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="沉迷学习无法自拔"/>













  <link rel="alternate" href="/atom.xml" title="APPARITION957">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://apparition957.github.io/page/5/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  
  <script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8bd9b518a8b821a06877823fceed6cab";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>








<meta name="google-site-verification" content="OxwLY0TQSQ2wO159foQs2OK6XTDPDZA_H3N6_pCPnng" />


    <title> APPARITION957 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">APPARITION957</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">APPARITION957</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/27/ArrayList 源码分析/">ArrayList 源码分析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-27
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="常量与重要的成员变量"><a href="#常量与重要的成员变量" class="headerlink" title="常量与重要的成员变量"></a>常量与重要的成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 默认容量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="comment">// 空数组-对应第一个构造函数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 默认空数组-对应第二个构造函数。这个与上面EMPTY_ELEMENTDATA要进行区别，根据源码解释说到，两个变量决定了当第一次插入数据时容器的扩容机制，在这里相当于起到了标志位的作用。实际操作看扩容与缩容部分</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// ArrayList内部的真实容器(数组)</span></div><div class="line"><span class="keyword">transient</span> Object[] elementData;</div><div class="line"></div><div class="line"><span class="comment">// ArrayList内部的记录实际装载数据个数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根据用户自定义容量初始化容器</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">                                           initialCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 默认构造函数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 由一组数组进行容器的初始化(前提该数组必须是实现了Collection接口，并继承或来源于&lt;E&gt;)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    elementData = c.toArray();</div><div class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 倘若返回的Class类型并非Object[]，需要Arrays.copy()将其类型转化为Object[]</span></div><div class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</div><div class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 若该组数组为空数组</span></div><div class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>EMPTY_ELEMENTDATA</code>与<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>两个标志位，个人认为：</p>
<ul>
<li>如果以默认的构造函数模式初始化ArrayList，则以ArrayList内部的增长模式扩展，即初始化时容器大小就是DEFAULT_CAPACITY，即为10</li>
<li>如果</li>
</ul>
<h2 id="增加操作-——-add"><a href="#增加操作-——-add" class="headerlink" title="增加操作 —— add()"></a>增加操作 —— add()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 顺序插入数据</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">  	<span class="comment">// 无论是哪种插入操作，都需要提前进行扩容，防止抛出ArrayIndexOutOfBoundsException</span></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在指定位置上插入数据</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">  	<span class="comment">// if (index&lt;0 || index&gt;size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span></div><div class="line">    rangeCheckForAdd(index);</div><div class="line"></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</div><div class="line">  	<span class="comment">// System.arraycopy(Object src, int srcPos,</span></div><div class="line">  	<span class="comment">//					Object dest, int destPos,</span></div><div class="line">  	<span class="comment">//					int length)</span></div><div class="line">  	<span class="comment">// 即从原数组(src)中的指定位置(src)，复制一定长度的数据(length)，到目标数组(dest)的指定位置上(destPos)</span></div><div class="line">  	System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">                     size - index);</div><div class="line">    elementData[index] = element;</div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 顺序插入一组数据</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    Object[] a = c.toArray();</div><div class="line">    <span class="keyword">int</span> numNew = a.length;</div><div class="line">    ensureCapacityInternal(size + numNew);</div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</div><div class="line">    size += numNew;</div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在指定位置上，插入一组数据</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    rangeCheckForAdd(index);</div><div class="line"></div><div class="line">    Object[] a = c.toArray();</div><div class="line">    <span class="keyword">int</span> numNew = a.length;</div><div class="line">    ensureCapacityInternal(size + numNew);</div><div class="line"></div><div class="line">  	<span class="comment">// 原数组中需要移动的个数</span></div><div class="line">    <span class="keyword">int</span> numMoved = size - index;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">      System.arraycopy(elementData, index, elementData, index + numNew,</div><div class="line">                       numMoved);</div><div class="line"></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</div><div class="line">    size += numNew;</div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在ArrayList内部，数组的移动往往通过<code>System.arraycopy()</code>和<code>Array.copy()</code>进行操作。这种方式增加了提高了内聚性，也避免了大量的重复代码出现在不同地方中。</p>
<h2 id="扩容与缩容操作-ensureCapacity-与trimToSize"><a href="#扩容与缩容操作-ensureCapacity-与trimToSize" class="headerlink" title="扩容与缩容操作 - ensureCapacity()与trimToSize()"></a>扩容与缩容操作 - ensureCapacity()与trimToSize()</h2><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法域为public，即该方法是方便用户根据自己的需求直接扩展容器容量</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">  	<span class="comment">// 此时出现了DEFAULTCAPACITY_EMPTY_ELEMENTDATA标志，该字段是表明不同的标志位所要求的最低扩展阈值不同</span></div><div class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</div><div class="line">        ? <span class="number">0</span></div><div class="line">        : DEFAULT_CAPACITY;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</div><div class="line">      	<span class="comment">// 最终调用内部的ensureCapacityInternal()</span></div><div class="line">        ensureExplicitCapacity(minCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方法域为private，内部只存在简单的判断逻辑，用于判断该数组是不是DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 最终确认容器是否有必要进行扩容操作(毕竟每扩容一次，代表这一次性能消耗，扩容操作越频繁，性能消耗越大)</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实际执行扩容操作</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  <span class="comment">// 新容器大小为旧容器的1.5倍</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">      newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">      newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 由于ArrayList本身是不会进行缩容的，于是在进行大量的数据插入删除后，会造成大面积的空间浪费</span></div><div class="line"><span class="comment">// 此时用户可以自己通过trimToSize()来缩容</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</div><div class="line">        elementData = (size == <span class="number">0</span>)</div><div class="line">          ? EMPTY_ELEMENTDATA</div><div class="line">          : Arrays.copyOf(elementData, size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="删除操作-remove"><a href="#删除操作-remove" class="headerlink" title="删除操作 - remove()"></a>删除操作 - remove()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在指定位置上删除数据</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">      	<span class="comment">// 数组直接向左移动ß</span></div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// 进行清空操作，方便GC回收</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 删除指定数据(碰到的第一个)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">      	System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                       numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 还存在其他删除操作，但原理基本相同</span></div></pre></td></tr></table></figure>
<h2 id="查找操作-get"><a href="#查找操作-get" class="headerlink" title="查找操作 - get()"></a>查找操作 - get()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 时间复杂度O(1)</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> elementData(index);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (E) elementData[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="修改操作-set"><a href="#修改操作-set" class="headerlink" title="修改操作 - set()"></a>修改操作 - set()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 时间复杂度O(1)</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    E oldValue = elementData(index);</div><div class="line">    elementData[index] = element;</div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="三种遍历ArrayList的方式"><a href="#三种遍历ArrayList的方式" class="headerlink" title="三种遍历ArrayList的方式"></a>三种遍历ArrayList的方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一种，通过迭代器遍历</span></div><div class="line">Integer value = <span class="keyword">null</span>;</div><div class="line">Iterator iter = list.iterator();</div><div class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">    value = (Integer)iter.next();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 第二种，随机访问(RandomAccess)，通过索引值去遍历 -&gt; 效率最高</span></div><div class="line">Integer value = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">int</span> size = list.size();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">    value = (Integer) list.get(i);        </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 第三种，for循环遍历 -&gt; 效率最低</span></div><div class="line">Integer value = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">for</span> (Integer integer: list) &#123;</div><div class="line">    value = integer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>参考资料：</p>
<p><a href="http://www.jianshu.com/p/2cd7be850540" target="_blank" rel="external">Java集合干货系列-（一）ArrayList源码解析</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/26/HashMap 源码分析/">HashMap 源码分析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-26
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>下图可从可视化的角度理解 HashMap（其实也是方便自己想起来）。</p>
<p><img src="http://4.bp.blogspot.com/-unPwpp8AJTA/U0e9S0F5ljI/AAAAAAAAAUo/xMnUVRO5fyY/s1600/how+hashmap+works+internally+in+java+.png" alt=""></p>
<h2 id="常量与重要的成员变量"><a href="#常量与重要的成员变量" class="headerlink" title="常量与重要的成员变量"></a>常量与重要的成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 默认容量(也是最小容量阈值)</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></div><div class="line"><span class="comment">// 最大容量阈值</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"><span class="comment">// 默认负载因子</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line"><span class="comment">// 从链表转变为红黑树的阈值</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</div><div class="line"><span class="comment">// 从红黑树转变为链表的阈值</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</div><div class="line"><span class="comment">// 从链表转变为红黑树的最小容量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</div><div class="line"></div><div class="line"><span class="comment">// HashMap 实际存储键值对的容器</span></div><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div><div class="line"><span class="comment">// HashMap 实际阈值，其值由 capacity * loadFactor 决定</span></div><div class="line"><span class="keyword">int</span> threshold;</div></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">  	<span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                       initialCapacity);</div><div class="line">  	<span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">    	initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">  	<span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                       loadFactor);</div><div class="line">  	<span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">  	<span class="comment">// 重点！</span></div><div class="line">  	<span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 该方法用于返回大于给定容量的最小2的幂次方的数值</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为什么 HashMap 的容量数值非要是2的幂次方呢？请看<a href="https://www.zhihu.com/question/20733617" target="_blank" rel="external">JDK 源码中 HashMap 的 hash 方法原理是什么？</a> </p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash()"></a>hash()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HashMap 中的实际 hash 值计算是通过 <code>key.hashCode()</code>所得出来的<code>h</code> ，与<code>h</code>无条件右移16位后，进行按位异或<code>^</code>得出来的。</p>
<p>但是怎么转化成实际上<code>table</code>数组的所索引值呢？剧透一下，<code>table</code> 的索引值是通过 <code>capacity</code>与<code>hash</code>进行按位与<code>&amp;</code>计算出来的。</p>
<h2 id="putVal"><a href="#putVal" class="headerlink" title="putVal()"></a>putVal()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    </div><div class="line">  	<span class="comment">// 当HashMap中的数组，即table为空，或者table的长度为0时，调用 resize 方式进行 HashMap 的初始化(HashMap真正的容器初始化阶段是在第一次插入时)</span></div><div class="line">  	<span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">       	n = (tab = resize()).length;</div><div class="line">   	</div><div class="line">  	<span class="comment">// 根据n(capacity)-1与hash值进行按位运算，获得该key值对应的数组中的位置。若该索引(p)上的值为null，则直接创建新的节点</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">  </div><div class="line">  	<span class="comment">// 该索引上的值不为null，那么需要分以下三种情况分析</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">      </div><div class="line">      	<span class="comment">// 该p的hash值与传入的hash值相等，并且p的key值也与传入的key值相等，或者在hash值不相同的情况下，两者的key值是相同的</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">      </div><div class="line">      	<span class="comment">// 若p的key值不等于传入的key值</span></div><div class="line">      	<span class="comment">// p的类型属于TreeNode，即从属于红黑树，则转由红黑树进行实际节点添加的操作</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">      	<span class="comment">// p的类型属于Node，即从属于链表。这里就是HashMap中怎么处理哈希冲突的办法。</span></div><div class="line">      	<span class="comment">// 当传入元素的hash值与数组上的元素相同，但key不同时。</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">      </div><div class="line">      	<span class="comment">// 当上述的添加新节点的阶段结束后，若此时的e(即原始节点)不为空时，则进行值的替换。</span></div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  	</div><div class="line">    ++modCount;	<span class="comment">// 用于记录修改的操作次数</span></div><div class="line">	<span class="comment">// 若此时的容器容量大于阈值时，进行resize()扩容容器</span></div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果看懂了putVal()，那么get()就是同样的方式分析了</span></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h2><p><code>resize()</code>实际上的目的在于将原数组中的值均匀地平摊到新数组中，这样无论是插入还是访问的效率也会有一定的提升。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这一部分分析难度不亚于putVal()</span></div><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">  </div><div class="line">  	<span class="comment">// 若老数组为0，那么老容量为0，否则为老数组长度</span></div><div class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line">    <span class="keyword">int</span> oldThr = threshold;</div><div class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">  </div><div class="line">  	<span class="comment">// 若老容量大于0</span></div><div class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">      	<span class="comment">// 若老容量是否大于最大容量阈值</span></div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span> oldTab;</div><div class="line">        &#125;</div><div class="line">      	<span class="comment">// 若扩容后的新容量小于最大容量阈值且老容量大于默认容量值，则新阈值为老阈值的两倍</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  	<span class="comment">// 若老容量等于0且老阈值大于0，那么新容量就等于老阈值</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</div><div class="line">        newCap = oldThr;</div><div class="line">  	<span class="comment">// 若老容量等于0且老阈值也为0，这种比较极端了</span></div><div class="line">  	<span class="comment">// 新容量为默认容量值，而新阈值也为默认阈值(0.75)</span></div><div class="line">    <span class="keyword">else</span> &#123;               </div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  	<span class="comment">// 若新阈值为0，那么则由负载因子与新容量的乘积获得</span></div><div class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    threshold = newThr;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">  </div><div class="line">  	<span class="comment">// 实际操作部分，初始化新容器！</span></div><div class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">  	</div><div class="line">  	<span class="comment">// 其实HashMap的初始化阶段从这里就结束了，以下部分只适用于存有实际节点的容器</span></div><div class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">      	<span class="comment">// 遍历老数组</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">          	<span class="comment">// 若该索引上的节点部位不为空，则分以下三种情况分析</span></div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                oldTab[j] = <span class="keyword">null</span>;</div><div class="line">              	<span class="comment">// 单个节点</span></div><div class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">              	<span class="comment">// 红黑树</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">              	<span class="comment">// 链表</span></div><div class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></div><div class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                loHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                hiHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        loTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        hiTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="keyword">return</span> newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际可视化操作如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1541350-f1221a46429fffc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="为什么-HashMap-不是线程安全的？"><a href="#为什么-HashMap-不是线程安全的？" class="headerlink" title="为什么 HashMap 不是线程安全的？"></a>为什么 HashMap 不是线程安全的？</h2><p>根据《Java并发编程的艺术》中写道：</p>
<blockquote>
<p>HashMap 在并发执行 put 操作时会引起死循环，导致 CPU 利用率接近100%。因为多线程会导致 HashMap 的 Node 链表形成环形数据结构，一旦形成环形数据结构，Node 的 next 节点永远不为空，就会在获取 Node 时产生死循环。</p>
</blockquote>
<p>实际原理可以<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="external">疫苗：JAVA HASHMAP的死循环</a>一文。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/12/《别让我思考》读书笔记/">《别让我思考》读书笔记</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-12
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h3 id="别让我思考"><a href="#别让我思考" class="headerlink" title="别让我思考"></a>别让我思考</h3><h4 id="Krug-可用性第一定律"><a href="#Krug-可用性第一定律" class="headerlink" title="Krug 可用性第一定律"></a>Krug 可用性第一定律</h4><p><strong>设计者应该尽量做到，当我看一个页面时，他应该是不言而喻、一目了然、自我解释的。</strong>我应该能明白它——它是什么，怎样使用它——而不需要花费精力进行思考。</p>
<p>网页上每项内容都有可能迫使我们停下来，进行不必要的思考。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">作为一个用户，永远不该让我们花上几微秒去思考某个东西是否能点击。你可能会这么想，“其实，找出某个东西是否能点击并不需要花费多大工夫。如果你将鼠标移过去，它的光标由箭头变成一只小手，就表示可以点击。这会有很大的问题吗？”。</div><div class="line"></div><div class="line">问题是，当我们访问 Web 的时候，每个问号都会加重我们的认知负担，把我们的注意力从要完成的任务上拉开。这种干扰也许很轻微，但它们会累积起来，有时候这样的干扰不用太多，就足以让我们抓狂。况且，人们通常不喜欢苦苦思索背后的原理。</div></pre></td></tr></table></figure>
<hr>
<h3 id="我们实际上是如何使用-Web-的"><a href="#我们实际上是如何使用-Web-的" class="headerlink" title="我们实际上是如何使用 Web 的"></a>我们实际上是如何使用 Web 的</h3><h4 id="扫描，满意即可，勉强应付"><a href="#扫描，满意即可，勉强应付" class="headerlink" title="扫描，满意即可，勉强应付"></a>扫描，满意即可，勉强应付</h4><p>如果想设计有效地网页，你必须开始接受关于网络使用情况的三个事实。</p>
<h5 id="第一个事实：我们不是阅读，二是扫描"><a href="#第一个事实：我们不是阅读，二是扫描" class="headerlink" title="第一个事实：我们不是阅读，二是扫描"></a>第一个事实：我们不是阅读，二是扫描</h5><p><strong>人们会花极少的时间来阅读大部分的页面，其实，我们只是扫描一下（或者匆匆掠过）网页，寻找能够吸引我们注意力的文字或词语。</strong></p>
<p>我们为什么扫描：</p>
<ul>
<li><strong>我们总是处于忙碌之中。</strong>Web 用户的行为更像鲨鱼，即它们不得不一直移动，否则就会死掉。我们没有时间阅读那些不必要的内容。</li>
<li><strong>我们知道自己不必阅读所有内容。</strong>在绝大多数页面上，我们实际上只对其中一小部分内容感兴趣，剩下的内容我们并不关心。</li>
<li><strong>我们善于扫描。</strong></li>
</ul>
<h5 id="第二个事实：我们不做最佳选择，而是满意即可"><a href="#第二个事实：我们不做最佳选择，而是满意即可" class="headerlink" title="第二个事实：我们不做最佳选择，而是满意即可"></a>第二个事实：我们不做最佳选择，而是满意即可</h5><p>在设计页面时，我们通常假设用户只是扫过整个页面，考虑所有可能的选项，然后选择一个最好的。<strong>然而，事实上，大多数时间里我们不会选择最佳选项，而是选择第一个合理的选项，这就是满意策略。</strong>一旦我们发现一个链接，看起来似乎能够跳转到我们想去的地方，那就是一个我们将会点击它的大好机会。</p>
<p>我们为什么不寻找最佳选择：</p>
<ul>
<li><strong>我们总是处于忙碌之中。</strong></li>
<li><strong>如果猜错了，也不会产生什么严重的后果。</strong>与救火不同，在网站上做了一次错误选择的后果通常只是点击几次后退按钮。</li>
<li><strong>对选择进行权衡并不会改善我们的机会。</strong></li>
<li><strong>猜测更有意思。</strong>猜测不会像仔细衡量那么累，而且如果猜对了，速度会更快。他还会带来一个机会因素——有可能无意中看到某个令人意外但不错的内容，这种可能性让人开心。</li>
</ul>
<h5 id="第三个事实：我们不是追根究底，而是勉强应对"><a href="#第三个事实：我们不是追根究底，而是勉强应对" class="headerlink" title="第三个事实：我们不是追根究底，而是勉强应对"></a>第三个事实：我们不是追根究底，而是勉强应对</h5><p>在很大程度上人们一直在使用这些东西，但并不理解它们的运作原理，甚至对它们的工作原理有完全错误的理解。无论面对哪种技术，很少有人会花时间读说明书。<strong>相反，我们贸然前进，勉强应对，编造出我们自己模棱两可的故事，来解释我们的所作所为，以及为什么这样能行得通。</strong></p>
<p>为什么会这样：</p>
<ul>
<li><strong>这对我们来说并不重要。</strong>对于我们中的大多数人来说，是否明白事物背后的工作机制并不重要，只要我们能正常使用它们即可。这并不是智力低下的表现，而是我们并不关心。</li>
<li><strong>如果发现某个事物能用，我们会一直用它。</strong>我们一旦发现某个事物能够用（不管有多难用），我们也不会去找一种更好的方法（至少不会主动去找）。</li>
</ul>
<hr>
<h3 id="广告牌设计101法则"><a href="#广告牌设计101法则" class="headerlink" title="广告牌设计101法则"></a>广告牌设计101法则</h3><h4 id="为扫描设计，不为阅读设计"><a href="#为扫描设计，不为阅读设计" class="headerlink" title="为扫描设计，不为阅读设计"></a>为扫描设计，不为阅读设计</h4><p>如果用户们都是疾驰而过，那么，你需要注意以下5个重要方面，来保证他们尽可能地看到了并理解了你的网站：</p>
<h5 id="在每个页面上建立清楚的视觉层次。"><a href="#在每个页面上建立清楚的视觉层次。" class="headerlink" title="在每个页面上建立清楚的视觉层次。"></a>在每个页面上建立清楚的视觉层次。</h5><ul>
<li>越重要的部分越突出。</li>
<li>逻辑上相关的部分在视觉上也相关。</li>
<li>逻辑上包含的部分在视觉上进行嵌套。</li>
</ul>
<h5 id="尽可能利用习惯用法。"><a href="#尽可能利用习惯用法。" class="headerlink" title="尽可能利用习惯用法。"></a>尽可能利用习惯用法。</h5><ul>
<li><strong>（优）它们非常有用。</strong>通常，习惯用法因为有用才会成为习惯用法。适当使用习惯用法会使用户在网站之间的访问更容易，不需要花费额外的努力来得到背后的工作原理。</li>
<li><strong>（劣）设计师通常不愿意利用他们。</strong>和使用习惯用法相比，设计师们都面临着很大的诱惑，想要重新发明轮子很大程度上是因为他们觉得他们的职业使命感，趋势他们去做一些崭新的，与众不同的设计。</li>
</ul>
<h5 id="把页面划分成明确定义的区域。"><a href="#把页面划分成明确定义的区域。" class="headerlink" title="把页面划分成明确定义的区域。"></a>把页面划分成明确定义的区域。</h5><p>把页面划分成明确意义的区域，可以让用户很快决定关注页面的哪些区域，或者放心地跳过哪些区域。</p>
<h5 id="明显标识可以点击的地方。"><a href="#明显标识可以点击的地方。" class="headerlink" title="明显标识可以点击的地方。"></a>明显标识可以点击的地方。</h5><h5 id="最大限度降低干扰。"><a href="#最大限度降低干扰。" class="headerlink" title="最大限度降低干扰。"></a>最大限度降低干扰。</h5><p>有效降低噪音的方式——在设计页面的收，先假定所有的内容都是视觉噪声，除非得到证明它们不是。</p>
<hr>
<h3 id="动物、植物、无机物"><a href="#动物、植物、无机物" class="headerlink" title="动物、植物、无机物"></a>动物、植物、无机物</h3><h4 id="为什么用户喜欢无须思考的选择"><a href="#为什么用户喜欢无须思考的选择" class="headerlink" title="为什么用户喜欢无须思考的选择"></a>为什么用户喜欢无须思考的选择</h4><p><strong>“点击多少次都没关系，只要每次点击都是无须思考、明确无误的选择。”——Krug 可用性第二定律</strong></p>
<p>如果我们需要一直在网络上进行选择，那么让这些选择变得无须思考是让一个网站容易使用的主要因素。</p>
<hr>
<h3 id="省略不必要的文字"><a href="#省略不必要的文字" class="headerlink" title="省略不必要的文字"></a>省略不必要的文字</h3><h4 id="不要在-Web-上写作的艺术"><a href="#不要在-Web-上写作的艺术" class="headerlink" title="不要在 Web 上写作的艺术"></a>不要在 Web 上写作的艺术</h4><p><strong>“去掉每个页面上一半的文字，然后把剩下的文字再去掉一半。”——Krug 可用性第三定律</strong></p>
<p><strong>省略多余的文字。</strong>有力的文字都很简练。句子里不应该有多余的文字，段落中不应该有多余的句子。同样，画上不应该有多余的线条，机器上不应该有多余的零件。</p>
<hr>
<h3 id="街头指示牌和面包屑"><a href="#街头指示牌和面包屑" class="headerlink" title="街头指示牌和面包屑"></a>街头指示牌和面包屑</h3><h4 id="设计导航"><a href="#设计导航" class="headerlink" title="设计导航"></a>设计导航</h4><p><strong>如果在网站上找不到方向，人们不会使用你的网站。</strong></p>
<p>导航有两个显而易见的用途：<strong>帮助我们找到想要的任何东西</strong>和<strong>告诉我们现身何处</strong>。此外，导航还有以下额外的好处：</p>
<ul>
<li><strong>他给了我们一些固定的感觉。</strong></li>
<li><strong>它告诉我们当前的位置。</strong></li>
<li><strong>它告诉我们如何使用网站。</strong></li>
<li><strong>它给了我们对网站建造者的信心。</strong>在网站上的每一刻，我们都会在头脑中保持一个标杆：这些人知道他们在做什么吗？这是我们决定是否离开，或者以后会不会来的主要考虑因素之一。</li>
</ul>
<hr>
<h3 id="首先要承认，主页不由你控制"><a href="#首先要承认，主页不由你控制" class="headerlink" title="首先要承认，主页不由你控制"></a>首先要承认，主页不由你控制</h3><h4 id="设计主页"><a href="#设计主页" class="headerlink" title="设计主页"></a>设计主页</h4><p>主页要完成的任务：</p>
<ul>
<li><strong>站点的标识（Logo）和使命。</strong>主页要告诉我这是什么网站，它是做什么的。</li>
<li><strong>站点层次。</strong>主页要给出网站提供的服务的概貌——既要包括内容（“我能在这里找到什么？”），也要包括功能（“我能做什么？”）——还有这些服务是如何组织的。</li>
<li><strong>搜索。</strong></li>
<li><strong>导读。</strong></li>
<li><strong>内容更新。</strong>时常更新的内容让用户觉得这个网站并不是一成不变的。</li>
<li><strong>友情链接。</strong>需要在主页上预留空间，用来放置广告，交叉推广，合作品牌的友情链接等。</li>
<li><strong>快捷方式。</strong></li>
<li><strong>注册。</strong></li>
</ul>
<p>主页需要满足一些抽象的目标：</p>
<ul>
<li><strong>让我看到自己正在寻找的东西。</strong></li>
<li><strong>··· ··· 还有我没有寻找的。</strong></li>
<li><strong>告诉我从哪里开始。</strong></li>
<li><strong>建立可信度和信任感。</strong></li>
</ul>
<hr>
<h3 id="农场主和牧牛人应该是朋友"><a href="#农场主和牧牛人应该是朋友" class="headerlink" title="农场主和牧牛人应该是朋友"></a>农场主和牧牛人应该是朋友</h3><h4 id="为什么-Web-设计团队讨论可用性是在浪费时间，如何避免这种情况"><a href="#为什么-Web-设计团队讨论可用性是在浪费时间，如何避免这种情况" class="headerlink" title="为什么 Web 设计团队讨论可用性是在浪费时间，如何避免这种情况"></a>为什么 Web 设计团队讨论可用性是在浪费时间，如何避免这种情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">从个人角度来说，我们喜欢 Flash 动画，因为它们很好玩；我们也可能不喜欢它们，因为要花很长时间下载。我们喜欢每个页面左边的菜单，因为它们看起来很熟悉而且容易使用；我们可能不喜欢它们，因为它们很枯燥乏味。我们真的喜欢有____的网站，或者，我们发现____真是让人痛苦极了。</div></pre></td></tr></table></figure>
<p>在网站日常开发当中，项目人员共同讨论关于某些的设计问题时，很难不讲以上例子所阐述的感觉牵涉进来。结果往往就是一堆人待在房间里面，每个人都有自持主见，不肯让步。<strong>而且，由于这些主张的力量——还有人的天性——自然有一种把这些喜欢或者不喜欢投射到整个 Wen 用户身上的倾向，认为绝大多数的 Web 用户喜欢我们所喜欢的。我们通常认为大部分 Web 用户和我们一样。</strong></p>
<p>争辩人们喜欢什么既浪费时间又消耗团队的精力，而通过<strong>测试</strong>能将讨论对错转移到什么有效、什么无效上，更容易缓和争论，打破僵局。而且，测试会让我们看到用户的动机、理解、反应的不同，从而让我们不会再坚持认为用户的想法和我们的想法一样。</p>
<hr>
<h3 id="一天10美分的可用性测试"><a href="#一天10美分的可用性测试" class="headerlink" title="一天10美分的可用性测试"></a>一天10美分的可用性测试</h3><h4 id="让测试简单——这样你能进行充分的测试"><a href="#让测试简单——这样你能进行充分的测试" class="headerlink" title="让测试简单——这样你能进行充分的测试"></a>让测试简单——这样你能进行充分的测试</h4><p>关于测试的几个重要事实：</p>
<ul>
<li><strong>如果想建立一个优秀的网站，一定要测试。</strong>测试更像是邀请外地的朋友，不可避免地，当你和他们一起四处游玩时，你会看到平时不会注意到的一些情况，因为你对它们太熟悉了。同时，你也意识到有很多你认为想当然的事情，对别人来说却并非如此。</li>
<li><strong>测试一个用户比不做测试好一倍。</strong>测试总是有效果的，哪怕是对错误的用户做一次最糟糕的测试，也会让你看到一些改善网站的重要方面。</li>
<li><strong>在项目中，早点测试一位用户，好过最后测试50位用户。</strong>一旦一个网站投入使用，要改变它就不会那么容易了。有些用户拒绝做出任何变化，因为即使很小的变更也会给他们带来深远的影响，让我们付出无法想象的代价（至少是项目初期所付出的数倍），所以任何在开始时就有助于防止你犯错误的方法都很划算。</li>
<li><strong>人们对招募用户代表的重要性估计过高。</strong></li>
<li><strong>测试的关键不是要证明什么或者反驳什么，而是了解你的判断力。</strong>测试能做的就是给你提供有价值的参考，加上你的经验、专业判断和常识能够让你更容易地在 A 和 B 之间做出更明智——也更自信——的选择。</li>
<li><strong>测试是一个迭代的过程。</strong></li>
<li><strong>没有什么比现场用户的反应更重要的。</strong></li>
</ul>
<h5 id="跳楼大减价的简易可用性测试"><a href="#跳楼大减价的简易可用性测试" class="headerlink" title="跳楼大减价的简易可用性测试"></a>跳楼大减价的简易可用性测试</h5><table>
<thead>
<tr>
<th></th>
<th>传统可用性测试</th>
<th>跳楼大减价的建议可用性测试</th>
</tr>
</thead>
<tbody>
<tr>
<td>每次测试的用户数量</td>
<td>通常需要八个或者更多个用户，因为建立测试的花费不菲</td>
<td>3-4个用户</td>
</tr>
<tr>
<td>招募方式</td>
<td>仔细选择，尽量靠近目标用户</td>
<td>随便找一些人，几乎任何会上网的人都可以</td>
</tr>
<tr>
<td>测试地点</td>
<td>一个可用性实验室，其中包括一个观察室和单向玻璃</td>
<td>任何办公室或会议室</td>
</tr>
<tr>
<td>主导测试</td>
<td>一位有经验的可用性专家</td>
<td>任何相对有耐心的人</td>
</tr>
<tr>
<td>提前计划</td>
<td>需要提前几个星期制定测试计划，预定可用性实验室，并预留招募时间</td>
<td>几乎可以在任何时间进行测试，稍微提前一些做计划即可</td>
</tr>
<tr>
<td>准备工作</td>
<td>起草、讨论并修订测试草案</td>
<td>决定你要展示什么</td>
</tr>
<tr>
<td>测试目标/时间</td>
<td>除非你预算充足，否则会把所有的鸡蛋放在一个篮子里，在网站快要完成的时候做一次测试</td>
<td>在开发过程中持续进行小规模的测试</td>
</tr>
<tr>
<td>成本</td>
<td>5000-15000美元（或者更多）</td>
<td>300美元（50-100美元是给每个用户的补贴），或者更少</td>
</tr>
<tr>
<td>后续工作</td>
<td>一周之后，产生一份20页的报告，然后开发团队朋友来决定怎样修改</td>
<td>开发团队（还有有兴趣的人员）利用当天的午餐时间进行总结</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="可用性是基本礼貌"><a href="#可用性是基本礼貌" class="headerlink" title="可用性是基本礼貌"></a>可用性是基本礼貌</h3><h4 id="为什么你的网站应该让人尊敬"><a href="#为什么你的网站应该让人尊敬" class="headerlink" title="为什么你的网站应该让人尊敬"></a>为什么你的网站应该让人尊敬</h4><p>降低好感的几种方式：</p>
<ul>
<li><strong>隐藏我想要的信息。</strong></li>
<li><strong>因为没有按照你们的方式形式而惩罚我。</strong></li>
<li><strong>向我询问不必要的信息。</strong></li>
<li><strong>敷衍我，欺骗我。</strong></li>
<li><strong>给我设置障碍。</strong></li>
<li><strong>你的网站看上去不专业。</strong></li>
</ul>
<p>提高好感的几种方式</p>
<ul>
<li><strong>知道人们在你的网站上想做什么，并让它们明白简易、清晰明了。</strong></li>
<li><strong>告诉我我想知道的。</strong></li>
<li><strong>尽量减少步骤。</strong></li>
<li><strong>花点心思。</strong></li>
<li><strong>知道我可能有哪些疑问，并且给予解答。</strong></li>
<li><strong>为我提供协助，例如打印友好页面。</strong></li>
<li><strong>容易从错误中恢复。</strong></li>
<li><strong>如有不确定，记得道歉。</strong></li>
</ul>
<hr>
<h3 id="可访问性、级联样式表和你"><a href="#可访问性、级联样式表和你" class="headerlink" title="可访问性、级联样式表和你"></a>可访问性、级联样式表和你</h3><h4 id="正当你觉得已经完成了的时候，一只猫掉了下来，背上捆着涂了奶油的面包"><a href="#正当你觉得已经完成了的时候，一只猫掉了下来，背上捆着涂了奶油的面包" class="headerlink" title="正当你觉得已经完成了的时候，一只猫掉了下来，背上捆着涂了奶油的面包"></a>正当你觉得已经完成了的时候，一只猫掉了下来，背上捆着涂了奶油的面包</h4><p>在页面设计中，可以从下面几个方面有效提高网站的可访问性：</p>
<ul>
<li><strong>为每张图片添加 alt 文本。</strong></li>
<li><strong>让你的表单配合屏幕阅读器。</strong></li>
<li><strong>在每页的最前面增加一个“跳转到主要内容”的链接。</strong></li>
<li><strong>让所有的内容都可以通过键盘访问。</strong></li>
<li><strong>如果没有充分的理由，不要使用 JavaScript。</strong></li>
<li><strong>使用客户端的影像地图。</strong></li>
</ul>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/09/20/BIO-NIO-AIO 三者关系解析/">BIO/NIO/AIO 三者关系解析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-09-20
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在 Java 的 I/O 体系架构中，存在三种截然不同的 I/O 模型，分别为 BIO（Block I/O，阻塞型 I/O）、NIO（New I/O，非阻塞型 I/O）以及 AIO（Asynchronous I/O，异步 I/O）。</p>
<p>下面分析将从基本的术语开始讲解，最后归整讲述不同 I/O 模型的区别。</p>
<hr>
<h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p>同步与异步关注的是<strong>消息通信机制</strong>。</p>
<ul>
<li><strong>同步</strong>是指发送方发出一个 I/O 请求时，在没有得到结果之前，该请求不返回结果。但是一旦请求返回时，就得到了相应的返回值。</li>
<li><strong>异步</strong>是指发送方发出一个 I/O 请求之后，这个请求便立即返回，该请求没有返回结果。直至请求接收方（即被调用者）通过回调的方式来通知发送方，或者发送方主动询问接收方请求结果。</li>
</ul>
<p>举个例子：</p>
<p>晚上我们需要去饭店预定位置，我们会优先打个电话给酒店来预定位置，当我们被告知饭店位置爆满时需要等待时。在同步的通信机制情况下，我们（发送方）只能默默地够保持通话的方式等待饭店（接收方）来通知我们空余位置的结果，不能够做别的事情。</p>
<p>而在异步的通信机制情况下，饭店（接收方）提供了特殊的服务，让我们（发送方）预留手机号码（回调方式），等有位置了可以主动通知你，我们就能够单方面切断通信，等待饭店通过我们预留的手机号码来通知我们，或者我们来主动询问饭店位置的空余情况。</p>
<hr>
<h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>阻塞与非阻塞关注的是<strong>程序在等待调用结果时的状态</strong>。</p>
<ul>
<li><strong>阻塞</strong>是指请求结果返回之前，当前线程会被挂起。请求线程只有在得到结果之后才会返回。此时的线程处于阻塞状态，相当于卡住不动了。</li>
<li><strong>非阻塞</strong>是指请求结果返回之前，当前线程不会被阻塞，可以处理别的任务。</li>
</ul>
<p>同举以上的例子：</p>
<p>当我们打电话给饭店，被告知饭店位置爆满时需要等待时。在阻塞线程的请求方式下，我们（发送方）只能够保持通讯（阻塞），直至饭店（接收方）通知我们空余位置的结果。</p>
<p>而在非阻塞线程的请求方式下，我们（发送方）可以单方面挂掉电话，继续去逛街（非阻塞），直至饭店（接收方）通知我们，亦或者我们主动打电话去询问。</p>
<hr>
<h4 id="同步-异步与阻塞-非阻塞的区别"><a href="#同步-异步与阻塞-非阻塞的区别" class="headerlink" title="同步/异步与阻塞/非阻塞的区别"></a>同步/异步与阻塞/非阻塞的区别</h4><p>在以上的解释当中，同步/异步与阻塞/非阻塞两者之间的关系十分相似，但是它们却存在本质上的区别。</p>
<ul>
<li>同步/异步注重的是<strong>消息的通信机制</strong>，重点在于<strong>消息</strong>本身。</li>
<li>阻塞/非阻塞注重的是<strong>程序在等待调用结果时的状态</strong>，重点在于<strong>程序</strong>本身。</li>
</ul>
<hr>
<h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>BIO（Block I/O）为同步阻塞型 I/O。在服务器端中实现模式为<strong>一个连接一个线程</strong>，即客户端有连接请求时，服务器端就会按需启动一个线程来处理。</p>
<p><img src="http://on83riher.bkt.clouddn.com/BIO.png" alt="BIO"></p>
<p>如果这个连接不做任何事情时，就造成不必要的线程开销，此时可以通过线程池机制来对于空线程进行回收，但是对于线程的创建与销毁等操作，系统所消耗的资源依然很大。</p>
<hr>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>NIO（New I/O）为同步非阻塞型 I/O。在服务器端中实现模式为<strong>一个请求一个线程</strong>，即客户端发送的连接请求都会注册到多路复用器上（Selector），多路复用器轮询到连接有 I/O 请求（Channel）才启动一个线程（Handler）来处理。用户进程也需要时不时地询问 I/O 操作是否就绪。</p>
<p><img src="http://on83riher.bkt.clouddn.com/NIO.png" alt="NIO"></p>
<p>在 NIO 的 I/O 模型上，可以仅通过单线程的方式来处理高并发问题。</p>
<hr>
<h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>AIO（Asynchronous I/O）为异步非阻塞型 I/O。在此种模式下，用户进程只需要发起一个IO操作然后便立即返回，待 I/O 操作真正的完成以后，应用程序会得到I/O操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的 I/O 读写操作，因为真正的 I/O 读取或者写入操作已经由内核完成了。    </p>
<hr>
<p>参考资料：</p>
<p><a href="https://www.zhihu.com/question/19732473" target="_blank" rel="external">怎样理解阻塞非阻塞与同步异步的区别？</a></p>
<p><a href="http://loveshisong.cn/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2016-06-25-%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3BIO-NIO-AIO.html" target="_blank" rel="external">十分钟了解BIO、NIO、AIO</a></p>
<p><a href="http://qindongliang.iteye.com/blog/2018539" target="_blank" rel="external">JAVA 中BIO,NIO,AIO的理解</a></p>
<p><a href="http://blog.csdn.net/liuhaiabc/article/details/64905654" target="_blank" rel="external">对Java BIO、NIO、AIO 学习</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/09/07/Android 源码分析资料归纳/">Android 源码分析资料归纳</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-09-07
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>这一篇是最近学习 Android 源码，在碰到不懂的知识点时，上网找到的不错的、通俗易懂的文章，在此进行归纳收藏，在比较深入了解的时候可以去整理笔记。</p>
<hr>
<ul>
<li>Context </li>
</ul>
<p>Context 是 Android 应用层架构中最重要类，它是维持 Android 程序中各个组件能够正常工作的核心功能类。下篇文章就阐明了这一论点，以及如何有效使用 Context。</p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/47028975" target="_blank" rel="external">Android Context完全解析，你所不知道的Context的各种细节</a></p>
<ul>
<li>View 事件分发机制</li>
</ul>
<p>该文章主要是通过图文结合的方式，并结合少量精炼的代码，详细地叙述了一个事件如何进行传递，又如何被处理。</p>
<p><a href="http://www.jianshu.com/p/38015afcdb58" target="_blank" rel="external">Android事件分发机制详解：史上最全面、最易懂</a></p>
<ul>
<li>Actvity 启动及工作流程</li>
</ul>
<p>该文章讲述了 Activity 如何启动，以及科普了 Activity 启动时所涉及的重要组件，并根据主要源码讲述了过程，虽然我还没看懂内部机制（有些方法太变态！），但是还是从大局观上有了部分的了解。</p>
<p><a href="http://www.jianshu.com/p/6037f6fda285" target="_blank" rel="external">【凯子哥带你学Framework】Activity启动过程全解析</a></p>
<ul>
<li>Handler 消息机制</li>
</ul>
<p>该文章从生产者-消费者这一设计模式中，阐明了 Handler 机制中的三大组件 Handler、Looper 以及 MessageQueue，以及组件间是如何相互配合的。</p>
<p><a href="http://www.woaitqs.cc/android/2016/06/06/android-handler.html" target="_blank" rel="external">Android Handler机制全解析</a></p>
<ul>
<li>BroadcastProvider 广播机制</li>
</ul>
<p>该文章主要从三个角度来入手，广播接受者是如何进行注册，广播如何被发送，广播负载物是什么。</p>
<p><a href="http://www.jianshu.com/p/48d58a9dcc62" target="_blank" rel="external">读源码-五分钟理解不了广播机制</a></p>
<ul>
<li>Service 机制</li>
</ul>
<p>该文章怎么说，通读下来，虽然能从文章中能够理解他这个意思，但是具体的实现却异常复杂，可能现在我这个水平，还理解不了为什么它们要这样设计，这样设计的好处。</p>
<p><a href="http://www.woaitqs.cc/android/2016/09/20/android-service-usage.html" target="_blank" rel="external">从源码出发深入理解 Android Service</a></p>
<ul>
<li>ContentProvider 机制</li>
</ul>
<p><a href="http://gityuan.com/2016/07/30/content-provider/" target="_blank" rel="external">理解ContentProvider原理</a></p>
<ul>
<li>Android 动画机制</li>
</ul>
<p>看了两位 csdn 大神所写的 Android 动画教学系列，了解了 Android 动画的大战里程从 View Animation 的卡帧动画到 Drawable Animation 的仅支持少数动画效果动画机制，最后到 Property Animation 的强大。</p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/43536355" target="_blank" rel="external">Android属性动画完全解析(上)，初识属性动画的基本用法</a></p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/43816093" target="_blank" rel="external">Android属性动画完全解析(中)，ValueAnimator和ObjectAnimator的高级用法</a></p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/44171115" target="_blank" rel="external">Android属性动画完全解析(下)，Interpolator和ViewPropertyAnimator的用法</a></p>
<p><a href="http://blog.csdn.net/lmj623565791/article/details/38067475" target="_blank" rel="external">Android 属性动画（Property Animation） 完全解析 （上）</a></p>
<p><a href="http://blog.csdn.net/lmj623565791/article/details/38092093" target="_blank" rel="external">Android 属性动画（Property Animation） 完全解析 （下）</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/09/01/Android 进行 HTTPS 网络通信/">Android 进行 HTTPS 网络通信</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-09-01
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>前两天在 Andorid 上与使用自签名证书的服务器进行 https 网络通信遇到了问题，主要的问题出在于服务器端的证书不受客户端信任与认证，服务器端也不认识客户端，双方互不认识（在浏览器好歹也会提示用户添加安全证书）。</p>
<hr>
<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>根据需求分析，Android 平台上需要进行双向验证才能够进行正常的 https 通信。而在之前的代码结构中，由于不熟悉 https 沟通方式，错误使用了服务端证书来进行身份识别与验证。</p>
<hr>
<h4 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h4><p>进行后续操作的调整，在 centOS 平台上使用 keytool 分别了生成了服务器端证书以及客户端证书，并将客户端证书放置 Android 上，用于连接服务器端时对服务器端的证书进行鉴别与认证。</p>
<p>具体操作如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">1、生成服务器证书库</div><div class="line"></div><div class="line">keytool -validity 365 -genkey -v -alias server -keyalg RSA -keystore server.keystore -dname "CN=commonName,OU=organizationalUnit,O=Organization,L=Locality,ST=state,c=country" -storepass 123456 -keypass 123456 -keysize 2048</div><div class="line"></div><div class="line">2、生成客户端证书库</div><div class="line"></div><div class="line">keytool -validity 365 -genkey -v -alias client -keyalg RSA -storetype PKCS12 -keystore client.p12 -dname "CN=client,OU=organizationalUnit,O=Organization,L=Organization,ST=state,c=country" -storepass 123456 -keypass 123456 -keysize 2048</div><div class="line"></div><div class="line">3、从客户端证书库中导出客户端证书</div><div class="line"></div><div class="line">keytool -export -v -alias client -keystore client.p12 -storetype PKCS12 -storepass 123456 -rfc -file client.cer</div><div class="line"></div><div class="line">4、从服务器证书库中导出服务器证书</div><div class="line"></div><div class="line">keytool -export -v -alias server -keystore server.keystore -storepass 123456 -rfc -file server.cer</div><div class="line"></div><div class="line">5、生成客户端信任证书库(由服务端证书生成的证书库)</div><div class="line"></div><div class="line">keytool -import -v -alias server -file server.cer -keystore client.truststore -storepass 123456 -storetype BKS -provider org.bouncycastle.jce.provider.BouncyCastleProvider</div><div class="line"></div><div class="line">6、将客户端证书导入到服务器证书库(使得服务器信任客户端证书)</div><div class="line"></div><div class="line">keytool -import -v -alias client -file client.cer -keystore server.keystore -storepass 123456</div></pre></td></tr></table></figure>
<p>keytool 常用参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>-genkey</td>
<td>在用户主目录中创建一个默认文件“.keystore”</td>
</tr>
<tr>
<td>-validity</td>
<td>指定创建的证书有效期为多少天</td>
</tr>
<tr>
<td>-alias</td>
<td>产生别名，每个 keystore 都关联一个独一无二的 alias</td>
</tr>
<tr>
<td>-keystore</td>
<td>指定密钥库的名称</td>
</tr>
<tr>
<td>-keyalg</td>
<td>指定密钥的算法</td>
</tr>
<tr>
<td>-keysize</td>
<td>指定密钥的长度</td>
</tr>
<tr>
<td>-dname</td>
<td>指定证书发行者信息，其中： “CN=名字与姓氏,OU=组织单位名称,O=组织名称,L=城市或区域名 称,ST=州或省份名称,C=单位的两字母国家代码”</td>
</tr>
<tr>
<td>-storepass</td>
<td>指定密钥库的密码（.keystore密码）</td>
</tr>
<tr>
<td>-keypass</td>
<td>指定别名条目的密码（私钥密码）</td>
</tr>
<tr>
<td>-storetype</td>
<td>指定密钥库的存储类型</td>
</tr>
<tr>
<td>-export</td>
<td>将 alias 指定的证书导出到文件</td>
</tr>
<tr>
<td>-import</td>
<td>将已签名的证书导入密钥库中</td>
</tr>
<tr>
<td>-rfc</td>
<td>以Base64的编码格式打印证书</td>
</tr>
<tr>
<td>-file</td>
<td>指定导出到文件的文件名</td>
</tr>
<tr>
<td>-v</td>
<td>查看密钥库中的证书详细信息</td>
</tr>
</tbody>
</table>
<hr>
<p>在代码结构上，在 http 通信代码中添加 SSL 通信机制，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_STORE_TYPE_BKS = <span class="string">"BKS"</span>;<span class="comment">//证书类型</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_STORE_TYPE_P12 = <span class="string">"PKCS12"</span>;<span class="comment">//证书类型</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_STORE_CLIENT_PATH = <span class="string">"swaypay.p12"</span>;<span class="comment">//客户端要给服务器端认证的证书</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_STORE_TRUST_PATH = <span class="string">"swaypay.truststore"</span>;<span class="comment">//客户端验证服务器端的证书库</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_STORE_PASSWORD = <span class="string">"superssl1"</span>;<span class="comment">// 客户端证书密码</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_STORE_TRUST_PASSWORD = <span class="string">"superssl1"</span>;<span class="comment">//客户端证书库密码</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_STORE_TYPE_X509 = <span class="string">"X509"</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SSL_CONTEXT_PROTOCOL = <span class="string">"TLS"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSSLConnection</span><span class="params">()</span> </span>&#123;</div><div class="line">  		<span class="comment">// 1 - KeyStore - 用于存储各种类型的密钥，方便管理与使用</span></div><div class="line">        KeyStore keyStore = KeyStore.getInstance(KEY_STORE_TYPE_P12);</div><div class="line">        KeyStore trustStore = KeyStore.getInstance(KEY_STORE_TYPE_BKS);</div><div class="line"></div><div class="line">  		<span class="comment">// 2 - 将提前获取的受服务器端信任的客户端证书/用于验证服务器端的证书的证书库进行导入</span></div><div class="line">        InputStream ksIn = ContextHolder.getContext().getAssets().open(KEY_STORE_CLIENT_PATH);</div><div class="line">        InputStream tsIn = ContextHolder.getContext().getAssets().open(KEY_STORE_TRUST_PATH);</div><div class="line">  </div><div class="line">  		<span class="comment">// 3 - 初始化 KeyManagerFactory</span></div><div class="line">        keyStore.load(ksIn, KEY_STORE_PASSWORD.toCharArray());</div><div class="line">  		KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KEY_STORE_TYPE_X509);</div><div class="line">        keyManagerFactory.init(keyStore, KEY_STORE_PASSWORD.toCharArray());</div><div class="line">  </div><div class="line">  		<span class="comment">// 4 - 初始化 TrustManagerFactory</span></div><div class="line">        trustStore.load(tsIn, KEY_STORE_TRUST_PASSWORD.toCharArray());</div><div class="line">        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</div><div class="line">        trustManagerFactory.init(trustStore);</div><div class="line">  </div><div class="line">  		<span class="comment">// 5 - 初始化 SSLContext 并添加通过 KeyManagerFactory 和 TrustManagerFactory 分别生成的 getKeyManagers 和 getTrustManagers</span></div><div class="line">  		<span class="comment">// 这一步中，通过这种方式，才算 https 的双向验证机制的真正建立</span></div><div class="line">  		sslContext = SSLContext.getInstance(SSL_CONTEXT_PROTOCOL);</div><div class="line">  		sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">... </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">private</span> HttpURLConnection <span class="title">createHttpURLConnection</span><span class="params">(String targetUrl)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        <span class="comment">// 6</span></div><div class="line">        <span class="keyword">if</span> (httpURLConnection <span class="keyword">instanceof</span> HttpsURLConnection) &#123;</div><div class="line">            setSSLConnection();</div><div class="line">            ((HttpsURLConnection) httpURLConnection).setSSLSocketFactory(sslContext.getSocketFactory());</div><div class="line">          	<span class="comment">// 暂不验证 host 有效性</span></div><div class="line">            ((HttpsURLConnection) httpURLConnection).setHostnameVerifier((String hostname, SSLSession session) -&gt; &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<hr>
<p>参考资料:</p>
<p>[1] <a href="http://frank-zhu.github.io/android/2014/12/26/android-https-ssl/" target="_blank" rel="external">http://frank-zhu.github.io/android/2014/12/26/android-https-ssl/</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/08/28/心跳机制/">心跳机制</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-08-28
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h1 id="心跳机制及基本实现"><a href="#心跳机制及基本实现" class="headerlink" title="心跳机制及基本实现"></a>心跳机制及基本实现</h1><h3 id="什么是心跳机制"><a href="#什么是心跳机制" class="headerlink" title="什么是心跳机制"></a>什么是心跳机制</h3><p>心跳机制是定时发送一个自定义的结构体（心跳包），让对方知道自己还活着，以确保连接的有效性的机制。这种机制在分布式系统中十分常见，也是确保分布式系统中的主机是否存在的有效机制之一。</p>
<h3 id="一般的实现机制"><a href="#一般的实现机制" class="headerlink" title="一般的实现机制"></a>一般的实现机制</h3><p>心跳机制一般会有两种，客户端实现和服务器端实现。</p>
<h4 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h4><p>客户端通过本机与服务器端连接后获得的 Socket 对象，在一定时间间隔中，发送附加有效信息的心跳包给服务器端。服务器端正确接收后，在服务器端上以适当的形式保存该客户端发送心跳包时间，以便用于检测客户端在规定的超时间隔内依然是否存在。</p>
<h4 id="服务器端实现"><a href="#服务器端实现" class="headerlink" title="服务器端实现"></a>服务器端实现</h4><p>服务器端需要保留所有已连接的客户端 Socket 对象，并在一定时间间隔中，发送空载的心跳包给所有客户端，并在本机中维护一个发送时间计时器。客户端正确接收到心跳包后，回传给服务器端一个附加有效信息的心跳包，用于证明客户端依然存在。若服务器端在计时器超时之后，仍没有收到客户端发送来的心跳包，可视为客户端断开连接。</p>
<h3 id="尝实现"><a href="#尝实现" class="headerlink" title="尝实现"></a>尝实现</h3><p>自己觉得好玩就尝试去实现，放在了 github，代码比较粗糙</p>
<p>Github: <a href="https://github.com/jianpeng957/heartbeat" target="_blank" rel="external">https://github.com/jianpeng957/heartbeat</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/08/07/记得刷牙！/">记得刷牙！</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-08-07
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>上个星期，小时候为了修复蛀牙而去补牙的填充物不知为何掉了出来，空剩我一颗大蛀牙在里面，虽然不会有很大疼痛，但是心情却异样烦闷。今天特意去医院看了口腔科，做了一系列诊断后，医生说我这颗牙已经烂得不行了，要么做根管治疗，要么就拔了做假牙，需要的费用也是挺贵的，前一个至少3000+，后一个至少1w+。</p>
<p>听了之后，再看看 X 光片中那颗糜烂的大蛀牙，我整个人都不好了，<strong>很懊恼为什么小时候老是不刷牙，尤其是吃了糖之后不刷牙。爱护牙齿，甚至爱护身体的每一部分都是自己生命的本钱，不好好珍惜，到后来都是要自己买单，甚至是给家里带来负担。</strong></p>
<p><strong>在爱护自己的道路上，一定要且行且珍惜。尤其是到了工作的部分，我相信肯定比大学时期的生活更加艰难。</strong>附上一张在医院拍的 X 光片。</p>
<p><img src="http://on83riher.bkt.clouddn.com/CA92AA0605B8DD2FD983C270192AC095.png" alt=""></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/08/05/移位操作符/">移位操作符</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-08-05
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <blockquote>
<p>移位运算符就是在二进制的基础上对数学进行平移。按照平移的方向和填充数字的规则分为三种：&lt;&lt;（左移）、&gt;&gt;（右移）、&gt;&gt;&gt;（无符号右移）。</p>
</blockquote>
<p>Java 中的移位运算符也有三种：</p>
<ul>
<li><code>&lt;&lt;</code> - 左移运算符</li>
<li><code>&gt;&gt;</code> - 右移运算符</li>
<li><code>&gt;&gt;&gt;</code> - 无符号右移运算符</li>
</ul>
<hr>
<h3 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 左移运算符</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 二进制 - 1010</span></div><div class="line">a &lt;&lt; <span class="number">1</span>; 	<span class="comment">// 二进制 - 10100 - 相当于乘于 2^1</span></div><div class="line"></div><div class="line"><span class="comment">// 右移运算符</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</div><div class="line">a &gt;&gt; <span class="number">1</span>; 	<span class="comment">// 二进制 - 101 - 相当于除于 2^1</span></div><div class="line"></div><div class="line"><span class="comment">// 无符号右移运算符 - 分两种情况：非负数与负数</span></div><div class="line"><span class="comment">// 非负数</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</div><div class="line">a &gt;&gt; <span class="number">1</span>; 	<span class="comment">// 二进制 - 101 - 相当于除于 2^1</span></div><div class="line"></div><div class="line"><span class="comment">// 负数</span></div><div class="line"><span class="keyword">int</span> a = -<span class="number">10</span>; <span class="comment">// 二进制 - 11111111111111111111111111110110 - 负数在高位填补1</span></div><div class="line">a &gt;&gt; <span class="number">1</span>; 	 <span class="comment">// 二进制 - 01111111111111111111111111111011 - 十进制 - 2147483643</span></div></pre></td></tr></table></figure>
<p>以上代码中，十进制转换为二进制中，为什么<code>int a = -10</code>的二进制数的总长度为<strong>32</strong>呢。这取决于数据类型，在 java 中，基本数据类型<code>int</code>是4个字节，即32位。如果将数据类型<code>int</code>改变为<code>long</code>，结果则完全不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> a = -<span class="number">10</span>;</div><div class="line">a &gt;&gt; <span class="number">1</span>; 	 <span class="comment">// 十进制 - 9223372036854775803</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>移位运算是直接基于二进制对数值进行操作，主要目的是节约内存，运算时间比算术运算符更加快。</li>
</ul>
<hr>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="https://baike.baidu.com/item/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6" target="_blank" rel="external">https://baike.baidu.com/item/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6</a></li>
<li><a href="http://www.cnblogs.com/hongten/p/hongten_java_yiweiyunsuangfu.html" target="_blank" rel="external">http://www.cnblogs.com/hongten/p/hongten_java_yiweiyunsuangfu.html</a></li>
</ol>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/08/04/joda-time源码简略剖析/">joda-time源码简略剖析.md</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-08-04
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>最近查看了 Java 中有关于日期/时间处理的 API，发现了 <code>Joda-time</code> 这一款被众人广泛使用的开源库，花了一个下午，研究了内部的架构解析，画了下草图（真草图），内部的有些计算解析涉及到位处理，有些难以消化。</p>
<ul>
<li><img src="http://on83riher.bkt.clouddn.com/joda-time%E6%BA%90%E7%A0%81%E5%9B%BE.JPG" alt=""></li>
</ul>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/4/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    
    
      <a class="next" href="/page/6/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:jianpeng957@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">jianpeng957</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
