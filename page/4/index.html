<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="沉迷学习无法自拔"/>













  <link rel="alternate" href="/atom.xml" title="APPARITION957">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://apparition957.github.io/page/4/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  
  <script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8bd9b518a8b821a06877823fceed6cab";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>








<meta name="google-site-verification" content="OxwLY0TQSQ2wO159foQs2OK6XTDPDZA_H3N6_pCPnng" />


    <title> APPARITION957 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">APPARITION957</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">APPARITION957</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/31/Java关键字-static/">Java关键字 - static</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-31
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在Java中，我们可以通过用<code>static</code>来表示某个字段或者方法为“全局“或者”静态“的意思，当然<code>static</code>也可以修饰代码块。</p>
<h2 id="怎么使用static"><a href="#怎么使用static" class="headerlink" title="怎么使用static"></a>怎么使用static</h2><p><code>static</code>可以用于修饰成员变量和成员方法，我们将其称为静态变量和静态方法，可以直接通过类名进行访问。如下所示：</p>
<ul>
<li>ClassName.propertyName</li>
<li>ClassName.methodName()</li>
</ul>
<p>而<code>static</code>修饰的代码块也称之为静态代码块，当其所属的类被加载时，就会优先先执行这部分代码。</p>
<h3 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h3><p><code>static</code>修饰的变量称之为静态变量，而没有<code>static</code>修饰的变量称之为实例变量。两者的区别在于：</p>
<p>静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问。</p>
<p>但是实例变量则不同，他是伴随着实例的创建而创建，也伴随着实例的消亡而消亡。而且实例变量只能够通过对象进行访问。</p>
<h3 id="static函数"><a href="#static函数" class="headerlink" title="static函数"></a>static函数</h3><p><code>static</code>修饰的方法称之为静态方法，可以直接通过类名对其进行调用。正因为<code>static</code>修饰的函数在类加载的时候就已经存在了，它不依赖于任何实例，所以<code>static</code>方法必须被实现，也就是说它不能够同时与<code>abstract</code>搭配修饰函数。</p>
<p><code>static</code>方法是类中的一种特殊方法，当我们需要这个类下的某个方法完成某个特定的目的而无须将其实例化时，才将这个方法修饰为<code>static</code>。如Math类下的所有方法都是静态<code>static</code>的。</p>
<h3 id="static代码块"><a href="#static代码块" class="headerlink" title="static代码块"></a>static代码块</h3><p><code>static</code>修饰的代码块称之为静态代码块，它会随着类加载的时候一块执行。静态代码块可以放置类中任意地方，且在类加载时，静态代码块按从下到上的顺序依次执行。</p>
<h3 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h3><p><code>static</code>修饰的方法不能够调用非<code>static</code>变量或者非<code>static</code>方法</p>
<p><code>static</code>所修饰的方法是从属于类的，且被由该类实例化出的所有对象所共享。若在<code>static</code>方法中调用了非<code>static</code>变量或非<code>static</code>方法，那么在运行期间，程序则无法确定此时的所调用的非<code>static</code>变量的确切值（因为成员变量的实际值取决于其所属的对象），从而导致程序运行错误。</p>
<h2 id="静态代码块与非静态代码块的初始化顺序"><a href="#静态代码块与非静态代码块的初始化顺序" class="headerlink" title="静态代码块与非静态代码块的初始化顺序"></a>静态代码块与非静态代码块的初始化顺序</h2><p><strong>优先级结论：静态代码块 == 静态变量初始化 &gt; 实例代码块 == 实例变量初始化 &gt; 实例构造器。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> util_test;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"main instance block"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        System.out.println(<span class="string">"main static block"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"main instance constructor"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Son();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"father instance block"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        System.out.println(<span class="string">"father static block"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"father instance constructor"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"son instance block"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        System.out.println(<span class="string">"son static block"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"son instance constructor"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正确的执行顺序如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">main static block</div><div class="line">father static block</div><div class="line">son static block</div><div class="line">father instance block</div><div class="line">father instance constructor</div><div class="line">son instance block</div><div class="line">son instance constructor</div></pre></td></tr></table></figure>
<p>分析上述的代码加载过程。</p>
<ol>
<li>因为<code>main</code>方法在Main类中，所以首先加载Main类，因此会执行Main类中的<code>static</code>代码块。接着执行<code>main</code>方法中的<code>new Son()</code>语句，而此时Son类尚未被加载，因此此时需要加载Son类。在加载Son类的时候，发现Son类是继承自Father类，所以转而去优先加载Father类，所以Father类中的<code>static</code>代码块会被执行，然后再执行Son类中的<code>static代码</code>块。</li>
<li>在所有所需的类加载完毕后，就通过构造器来生成对象。而在生成对象的时候，必须先初始化父类的成员变量以及执行实例代码块。因此先执行Father类中的实例代码块与构造器，最后再执行Son类中实例代码块与构造器。</li>
</ol>
<hr>
<p>参考资料</p>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3799052.html" target="_blank" rel="external">Java中的static关键字解析</a></p>
<p><a href="http://www.cnblogs.com/chenssy/p/3386721.html" target="_blank" rel="external">java提高篇(七)—–关键字static</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/31/堆排序（Heap Sort）/">堆排序（Heap Sort）</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-31
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>堆排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。</p>
<h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p>堆的实现通过构造二叉堆，实为二叉树的一种分支。这种数据结构具有以下性质：</p>
<ul>
<li>任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。</li>
<li>堆总是一个完全二叉树，即除了最底层外，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。</li>
</ul>
<p>将根节点最大的堆叫做最大堆，而将根节点最小的堆叫做最小堆。</p>
<p><img src="http://on83riher.bkt.clouddn.com/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%A0%86.png" alt="图源于维基百科"></p>
<h2 id="堆排序中如何表示堆"><a href="#堆排序中如何表示堆" class="headerlink" title="堆排序中如何表示堆"></a>堆排序中如何表示堆</h2><p>由于<strong>堆总是一个完全二叉树</strong>这一特性，这使得堆可以利用<strong>数组</strong>来表示，如下图所示。</p>
<p><img src="http://on83riher.bkt.clouddn.com/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%88%9D%E5%A7%8B.png" alt=""></p>
<p>对于给定的某个节点的下标i，可以很容易的计算出这个节点的父节点、左右孩子节点的下标：</p>
<ul>
<li><strong>Parent(i) = floor((i - 1) / 2)</strong>，i节点的父节点下标</li>
<li><strong>Left(i) = 2i * 1</strong>，i节点的左子节点下标</li>
<li><strong>Right(i) = 2 * (i - 1)</strong>，i节点的右子节点下标</li>
</ul>
<h2 id="堆排序原理（以最大堆为例）"><a href="#堆排序原理（以最大堆为例）" class="headerlink" title="堆排序原理（以最大堆为例）"></a>堆排序原理（以最大堆为例）</h2><p>堆排序就是把最大堆的堆顶取出，将剩余的堆继续调整为最大堆，再将堆顶的数值取出，不断重复这一过程，直至堆中只剩下一个节点为止。堆中定义以下几种操作：</p>
<ul>
<li><strong>最大堆调整（MaxHeapify）</strong>：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li><strong>创建最大堆（BuildMaxHeap）</strong>：将堆所有数据重新排序</li>
<li><strong>推排序（HeapSort）</strong>：移除在第一个数据的根节点，bin并做最大堆调整的递归运算</li>
</ul>
<h4 id="最大堆调整（MaxHeapify）"><a href="#最大堆调整（MaxHeapify）" class="headerlink" title="最大堆调整（MaxHeapify）"></a>最大堆调整（MaxHeapify）</h4><p>最大堆调整的作用是保持最大堆的性质，是整个算法的核心部分。它内部的算法其实决定了堆到底是最大堆还是最小堆。</p>
<p><img src="http://on83riher.bkt.clouddn.com/MAX_HEAPIFY.png" alt=""></p>
<p>代码部分如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// array代表需要排序的数组部分</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapAdjust</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> largest = index;</div><div class="line">    <span class="comment">// 左右子节点在数组中的位置</span></div><div class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * (index + <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 若左子节点大于父节点</span></div><div class="line">    <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; array[index] &lt; array[left]) &#123;</div><div class="line">        largest = left;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 若右子节点大于父节点</span></div><div class="line">    <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; array[largest] &lt; array[right]) &#123;</div><div class="line">        largest = right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 倘若larget并非指向原节点index时，则证明父节点index小于某个子节点left/right</span></div><div class="line">    <span class="keyword">if</span> (largest != index) &#123;</div><div class="line">        swap(largest, index);</div><div class="line">      	<span class="comment">// 因为largest并非index，所以节点largest的堆结构也发生了变化</span></div><div class="line">        maxHeapAdjust(largest, heapSize);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> tmp = queue[i];</div><div class="line">    queue[i] = queue[j];</div><div class="line">    queue[j] = tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非递归实现版本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapAdjustWhile</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> largest, left, right;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        largest = index;</div><div class="line">        left = <span class="number">2</span> * index + <span class="number">1</span>;</div><div class="line">        right = <span class="number">2</span> * (index + <span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 若左子节点大于父节点</span></div><div class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; queue[index] &lt; queue[left]) &#123;</div><div class="line">          	largest = left;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 若右子节点大于父节点</span></div><div class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; queue[largest] &lt; queue[right]) &#123;</div><div class="line">          	largest = right;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 倘若larget并非指向原节点index时，则证明父节点index小于某个子节点left/right</span></div><div class="line">        <span class="keyword">if</span> (largest != index) &#123;</div><div class="line">          	swap(largest, index);</div><div class="line">          	maxHeapAdjustWhile(largest, heapSize);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          	<span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建最大堆（BuildMaxHeap）"><a href="#创建最大堆（BuildMaxHeap）" class="headerlink" title="创建最大堆（BuildMaxHeap）"></a>创建最大堆（BuildMaxHeap）</h4><p>创建最大堆的作用是将一个数组转换为一个最大堆。倘若堆中有n个元素，那么BuildMaxHeap就从Parent(n)开始（因为Parent(n)的节点刚刚好指向最后一个元素的父节点），从下往上地调用MaxHeapify。</p>
<p><img src="http://on83riher.bkt.clouddn.com/BUILD_MAX_HEAP.png" alt=""></p>
<p>代码结构如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span> heapSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> parent = (heapSize - <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">  	<span class="comment">// 可以参考图思考一下，为什么这样循环递减i</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = parent; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        maxHeapAdjust(i, heapSize);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="推排序（HeapSort）"><a href="#推排序（HeapSort）" class="headerlink" title="推排序（HeapSort）"></a>推排序（HeapSort）</h4><p>堆排序是堆排序算法的接口算法部分，HeapSort先调用BuildMaxHeap将传递来的数组转换为最大堆，然后将最大堆堆顶元素与堆底最后一个元素对换，然后再重新调用MaxHeapify来保证最大堆的性质。</p>
<p><img src="http://on83riher.bkt.clouddn.com/HEAPSORT.png" alt=""></p>
<p>代码结构如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxHeapSort() &#123;</div><div class="line">    <span class="keyword">int</span> heapSize = queue.length;</div><div class="line">    buildMaxHeap(heapSize);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = heapSize - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="comment">// 交换堆顶的最大值放置数组末尾</span></div><div class="line">        swap(<span class="number">0</span>, i);</div><div class="line">        <span class="comment">// 重新整理最大堆，范围缩小至除已排序的节点外</span></div><div class="line">        maxHeapAdjust(<span class="number">0</span>, i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> queue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h2><p>最优时间复杂度为O(nlogn)，最坏时间复杂度O(nlogn)。</p>
<p>总空间复杂度为O(n)，辅助空间复杂度O(1)。</p>
<hr>
<p>参考资料</p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F" target="_blank" rel="external">堆排序</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%A0%86_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="external">堆 (数据结构)</a>)</p>
<p><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="external">常见排序算法 - 堆排序 (Heap Sort)</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/30/Java异常机制分析/">Java异常机制分析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-30
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>异常是指程序在运行期间所发生的错误，如使用了空指针、栈溢出、非法参数等。在程序编写期间，编译器会自动检查代码是否符合规范，并尽可能地帮助程序员将其纠正。但即使是看似正确的代码，也可能会在运行期间抛出一个意想不到的异常。</p>
<p>Java为此提供了异常处理机制，即在程序运行期间，倘若抛出了异常，则可以以适当的方式进行捕获处理，使得程序能够正常的运作下去。</p>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p><img src="http://on83riher.bkt.clouddn.com/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt=""></p>
<p>在Java中所有的异常类都是从<code>java.lang.Throwable</code>类集成的子类。</p>
<p>根类<code>Throwable</code>下（仅）有两个重要的子类——<code>Error</code>与<code>Exception</code>。</p>
<ul>
<li><code>Error</code>代表运行期间JVM（Java虚拟机）出现的异常，这种异常一般来说是无法处理的。</li>
<li><code>Exception</code>代表运行期间程序本身的逻辑出现的异常，这种异常一般是程序本身可以处理的。</li>
</ul>
<p>其中，<code>Exception</code>可分为两类：运行时异常和检查异常。</p>
<ul>
<li>检查异常（CheckedException），是指程序在执行某段代码时，是可以提前知道这段代码是存在潜在异常的，而且<strong>要求程序必须以某种方式来处理</strong>。若不处理这种异常情况时，编译器是不会通过编译的。</li>
</ul>
<ul>
<li>运行时异常（RuntimeException），也称为非检查异常，是指程序在运行期间可能会抛出异常，但不要求程序必须处理该异常。在编译期间，编译器也不会要求用户去处理它。</li>
</ul>
<h2 id="TRY-CATCH会不会性能消耗"><a href="#TRY-CATCH会不会性能消耗" class="headerlink" title="TRY-CATCH会不会性能消耗"></a>TRY-CATCH会不会性能消耗</h2><p>当初的自己觉得如果在<code>try-catch</code>块中大量使用循环的话，想当然的认为会消耗大量的性能。但是通过阅读多篇文章后，得出以下结论：</p>
<ul>
<li>异常如果没发生，也就不会去查异常表，也就是说你写不写<code>try-catch</code>，也就是有没有这个异常表的问题，如果没有发生异常，写<code>try-catch</code>对性能是木有消耗的，所以不会让程序跑得更慢。</li>
<li><code>try-catch</code> 的范围大小其实就是异常表中两个值（开始地址和结束地址）的差异而已，也是不会影响性能的。</li>
</ul>
<p>具体文章如下所示：</p>
<p><a href="http://www.cnblogs.com/isline/archive/2010/04/22/1717837.html" target="_blank" rel="external">Try-Catch真的会影响程序性能吗</a></p>
<p><a href="http://blog.csdn.net/tao_zi7890/article/details/17584813" target="_blank" rel="external">Java上的try catch并不影响性能（转）</a></p>
<h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><p>优化建议这一部分是结合了<a href="http://www.cnblogs.com/dolphin0520/p/3769804.html" target="_blank" rel="external">Java异常处理和设计</a>和<a href="https://www.oschina.net/question/12_37141" target="_blank" rel="external">异常处理的 15 个处理原则</a>两文的精华，小弟只能做个低调的搬运工。</p>
<ul>
<li>只在必要使用异常的地方才使用异常，不要用异常去控制程序的流程</li>
</ul>
<p>即使在上述的说到异常机制不会怎么消耗性能，但这并不代表能够在程序中随处使用<code>try-catch</code>。要在程序中谨慎地使用异常，倘若异常使用过多仍然会很大程度上影响程序的性能。如果在程序中能够用<code>if</code>语句来进行逻辑判断，自然能更清楚地表明出当某个字段处于某个阶段时要进行的逻辑，也可以减少异常的使用，从而避免不必要的异常捕获和处理。</p>
<ul>
<li>切忌使用空<code>catch</code>块</li>
</ul>
<p>倘若程序在捕获了异常之后什么都不做，相当于你直接隐藏了这个异常，这可能会导致后面的程序逻辑出现不可控的执行结果，这是一种相当不负责任的行为。倘若有这种情况发生，不如改变程序本身的代码逻辑，使其变得更加健壮，并用日志的方式记录其异常的状态，方便日后的更新和维护。</p>
<ul>
<li>检查异常与非检查异常的选择</li>
</ul>
<p>当你决定要抛出一个自己新定义的异常，你就要决定以什么形式来处理这个异常。</p>
<p>当有些检查异常对开发人员来说是无法通过合理的手段处理的，例如<code>SQLException</code>，这样就会导致在代码中经常出现的一种情况：逻辑代码很少几行，但是要进行异常捕获和异常处理的代码却有很多行，这会导致逻辑代码阅读起来晦涩难懂，使得代码难以维护。</p>
<p>在检查异常与非检查异常的选择上面，如果存在该异常情况的出现很普遍，需要特别提醒调用者注意处理的话，就是用检查异常，否则就使用非检查异常。</p>
<ul>
<li>注意<code>catch</code>块的顺序</li>
</ul>
<p>切忌将捕获父类异常的<code>catch</code>块放置于捕获子类异常<code>catch</code>块前，否则将永远无法到达程序理想的异常处理逻辑状态中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"d:/a.txt"</span>);</div><div class="line">    <span class="keyword">int</span> ch = inputStream.read();</div><div class="line">    System.out.println(<span class="string">"aaa"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="string">"step1"</span>;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    System.out.println(<span class="string">"io exception"</span>);　　      </div><div class="line">    <span class="keyword">return</span> <span class="string">"step2"</span>;</div><div class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">  	<span class="comment">// 永远到不了这一步，因为catch块是从上到下优先匹配到符合该异常类及其父类</span></div><div class="line">  	<span class="comment">// 由于Exception为FileNotFoundException的父类，所以catch块将在第一次匹配中结束</span></div><div class="line">    System.out.println(<span class="string">"file not found"</span>);　　　　      </div><div class="line">    <span class="keyword">return</span> <span class="string">"step3"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>避免多次在日志信息中记录同一异常</li>
</ul>
<p>很多情况下异常都是层层向上抛出，如果在每次向上抛出异常的时候，都记录到日志中，则会导致冗余的异常重复记录在日志中，不仅大量浪费空间，而且很难查找到异常的根源。</p>
<p>妥当的做法是只在异常最开始发生的地方进行日志信息记录。</p>
<ul>
<li>在<code>finally</code>中释放资源</li>
</ul>
<p>如果在程序中存在文件读取、网络操作以及数据库操作等，需要在<code>finally</code>块中释放资源。这样不仅使得程序占用的资源更少，也会避免由于资源未及时释放而导致的异常情况。</p>
<ul>
<li>不要在<code>finally</code>中使用<code>return</code>语句</li>
</ul>
<p>倘若在正常<code>try</code>块中返回值，又或者是，在捕获异常后打算在<code>catch</code>块中返回值的话，切忌在<code>finally</code>块中再返回值，否则<code>finally</code>的返回值将直接取代<code>catch</code>块中的返回值。这不难想象，因为<code>finally</code>块在<code>try-catch</code>执行完后一定会执行的，所以<code>finally</code>中的操作将会正常执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"d:/a.txt"</span>);</div><div class="line">    <span class="keyword">int</span> ch = inputStream.read();</div><div class="line">    System.out.println(<span class="string">"aaa"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="string">"step1"</span>;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    System.out.println(<span class="string">"io exception"</span>);　　      </div><div class="line">    <span class="keyword">return</span> <span class="string">"step2"</span>;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  	System.out.println(<span class="string">"finally end"</span>);　</div><div class="line">  	<span class="comment">// 程序执行到这，会导致最终的返回值是"step3"，而非"step1"，也不会是"step1"</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"step3"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当方法判断出错该返回时应该抛出异常，而不是返回一些错误值</li>
</ul>
<p>因为错误值在程序逻辑中可能会出现难以理解的情况，并且错误值在描述异常的情况并不直观。在文件找不到的时候，应当抛出类似 FileNotFoundException 异常，而不是返回 -1 或者 -2 之类的错误值。</p>
<hr>
<p>参考资料</p>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3769804.html" target="_blank" rel="external">Java异常处理和设计</a></p>
<p><a href="https://www.oschina.net/question/12_37141" target="_blank" rel="external">异常处理的 15 个处理原则</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/29/ArrayList与LinkedList的循环效率对比/">ArrayList与LinkedList的循环效率对比</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-29
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p><code>for</code>循环遍历存在这两种方式，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++);</div><div class="line"><span class="keyword">for</span> (Object object: objects);</div></pre></td></tr></table></figure>
<p><code>ArrayList</code>与<code>LinkedList</code>两种集合在两种方式的遍历存在着较大的性能差距，下面将以以下测试代码作为范例解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_SIZE = <span class="number">2000000</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testList</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</div><div class="line">            list.get(i);</div><div class="line">        &#125;</div><div class="line">        System.out.println(list.getClass().getSimpleName() + <span class="string">"-普通for-花费时间: "</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</div><div class="line"></div><div class="line">        start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (Integer num: list) &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        System.out.println(list.getClass().getSimpleName() + <span class="string">"-foreach-花费时间: "</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; arrayNums = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        List&lt;Integer&gt; linkNums = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_SIZE; i++) &#123;</div><div class="line">            arrayNums.add(i);</div><div class="line">            linkNums.add(i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        testList(arrayNums);</div><div class="line">        testList(linkNums);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试运行结果可得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ArrayList-普通for-花费时间: 5ms</div><div class="line">ArrayList-foreach-花费时间: 7ms</div><div class="line">LinkedList-普通for-花费时间: 32459ms</div><div class="line">LinkedList-foreach-花费时间: 9ms</div></pre></td></tr></table></figure>
<p>从上述的结果中，可以看出<code>ArrayList</code>在普通for循环上更胜一筹，而在LinkedList在foreach上效率极高。倘若数据量不断上升，那么这个差距只会不断加大。</p>
<p>那么为什么会造成上述情况发生呢？</p>
<h2 id="问题解释"><a href="#问题解释" class="headerlink" title="问题解释"></a>问题解释</h2><p>问题可以从两者的结构体系上分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></div><div class="line"><span class="class">        </span></div><div class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></div></pre></td></tr></table></figure>
<p>在两者对比中，我们可以发现<code>ArrayList</code>中实现了<code>RandomAccess</code>接口，而<code>LinkedList</code>没有实现。仔细查看RandomAccess的注释解释，如果实现该接口的<code>List</code>，在普通for循环遍历的效率上会快于foreach循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Marker interface used by &lt;tt&gt;List&lt;/tt&gt; implementations to indicate that</span></div><div class="line"><span class="comment"> * they support fast (generally constant time) random access.  The primary</span></div><div class="line"><span class="comment"> * purpose of this interface is to allow generic algorithms to alter their</span></div><div class="line"><span class="comment"> * behavior to provide good performance when applied to either random or</span></div><div class="line"><span class="comment"> * sequential access lists.</span></div><div class="line"><span class="comment"> * List实现所使用的标记接口，用来表明实现了这个接口的list支持快速随机访问(通常在常数时</span></div><div class="line"><span class="comment"> * 间内)。这个接口主要目的在于允许一般的算法更改它们的行为，以便在随机或者顺序访问list</span></div><div class="line"><span class="comment"> * 时有更好的性能。</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;p&gt;The best algorithms for manipulating random access lists (such as</span></div><div class="line"><span class="comment"> * &lt;tt&gt;ArrayList&lt;/tt&gt;) can produce quadratic behavior when applied to</span></div><div class="line"><span class="comment"> * sequential access lists (such as &lt;tt&gt;LinkedList&lt;/tt&gt;).  Generic list</span></div><div class="line"><span class="comment"> * algorithms are encouraged to check whether the given list is an</span></div><div class="line"><span class="comment"> * &lt;tt&gt;instanceof&lt;/tt&gt; this interface before applying an algorithm that would</span></div><div class="line"><span class="comment"> * provide poor performance if it were applied to a sequential access list,</span></div><div class="line"><span class="comment"> * and to alter their behavior if necessary to guarantee acceptable</span></div><div class="line"><span class="comment"> * performance.</span></div><div class="line"><span class="comment"> * 操作随机访问列表(如ArrayList)的最佳算法在顺序访问列表(如LinkedList)上应用，会产</span></div><div class="line"><span class="comment"> * 生歧义行为。泛型列表的算法鼓励在将某个算法应用于顺序访问列表可能产生较差的性能之前，</span></div><div class="line"><span class="comment"> * 检查给定的列表是不是这个接口的实现，并在有必要的时候修改它们的行为，以保证提供可接受</span></div><div class="line"><span class="comment"> * 的性能。</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;p&gt;It is recognized that the distinction between random and sequential</span></div><div class="line"><span class="comment"> * access is often fuzzy.  For example, some &lt;tt&gt;List&lt;/tt&gt; implementations</span></div><div class="line"><span class="comment"> * provide asymptotically linear access times if they get huge, but constant</span></div><div class="line"><span class="comment"> * access times in practice.  Such a &lt;tt&gt;List&lt;/tt&gt; implementation</span></div><div class="line"><span class="comment"> * should generally implement this interface.  As a rule of thumb, a</span></div><div class="line"><span class="comment"> * &lt;tt&gt;List&lt;/tt&gt; implementation should implement this interface if,</span></div><div class="line"><span class="comment"> * for typical instances of the class, this loop:</span></div><div class="line"><span class="comment"> * 在界定随机访问与顺序访问的界限一般都是模糊不清的。例如，某些列表在它们拥有大量的数据</span></div><div class="line"><span class="comment"> * 时提供非线性访问时间，但实际上是常量级别的访问时间。这样的接口应该实现该接口。</span></div><div class="line"><span class="comment"> * &lt;pre&gt;</span></div><div class="line"><span class="comment"> *     for (int i=0, n=list.size(); i &amp;lt; n; i++)</span></div><div class="line"><span class="comment"> *         list.get(i);</span></div><div class="line"><span class="comment"> * &lt;/pre&gt;</span></div><div class="line"><span class="comment"> * runs faster than this loop:</span></div><div class="line"><span class="comment"> * 比下面的循环运行速度更快。</span></div><div class="line"><span class="comment"> * &lt;pre&gt;</span></div><div class="line"><span class="comment"> *     for (Iterator i=list.iterator(); i.hasNext(); )</span></div><div class="line"><span class="comment"> *         i.next();</span></div><div class="line"><span class="comment"> * &lt;/pre&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomAccess</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>参考资料</p>
<p><a href="http://www.jianshu.com/p/d5ec2ff72b33" target="_blank" rel="external">Java集合干货系列-（二）LinkedList源码解析</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/29/LinkedList 源码分析/">LinkedList 源码分析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-29
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="结构体系"><a href="#结构体系" class="headerlink" title="结构体系"></a>结构体系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></div></pre></td></tr></table></figure>
<p><code>LinkedList</code>继承自<code>AbstractSequentialList</code>，并同时实现了<code>List</code>、<code>Deque</code>、<code>Cloneable</code>与<code>Serializable</code>接口。从继承体系上与接口上，可以看出<code>LinkedList</code>不仅仅是<strong>双向链表</strong>而已，它可以同时被当做<strong>双向队列</strong>进行操作。</p>
<p>为什么是双向链表呢？后面一小节将会解释。</p>
<h2 id="常量与重要成员"><a href="#常量与重要成员" class="headerlink" title="常量与重要成员"></a>常量与重要成员</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 记录链表上实际装载的节点个数</span></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"><span class="comment">// 指向链表头部的指针</span></div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</div><div class="line"><span class="comment">// 指向链表尾部的指针</span></div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</div></pre></td></tr></table></figure>
<p>在成员变量中，我们可以看到链表所承载的节点是<code>Node</code>，下面看看<code>Node</code>是怎么构成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    E item; <span class="comment">// 节点上承载的值</span></div><div class="line">    Node&lt;E&gt; next; <span class="comment">// 指向前一个节点</span></div><div class="line">    Node&lt;E&gt; prev; <span class="comment">// 指向后一个节点</span></div><div class="line"></div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.item = element;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">        <span class="keyword">this</span>.prev = prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从<code>Node</code>中，不难看出<code>LinkedList</code>就是一个双向链表的集合，如下所示。</p>
<p><img src="http://on83riher.bkt.clouddn.com/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt=""></p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>();</div><div class="line">    addAll(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LinkedList</code>的构造函数可以说是很简约了，毕竟内部不像<code>ArrayList</code>里面还有个数组作支撑，只需头/尾指针即可。</p>
<h2 id="基本操作-node"><a href="#基本操作-node" class="headerlink" title="基本操作 - node()"></a>基本操作 - node()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在LinkedList中，在某些需要在指定节点中进行操作的时候，是怎么通过索引下标的形式找到指定节点的呢</span></div><div class="line"><span class="comment">// LinkedList内部提供了node()方法来实现这一目标。顺便一提node()内部充分使用了头尾节点的好处，将遍历范围缩减到size/2内</span></div><div class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert isElementIndex(index);</span></div><div class="line">	</div><div class="line">  	<span class="comment">// 若index &gt; size/2</span></div><div class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="添加操作-add"><a href="#添加操作-add" class="headerlink" title="添加操作 - add()"></a>添加操作 - add()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    linkLast(e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    checkPositionIndex(index);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (index == size)</div><div class="line">      linkLast(element);</div><div class="line">    <span class="keyword">else</span></div><div class="line">      linkBefore(element, node(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的<code>add()</code>方法均调用了<code>link*（）</code>字样的方法，其实这是<code>LinkedList</code>内部用于对链表的中<strong>单个节点</strong>的操作。相对应的<code>remove()</code>方法也会调用<code>unlink*()</code>字样的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 作为头节点链接到链表中</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</div><div class="line">    first = newNode;</div><div class="line">  	<span class="comment">// 若f为null, 则表明链表为空</span></div><div class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</div><div class="line">        last = newNode;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        f.prev = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 作为尾节点链接到链表中</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</div><div class="line">    last = newNode;</div><div class="line">  	<span class="comment">// 若l为null, 则表明链表为空</span></div><div class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</div><div class="line">        first = newNode;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        l.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将新节点插在指定节点前</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert succ != null;</span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</div><div class="line">    succ.prev = newNode;</div><div class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</div><div class="line">        first = newNode;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        pred.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LinkedList</code>也提供了将一组数据添加入链表中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">  	<span class="comment">// 默认从尾节点后插入</span></div><div class="line">  	<span class="keyword">return</span> addAll(size, c);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    checkPositionIndex(index);</div><div class="line"></div><div class="line">    Object[] a = c.toArray();</div><div class="line">    <span class="keyword">int</span> numNew = a.length;</div><div class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    Node&lt;E&gt; pred, succ;</div><div class="line">  	<span class="comment">// 若指定位置就是尾节点时</span></div><div class="line">    <span class="keyword">if</span> (index == size) &#123;</div><div class="line">      succ = <span class="keyword">null</span>;</div><div class="line">      pred = last;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      succ = node(index);</div><div class="line">      pred = succ.prev;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (Object o : a) &#123;</div><div class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</div><div class="line">      Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</div><div class="line">      <span class="comment">// 确保头节点始终不为空</span></div><div class="line">      <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</div><div class="line">      	first = newNode;</div><div class="line">      <span class="keyword">else</span></div><div class="line">        pred.next = newNode;</div><div class="line">      pred = newNode;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  	<span class="comment">// 确保尾节点不为空</span></div><div class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</div><div class="line">      last = pred;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      pred.next = succ;</div><div class="line">      succ.prev = pred;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    size += numNew;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="删除操作-remove"><a href="#删除操作-remove" class="headerlink" title="删除操作 - remove()"></a>删除操作 - remove()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> removeFirst();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    checkElementIndex(index);</div><div class="line">    <span class="keyword">return</span> unlink(node(index));</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</div><div class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    <span class="keyword">return</span> unlinkFirst(f);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">	<span class="keyword">if</span> (l == <span class="keyword">null</span>)</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">	<span class="keyword">return</span> unlinkLast(l);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>remove()</code>如同<code>add()</code>一样，使用着功能截然相反的<code>unlink*()</code>方法，但逻辑处理难度上较大与<code>link*()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 删除非空头节点</span></div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></div><div class="line">    <span class="keyword">final</span> E element = f.item;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</div><div class="line">    f.item = <span class="keyword">null</span>;</div><div class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// 方便GC进行垃圾回收</span></div><div class="line">    first = next;</div><div class="line">  	<span class="comment">// 若链表中只有单个节点</span></div><div class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</div><div class="line">        last = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        next.prev = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 删除非空尾节点</span></div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></div><div class="line">    <span class="keyword">final</span> E element = l.item;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</div><div class="line">    l.item = <span class="keyword">null</span>;</div><div class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// 方便GC进行垃圾回收</span></div><div class="line">    last = prev;</div><div class="line">  	<span class="comment">// 若链表中只有单个节点</span></div><div class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</div><div class="line">        first = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        prev.next = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 删除指定节点</span></div><div class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert x != null;</span></div><div class="line">    <span class="keyword">final</span> E element = x.item;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</div><div class="line"></div><div class="line">  	<span class="comment">// 若prev指向的上一个节点为空，那么该节点为头节点</span></div><div class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</div><div class="line">        first = next;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        prev.next = next;</div><div class="line">        x.prev = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  	<span class="comment">// 若next指向的下一个节点为空，那么该节点为尾节点</span></div><div class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</div><div class="line">        last = prev;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        next.prev = prev;</div><div class="line">        x.next = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    x.item = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>remove()</code>操作中还提供了根据给定值删除指定节点的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="comment">// 若给定值为null</span></div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">    	<span class="comment">// 在这里就不能缩减范围提高效率了，只能老实的进行从头遍历到尾</span></div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</div><div class="line">              	unlink(x);</div><div class="line">              	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</div><div class="line">              	unlink(x);</div><div class="line">              	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="查询操作-get"><a href="#查询操作-get" class="headerlink" title="查询操作 - get()"></a>查询操作 - get()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    checkElementIndex(index);</div><div class="line">    <span class="keyword">return</span> node(index).item;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">	<span class="keyword">if</span> (f == <span class="keyword">null</span>)</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">	<span class="keyword">return</span> f.item;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">	<span class="keyword">if</span> (l == <span class="keyword">null</span>)</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">	<span class="keyword">return</span> l.item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="修改操作-set"><a href="#修改操作-set" class="headerlink" title="修改操作 - set()"></a>修改操作 - set()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    checkElementIndex(index);</div><div class="line">    Node&lt;E&gt; x = node(index);</div><div class="line">    E oldVal = x.item;</div><div class="line">    x.item = element;</div><div class="line">    <span class="keyword">return</span> oldVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实现了Deque接口的相关操作"><a href="#实现了Deque接口的相关操作" class="headerlink" title="实现了Deque接口的相关操作"></a>实现了Deque接口的相关操作</h2><p>别忘了，LinkedList实现了Deque接口，这说明操作LinkedList也可以像操作双向队列一样。如同<code>*first()</code>以及<code>*last()</code>这种操作也属于Deque要求实现的，下面将列出别的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">	<span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/28/Map-Entry 使用解析/">Map.Entry 使用解析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-28
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><code>Map.Entry</code>是<code>Map</code>声明的一个内部接口，此接口为泛型，定义为<code>Entry&lt;K,V&gt;</code>。它可用于 表示Map中的一个键值对。</p>
<p>在<code>Map</code>提供的<code>EntrySet()</code>返回的是<code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code>，是一个<code>Set</code>集合，刺激和类型是<code>Map.Entry</code>。相较于<code>Map</code>所提供的另一个方法<code>keySet()</code>，它所提供的以<code>key</code>值为数据的<code>Set</code>集合。</p>
<h2 id="使用以及对比"><a href="#使用以及对比" class="headerlink" title="使用以及对比"></a>使用以及对比</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// keySet()循环遍历</span></div><div class="line"><span class="keyword">for</span> (Object key: map.keySet()) &#123;</div><div class="line">    Object key = key;</div><div class="line">  	Object value = map.get(key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// entrySet()循环遍历</span></div><div class="line"><span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry: map.entrySet()) &#123;</div><div class="line">    Object = entry.getKey();</div><div class="line">  	Object = entry.getValue();</div><div class="line">  	<span class="comment">// entry.setValue()</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上两种方式中，相较于<code>keySet()</code>遍历<code>Map</code>，<code>entrySet()</code>能够更加清晰的显示<code>Map</code>内部的数据结构，同时<code>entrySet()</code>提供了用于修改<code>Map</code>的值。</p>
<hr>
<p>参考链接</p>
<p><a href="http://www.cnblogs.com/ningvsban/archive/2013/05/06/3062217.html" target="_blank" rel="external">Map.Entry使用详解</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/27/ArrayList 源码分析/">ArrayList 源码分析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-27
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="常量与重要的成员变量"><a href="#常量与重要的成员变量" class="headerlink" title="常量与重要的成员变量"></a>常量与重要的成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 默认容量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="comment">// 空数组-对应第一个构造函数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 默认空数组-对应第二个构造函数。这个与上面EMPTY_ELEMENTDATA要进行区别，根据源码解释说到，两个变量决定了当第一次插入数据时容器的扩容机制，在这里相当于起到了标志位的作用。实际操作看扩容与缩容部分</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// ArrayList内部的真实容器(数组)</span></div><div class="line"><span class="keyword">transient</span> Object[] elementData;</div><div class="line"></div><div class="line"><span class="comment">// ArrayList内部的记录实际装载数据个数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根据用户自定义容量初始化容器</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">                                           initialCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 默认构造函数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 由一组数组进行容器的初始化(前提该数组必须是实现了Collection接口，并继承或来源于&lt;E&gt;)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    elementData = c.toArray();</div><div class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 倘若返回的Class类型并非Object[]，需要Arrays.copy()将其类型转化为Object[]</span></div><div class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</div><div class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 若该组数组为空数组</span></div><div class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>EMPTY_ELEMENTDATA</code>与<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>两个标志位，个人认为：</p>
<ul>
<li>如果以默认的构造函数模式初始化ArrayList，则以ArrayList内部的增长模式扩展，即初始化时容器大小就是DEFAULT_CAPACITY，即为10</li>
<li>如果</li>
</ul>
<h2 id="增加操作-——-add"><a href="#增加操作-——-add" class="headerlink" title="增加操作 —— add()"></a>增加操作 —— add()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 顺序插入数据</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">  	<span class="comment">// 无论是哪种插入操作，都需要提前进行扩容，防止抛出ArrayIndexOutOfBoundsException</span></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在指定位置上插入数据</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">  	<span class="comment">// if (index&lt;0 || index&gt;size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span></div><div class="line">    rangeCheckForAdd(index);</div><div class="line"></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</div><div class="line">  	<span class="comment">// System.arraycopy(Object src, int srcPos,</span></div><div class="line">  	<span class="comment">//					Object dest, int destPos,</span></div><div class="line">  	<span class="comment">//					int length)</span></div><div class="line">  	<span class="comment">// 即从原数组(src)中的指定位置(src)，复制一定长度的数据(length)，到目标数组(dest)的指定位置上(destPos)</span></div><div class="line">  	System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">                     size - index);</div><div class="line">    elementData[index] = element;</div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 顺序插入一组数据</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    Object[] a = c.toArray();</div><div class="line">    <span class="keyword">int</span> numNew = a.length;</div><div class="line">    ensureCapacityInternal(size + numNew);</div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</div><div class="line">    size += numNew;</div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在指定位置上，插入一组数据</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    rangeCheckForAdd(index);</div><div class="line"></div><div class="line">    Object[] a = c.toArray();</div><div class="line">    <span class="keyword">int</span> numNew = a.length;</div><div class="line">    ensureCapacityInternal(size + numNew);</div><div class="line"></div><div class="line">  	<span class="comment">// 原数组中需要移动的个数</span></div><div class="line">    <span class="keyword">int</span> numMoved = size - index;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">      System.arraycopy(elementData, index, elementData, index + numNew,</div><div class="line">                       numMoved);</div><div class="line"></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</div><div class="line">    size += numNew;</div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在ArrayList内部，数组的移动往往通过<code>System.arraycopy()</code>和<code>Array.copy()</code>进行操作。这种方式增加了提高了内聚性，也避免了大量的重复代码出现在不同地方中。</p>
<h2 id="扩容与缩容操作-ensureCapacity-与trimToSize"><a href="#扩容与缩容操作-ensureCapacity-与trimToSize" class="headerlink" title="扩容与缩容操作 - ensureCapacity()与trimToSize()"></a>扩容与缩容操作 - ensureCapacity()与trimToSize()</h2><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法域为public，即该方法是方便用户根据自己的需求直接扩展容器容量</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">  	<span class="comment">// 此时出现了DEFAULTCAPACITY_EMPTY_ELEMENTDATA标志，该字段是表明不同的标志位所要求的最低扩展阈值不同</span></div><div class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</div><div class="line">        ? <span class="number">0</span></div><div class="line">        : DEFAULT_CAPACITY;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</div><div class="line">      	<span class="comment">// 最终调用内部的ensureCapacityInternal()</span></div><div class="line">        ensureExplicitCapacity(minCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方法域为private，内部只存在简单的判断逻辑，用于判断该数组是不是DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 最终确认容器是否有必要进行扩容操作(毕竟每扩容一次，代表这一次性能消耗，扩容操作越频繁，性能消耗越大)</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实际执行扩容操作</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  <span class="comment">// 新容器大小为旧容器的1.5倍</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">      newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">      newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 由于ArrayList本身是不会进行缩容的，于是在进行大量的数据插入删除后，会造成大面积的空间浪费</span></div><div class="line"><span class="comment">// 此时用户可以自己通过trimToSize()来缩容</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</div><div class="line">        elementData = (size == <span class="number">0</span>)</div><div class="line">          ? EMPTY_ELEMENTDATA</div><div class="line">          : Arrays.copyOf(elementData, size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="删除操作-remove"><a href="#删除操作-remove" class="headerlink" title="删除操作 - remove()"></a>删除操作 - remove()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在指定位置上删除数据</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">      	<span class="comment">// 数组直接向左移动ß</span></div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// 进行清空操作，方便GC回收</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 删除指定数据(碰到的第一个)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">      	System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                       numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 还存在其他删除操作，但原理基本相同</span></div></pre></td></tr></table></figure>
<h2 id="查找操作-get"><a href="#查找操作-get" class="headerlink" title="查找操作 - get()"></a>查找操作 - get()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 时间复杂度O(1)</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> elementData(index);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (E) elementData[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="修改操作-set"><a href="#修改操作-set" class="headerlink" title="修改操作 - set()"></a>修改操作 - set()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 时间复杂度O(1)</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    E oldValue = elementData(index);</div><div class="line">    elementData[index] = element;</div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="三种遍历ArrayList的方式"><a href="#三种遍历ArrayList的方式" class="headerlink" title="三种遍历ArrayList的方式"></a>三种遍历ArrayList的方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一种，通过迭代器遍历</span></div><div class="line">Integer value = <span class="keyword">null</span>;</div><div class="line">Iterator iter = list.iterator();</div><div class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">    value = (Integer)iter.next();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 第二种，随机访问(RandomAccess)，通过索引值去遍历 -&gt; 效率最高</span></div><div class="line">Integer value = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">int</span> size = list.size();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">    value = (Integer) list.get(i);        </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 第三种，for循环遍历 -&gt; 效率最低</span></div><div class="line">Integer value = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">for</span> (Integer integer: list) &#123;</div><div class="line">    value = integer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>参考资料：</p>
<p><a href="http://www.jianshu.com/p/2cd7be850540" target="_blank" rel="external">Java集合干货系列-（一）ArrayList源码解析</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/26/HashMap 源码分析/">HashMap 源码分析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-26
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>下图可从可视化的角度理解 HashMap（其实也是方便自己想起来）。</p>
<p><img src="http://4.bp.blogspot.com/-unPwpp8AJTA/U0e9S0F5ljI/AAAAAAAAAUo/xMnUVRO5fyY/s1600/how+hashmap+works+internally+in+java+.png" alt=""></p>
<h2 id="常量与重要的成员变量"><a href="#常量与重要的成员变量" class="headerlink" title="常量与重要的成员变量"></a>常量与重要的成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 默认容量(也是最小容量阈值)</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></div><div class="line"><span class="comment">// 最大容量阈值</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"><span class="comment">// 默认负载因子</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line"><span class="comment">// 从链表转变为红黑树的阈值</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</div><div class="line"><span class="comment">// 从红黑树转变为链表的阈值</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</div><div class="line"><span class="comment">// 从链表转变为红黑树的最小容量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</div><div class="line"></div><div class="line"><span class="comment">// HashMap 实际存储键值对的容器</span></div><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div><div class="line"><span class="comment">// HashMap 实际阈值，其值由 capacity * loadFactor 决定</span></div><div class="line"><span class="keyword">int</span> threshold;</div></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">  	<span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                       initialCapacity);</div><div class="line">  	<span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">    	initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">  	<span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                       loadFactor);</div><div class="line">  	<span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">  	<span class="comment">// 重点！</span></div><div class="line">  	<span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 该方法用于返回大于给定容量的最小2的幂次方的数值</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为什么 HashMap 的容量数值非要是2的幂次方呢？请看<a href="https://www.zhihu.com/question/20733617" target="_blank" rel="external">JDK 源码中 HashMap 的 hash 方法原理是什么？</a> </p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash()"></a>hash()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HashMap 中的实际 hash 值计算是通过 <code>key.hashCode()</code>所得出来的<code>h</code> ，与<code>h</code>无条件右移16位后，进行按位异或<code>^</code>得出来的。</p>
<p>但是怎么转化成实际上<code>table</code>数组的所索引值呢？剧透一下，<code>table</code> 的索引值是通过 <code>capacity</code>与<code>hash</code>进行按位与<code>&amp;</code>计算出来的。</p>
<h2 id="putVal"><a href="#putVal" class="headerlink" title="putVal()"></a>putVal()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    </div><div class="line">  	<span class="comment">// 当HashMap中的数组，即table为空，或者table的长度为0时，调用 resize 方式进行 HashMap 的初始化(HashMap真正的容器初始化阶段是在第一次插入时)</span></div><div class="line">  	<span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">       	n = (tab = resize()).length;</div><div class="line">   	</div><div class="line">  	<span class="comment">// 根据n(capacity)-1与hash值进行按位运算，获得该key值对应的数组中的位置。若该索引(p)上的值为null，则直接创建新的节点</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">  </div><div class="line">  	<span class="comment">// 该索引上的值不为null，那么需要分以下三种情况分析</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">      </div><div class="line">      	<span class="comment">// 该p的hash值与传入的hash值相等，并且p的key值也与传入的key值相等，或者在hash值不相同的情况下，两者的key值是相同的</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">      </div><div class="line">      	<span class="comment">// 若p的key值不等于传入的key值</span></div><div class="line">      	<span class="comment">// p的类型属于TreeNode，即从属于红黑树，则转由红黑树进行实际节点添加的操作</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">      	<span class="comment">// p的类型属于Node，即从属于链表。这里就是HashMap中怎么处理哈希冲突的办法。</span></div><div class="line">      	<span class="comment">// 当传入元素的hash值与数组上的元素相同，但key不同时。</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">      </div><div class="line">      	<span class="comment">// 当上述的添加新节点的阶段结束后，若此时的e(即原始节点)不为空时，则进行值的替换。</span></div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  	</div><div class="line">    ++modCount;	<span class="comment">// 用于记录修改的操作次数</span></div><div class="line">	<span class="comment">// 若此时的容器容量大于阈值时，进行resize()扩容容器</span></div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果看懂了putVal()，那么get()就是同样的方式分析了</span></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h2><p><code>resize()</code>实际上的目的在于将原数组中的值均匀地平摊到新数组中，这样无论是插入还是访问的效率也会有一定的提升。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这一部分分析难度不亚于putVal()</span></div><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">  </div><div class="line">  	<span class="comment">// 若老数组为0，那么老容量为0，否则为老数组长度</span></div><div class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line">    <span class="keyword">int</span> oldThr = threshold;</div><div class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">  </div><div class="line">  	<span class="comment">// 若老容量大于0</span></div><div class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">      	<span class="comment">// 若老容量是否大于最大容量阈值</span></div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span> oldTab;</div><div class="line">        &#125;</div><div class="line">      	<span class="comment">// 若扩容后的新容量小于最大容量阈值且老容量大于默认容量值，则新阈值为老阈值的两倍</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  	<span class="comment">// 若老容量等于0且老阈值大于0，那么新容量就等于老阈值</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</div><div class="line">        newCap = oldThr;</div><div class="line">  	<span class="comment">// 若老容量等于0且老阈值也为0，这种比较极端了</span></div><div class="line">  	<span class="comment">// 新容量为默认容量值，而新阈值也为默认阈值(0.75)</span></div><div class="line">    <span class="keyword">else</span> &#123;               </div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  	<span class="comment">// 若新阈值为0，那么则由负载因子与新容量的乘积获得</span></div><div class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    threshold = newThr;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">  </div><div class="line">  	<span class="comment">// 实际操作部分，初始化新容器！</span></div><div class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">  	</div><div class="line">  	<span class="comment">// 其实HashMap的初始化阶段从这里就结束了，以下部分只适用于存有实际节点的容器</span></div><div class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">      	<span class="comment">// 遍历老数组</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">          	<span class="comment">// 若该索引上的节点部位不为空，则分以下三种情况分析</span></div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                oldTab[j] = <span class="keyword">null</span>;</div><div class="line">              	<span class="comment">// 单个节点</span></div><div class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">              	<span class="comment">// 红黑树</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">              	<span class="comment">// 链表</span></div><div class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></div><div class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                loHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                hiHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        loTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        hiTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="keyword">return</span> newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际可视化操作如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1541350-f1221a46429fffc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="为什么-HashMap-不是线程安全的？"><a href="#为什么-HashMap-不是线程安全的？" class="headerlink" title="为什么 HashMap 不是线程安全的？"></a>为什么 HashMap 不是线程安全的？</h2><p>根据《Java并发编程的艺术》中写道：</p>
<blockquote>
<p>HashMap 在并发执行 put 操作时会引起死循环，导致 CPU 利用率接近100%。因为多线程会导致 HashMap 的 Node 链表形成环形数据结构，一旦形成环形数据结构，Node 的 next 节点永远不为空，就会在获取 Node 时产生死循环。</p>
</blockquote>
<p>实际原理可以<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="external">疫苗：JAVA HASHMAP的死循环</a>一文。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/12/《别让我思考》读书笔记/">《别让我思考》读书笔记</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-12
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h3 id="别让我思考"><a href="#别让我思考" class="headerlink" title="别让我思考"></a>别让我思考</h3><h4 id="Krug-可用性第一定律"><a href="#Krug-可用性第一定律" class="headerlink" title="Krug 可用性第一定律"></a>Krug 可用性第一定律</h4><p><strong>设计者应该尽量做到，当我看一个页面时，他应该是不言而喻、一目了然、自我解释的。</strong>我应该能明白它——它是什么，怎样使用它——而不需要花费精力进行思考。</p>
<p>网页上每项内容都有可能迫使我们停下来，进行不必要的思考。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">作为一个用户，永远不该让我们花上几微秒去思考某个东西是否能点击。你可能会这么想，“其实，找出某个东西是否能点击并不需要花费多大工夫。如果你将鼠标移过去，它的光标由箭头变成一只小手，就表示可以点击。这会有很大的问题吗？”。</div><div class="line"></div><div class="line">问题是，当我们访问 Web 的时候，每个问号都会加重我们的认知负担，把我们的注意力从要完成的任务上拉开。这种干扰也许很轻微，但它们会累积起来，有时候这样的干扰不用太多，就足以让我们抓狂。况且，人们通常不喜欢苦苦思索背后的原理。</div></pre></td></tr></table></figure>
<hr>
<h3 id="我们实际上是如何使用-Web-的"><a href="#我们实际上是如何使用-Web-的" class="headerlink" title="我们实际上是如何使用 Web 的"></a>我们实际上是如何使用 Web 的</h3><h4 id="扫描，满意即可，勉强应付"><a href="#扫描，满意即可，勉强应付" class="headerlink" title="扫描，满意即可，勉强应付"></a>扫描，满意即可，勉强应付</h4><p>如果想设计有效地网页，你必须开始接受关于网络使用情况的三个事实。</p>
<h5 id="第一个事实：我们不是阅读，二是扫描"><a href="#第一个事实：我们不是阅读，二是扫描" class="headerlink" title="第一个事实：我们不是阅读，二是扫描"></a>第一个事实：我们不是阅读，二是扫描</h5><p><strong>人们会花极少的时间来阅读大部分的页面，其实，我们只是扫描一下（或者匆匆掠过）网页，寻找能够吸引我们注意力的文字或词语。</strong></p>
<p>我们为什么扫描：</p>
<ul>
<li><strong>我们总是处于忙碌之中。</strong>Web 用户的行为更像鲨鱼，即它们不得不一直移动，否则就会死掉。我们没有时间阅读那些不必要的内容。</li>
<li><strong>我们知道自己不必阅读所有内容。</strong>在绝大多数页面上，我们实际上只对其中一小部分内容感兴趣，剩下的内容我们并不关心。</li>
<li><strong>我们善于扫描。</strong></li>
</ul>
<h5 id="第二个事实：我们不做最佳选择，而是满意即可"><a href="#第二个事实：我们不做最佳选择，而是满意即可" class="headerlink" title="第二个事实：我们不做最佳选择，而是满意即可"></a>第二个事实：我们不做最佳选择，而是满意即可</h5><p>在设计页面时，我们通常假设用户只是扫过整个页面，考虑所有可能的选项，然后选择一个最好的。<strong>然而，事实上，大多数时间里我们不会选择最佳选项，而是选择第一个合理的选项，这就是满意策略。</strong>一旦我们发现一个链接，看起来似乎能够跳转到我们想去的地方，那就是一个我们将会点击它的大好机会。</p>
<p>我们为什么不寻找最佳选择：</p>
<ul>
<li><strong>我们总是处于忙碌之中。</strong></li>
<li><strong>如果猜错了，也不会产生什么严重的后果。</strong>与救火不同，在网站上做了一次错误选择的后果通常只是点击几次后退按钮。</li>
<li><strong>对选择进行权衡并不会改善我们的机会。</strong></li>
<li><strong>猜测更有意思。</strong>猜测不会像仔细衡量那么累，而且如果猜对了，速度会更快。他还会带来一个机会因素——有可能无意中看到某个令人意外但不错的内容，这种可能性让人开心。</li>
</ul>
<h5 id="第三个事实：我们不是追根究底，而是勉强应对"><a href="#第三个事实：我们不是追根究底，而是勉强应对" class="headerlink" title="第三个事实：我们不是追根究底，而是勉强应对"></a>第三个事实：我们不是追根究底，而是勉强应对</h5><p>在很大程度上人们一直在使用这些东西，但并不理解它们的运作原理，甚至对它们的工作原理有完全错误的理解。无论面对哪种技术，很少有人会花时间读说明书。<strong>相反，我们贸然前进，勉强应对，编造出我们自己模棱两可的故事，来解释我们的所作所为，以及为什么这样能行得通。</strong></p>
<p>为什么会这样：</p>
<ul>
<li><strong>这对我们来说并不重要。</strong>对于我们中的大多数人来说，是否明白事物背后的工作机制并不重要，只要我们能正常使用它们即可。这并不是智力低下的表现，而是我们并不关心。</li>
<li><strong>如果发现某个事物能用，我们会一直用它。</strong>我们一旦发现某个事物能够用（不管有多难用），我们也不会去找一种更好的方法（至少不会主动去找）。</li>
</ul>
<hr>
<h3 id="广告牌设计101法则"><a href="#广告牌设计101法则" class="headerlink" title="广告牌设计101法则"></a>广告牌设计101法则</h3><h4 id="为扫描设计，不为阅读设计"><a href="#为扫描设计，不为阅读设计" class="headerlink" title="为扫描设计，不为阅读设计"></a>为扫描设计，不为阅读设计</h4><p>如果用户们都是疾驰而过，那么，你需要注意以下5个重要方面，来保证他们尽可能地看到了并理解了你的网站：</p>
<h5 id="在每个页面上建立清楚的视觉层次。"><a href="#在每个页面上建立清楚的视觉层次。" class="headerlink" title="在每个页面上建立清楚的视觉层次。"></a>在每个页面上建立清楚的视觉层次。</h5><ul>
<li>越重要的部分越突出。</li>
<li>逻辑上相关的部分在视觉上也相关。</li>
<li>逻辑上包含的部分在视觉上进行嵌套。</li>
</ul>
<h5 id="尽可能利用习惯用法。"><a href="#尽可能利用习惯用法。" class="headerlink" title="尽可能利用习惯用法。"></a>尽可能利用习惯用法。</h5><ul>
<li><strong>（优）它们非常有用。</strong>通常，习惯用法因为有用才会成为习惯用法。适当使用习惯用法会使用户在网站之间的访问更容易，不需要花费额外的努力来得到背后的工作原理。</li>
<li><strong>（劣）设计师通常不愿意利用他们。</strong>和使用习惯用法相比，设计师们都面临着很大的诱惑，想要重新发明轮子很大程度上是因为他们觉得他们的职业使命感，趋势他们去做一些崭新的，与众不同的设计。</li>
</ul>
<h5 id="把页面划分成明确定义的区域。"><a href="#把页面划分成明确定义的区域。" class="headerlink" title="把页面划分成明确定义的区域。"></a>把页面划分成明确定义的区域。</h5><p>把页面划分成明确意义的区域，可以让用户很快决定关注页面的哪些区域，或者放心地跳过哪些区域。</p>
<h5 id="明显标识可以点击的地方。"><a href="#明显标识可以点击的地方。" class="headerlink" title="明显标识可以点击的地方。"></a>明显标识可以点击的地方。</h5><h5 id="最大限度降低干扰。"><a href="#最大限度降低干扰。" class="headerlink" title="最大限度降低干扰。"></a>最大限度降低干扰。</h5><p>有效降低噪音的方式——在设计页面的收，先假定所有的内容都是视觉噪声，除非得到证明它们不是。</p>
<hr>
<h3 id="动物、植物、无机物"><a href="#动物、植物、无机物" class="headerlink" title="动物、植物、无机物"></a>动物、植物、无机物</h3><h4 id="为什么用户喜欢无须思考的选择"><a href="#为什么用户喜欢无须思考的选择" class="headerlink" title="为什么用户喜欢无须思考的选择"></a>为什么用户喜欢无须思考的选择</h4><p><strong>“点击多少次都没关系，只要每次点击都是无须思考、明确无误的选择。”——Krug 可用性第二定律</strong></p>
<p>如果我们需要一直在网络上进行选择，那么让这些选择变得无须思考是让一个网站容易使用的主要因素。</p>
<hr>
<h3 id="省略不必要的文字"><a href="#省略不必要的文字" class="headerlink" title="省略不必要的文字"></a>省略不必要的文字</h3><h4 id="不要在-Web-上写作的艺术"><a href="#不要在-Web-上写作的艺术" class="headerlink" title="不要在 Web 上写作的艺术"></a>不要在 Web 上写作的艺术</h4><p><strong>“去掉每个页面上一半的文字，然后把剩下的文字再去掉一半。”——Krug 可用性第三定律</strong></p>
<p><strong>省略多余的文字。</strong>有力的文字都很简练。句子里不应该有多余的文字，段落中不应该有多余的句子。同样，画上不应该有多余的线条，机器上不应该有多余的零件。</p>
<hr>
<h3 id="街头指示牌和面包屑"><a href="#街头指示牌和面包屑" class="headerlink" title="街头指示牌和面包屑"></a>街头指示牌和面包屑</h3><h4 id="设计导航"><a href="#设计导航" class="headerlink" title="设计导航"></a>设计导航</h4><p><strong>如果在网站上找不到方向，人们不会使用你的网站。</strong></p>
<p>导航有两个显而易见的用途：<strong>帮助我们找到想要的任何东西</strong>和<strong>告诉我们现身何处</strong>。此外，导航还有以下额外的好处：</p>
<ul>
<li><strong>他给了我们一些固定的感觉。</strong></li>
<li><strong>它告诉我们当前的位置。</strong></li>
<li><strong>它告诉我们如何使用网站。</strong></li>
<li><strong>它给了我们对网站建造者的信心。</strong>在网站上的每一刻，我们都会在头脑中保持一个标杆：这些人知道他们在做什么吗？这是我们决定是否离开，或者以后会不会来的主要考虑因素之一。</li>
</ul>
<hr>
<h3 id="首先要承认，主页不由你控制"><a href="#首先要承认，主页不由你控制" class="headerlink" title="首先要承认，主页不由你控制"></a>首先要承认，主页不由你控制</h3><h4 id="设计主页"><a href="#设计主页" class="headerlink" title="设计主页"></a>设计主页</h4><p>主页要完成的任务：</p>
<ul>
<li><strong>站点的标识（Logo）和使命。</strong>主页要告诉我这是什么网站，它是做什么的。</li>
<li><strong>站点层次。</strong>主页要给出网站提供的服务的概貌——既要包括内容（“我能在这里找到什么？”），也要包括功能（“我能做什么？”）——还有这些服务是如何组织的。</li>
<li><strong>搜索。</strong></li>
<li><strong>导读。</strong></li>
<li><strong>内容更新。</strong>时常更新的内容让用户觉得这个网站并不是一成不变的。</li>
<li><strong>友情链接。</strong>需要在主页上预留空间，用来放置广告，交叉推广，合作品牌的友情链接等。</li>
<li><strong>快捷方式。</strong></li>
<li><strong>注册。</strong></li>
</ul>
<p>主页需要满足一些抽象的目标：</p>
<ul>
<li><strong>让我看到自己正在寻找的东西。</strong></li>
<li><strong>··· ··· 还有我没有寻找的。</strong></li>
<li><strong>告诉我从哪里开始。</strong></li>
<li><strong>建立可信度和信任感。</strong></li>
</ul>
<hr>
<h3 id="农场主和牧牛人应该是朋友"><a href="#农场主和牧牛人应该是朋友" class="headerlink" title="农场主和牧牛人应该是朋友"></a>农场主和牧牛人应该是朋友</h3><h4 id="为什么-Web-设计团队讨论可用性是在浪费时间，如何避免这种情况"><a href="#为什么-Web-设计团队讨论可用性是在浪费时间，如何避免这种情况" class="headerlink" title="为什么 Web 设计团队讨论可用性是在浪费时间，如何避免这种情况"></a>为什么 Web 设计团队讨论可用性是在浪费时间，如何避免这种情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">从个人角度来说，我们喜欢 Flash 动画，因为它们很好玩；我们也可能不喜欢它们，因为要花很长时间下载。我们喜欢每个页面左边的菜单，因为它们看起来很熟悉而且容易使用；我们可能不喜欢它们，因为它们很枯燥乏味。我们真的喜欢有____的网站，或者，我们发现____真是让人痛苦极了。</div></pre></td></tr></table></figure>
<p>在网站日常开发当中，项目人员共同讨论关于某些的设计问题时，很难不讲以上例子所阐述的感觉牵涉进来。结果往往就是一堆人待在房间里面，每个人都有自持主见，不肯让步。<strong>而且，由于这些主张的力量——还有人的天性——自然有一种把这些喜欢或者不喜欢投射到整个 Wen 用户身上的倾向，认为绝大多数的 Web 用户喜欢我们所喜欢的。我们通常认为大部分 Web 用户和我们一样。</strong></p>
<p>争辩人们喜欢什么既浪费时间又消耗团队的精力，而通过<strong>测试</strong>能将讨论对错转移到什么有效、什么无效上，更容易缓和争论，打破僵局。而且，测试会让我们看到用户的动机、理解、反应的不同，从而让我们不会再坚持认为用户的想法和我们的想法一样。</p>
<hr>
<h3 id="一天10美分的可用性测试"><a href="#一天10美分的可用性测试" class="headerlink" title="一天10美分的可用性测试"></a>一天10美分的可用性测试</h3><h4 id="让测试简单——这样你能进行充分的测试"><a href="#让测试简单——这样你能进行充分的测试" class="headerlink" title="让测试简单——这样你能进行充分的测试"></a>让测试简单——这样你能进行充分的测试</h4><p>关于测试的几个重要事实：</p>
<ul>
<li><strong>如果想建立一个优秀的网站，一定要测试。</strong>测试更像是邀请外地的朋友，不可避免地，当你和他们一起四处游玩时，你会看到平时不会注意到的一些情况，因为你对它们太熟悉了。同时，你也意识到有很多你认为想当然的事情，对别人来说却并非如此。</li>
<li><strong>测试一个用户比不做测试好一倍。</strong>测试总是有效果的，哪怕是对错误的用户做一次最糟糕的测试，也会让你看到一些改善网站的重要方面。</li>
<li><strong>在项目中，早点测试一位用户，好过最后测试50位用户。</strong>一旦一个网站投入使用，要改变它就不会那么容易了。有些用户拒绝做出任何变化，因为即使很小的变更也会给他们带来深远的影响，让我们付出无法想象的代价（至少是项目初期所付出的数倍），所以任何在开始时就有助于防止你犯错误的方法都很划算。</li>
<li><strong>人们对招募用户代表的重要性估计过高。</strong></li>
<li><strong>测试的关键不是要证明什么或者反驳什么，而是了解你的判断力。</strong>测试能做的就是给你提供有价值的参考，加上你的经验、专业判断和常识能够让你更容易地在 A 和 B 之间做出更明智——也更自信——的选择。</li>
<li><strong>测试是一个迭代的过程。</strong></li>
<li><strong>没有什么比现场用户的反应更重要的。</strong></li>
</ul>
<h5 id="跳楼大减价的简易可用性测试"><a href="#跳楼大减价的简易可用性测试" class="headerlink" title="跳楼大减价的简易可用性测试"></a>跳楼大减价的简易可用性测试</h5><table>
<thead>
<tr>
<th></th>
<th>传统可用性测试</th>
<th>跳楼大减价的建议可用性测试</th>
</tr>
</thead>
<tbody>
<tr>
<td>每次测试的用户数量</td>
<td>通常需要八个或者更多个用户，因为建立测试的花费不菲</td>
<td>3-4个用户</td>
</tr>
<tr>
<td>招募方式</td>
<td>仔细选择，尽量靠近目标用户</td>
<td>随便找一些人，几乎任何会上网的人都可以</td>
</tr>
<tr>
<td>测试地点</td>
<td>一个可用性实验室，其中包括一个观察室和单向玻璃</td>
<td>任何办公室或会议室</td>
</tr>
<tr>
<td>主导测试</td>
<td>一位有经验的可用性专家</td>
<td>任何相对有耐心的人</td>
</tr>
<tr>
<td>提前计划</td>
<td>需要提前几个星期制定测试计划，预定可用性实验室，并预留招募时间</td>
<td>几乎可以在任何时间进行测试，稍微提前一些做计划即可</td>
</tr>
<tr>
<td>准备工作</td>
<td>起草、讨论并修订测试草案</td>
<td>决定你要展示什么</td>
</tr>
<tr>
<td>测试目标/时间</td>
<td>除非你预算充足，否则会把所有的鸡蛋放在一个篮子里，在网站快要完成的时候做一次测试</td>
<td>在开发过程中持续进行小规模的测试</td>
</tr>
<tr>
<td>成本</td>
<td>5000-15000美元（或者更多）</td>
<td>300美元（50-100美元是给每个用户的补贴），或者更少</td>
</tr>
<tr>
<td>后续工作</td>
<td>一周之后，产生一份20页的报告，然后开发团队朋友来决定怎样修改</td>
<td>开发团队（还有有兴趣的人员）利用当天的午餐时间进行总结</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="可用性是基本礼貌"><a href="#可用性是基本礼貌" class="headerlink" title="可用性是基本礼貌"></a>可用性是基本礼貌</h3><h4 id="为什么你的网站应该让人尊敬"><a href="#为什么你的网站应该让人尊敬" class="headerlink" title="为什么你的网站应该让人尊敬"></a>为什么你的网站应该让人尊敬</h4><p>降低好感的几种方式：</p>
<ul>
<li><strong>隐藏我想要的信息。</strong></li>
<li><strong>因为没有按照你们的方式形式而惩罚我。</strong></li>
<li><strong>向我询问不必要的信息。</strong></li>
<li><strong>敷衍我，欺骗我。</strong></li>
<li><strong>给我设置障碍。</strong></li>
<li><strong>你的网站看上去不专业。</strong></li>
</ul>
<p>提高好感的几种方式</p>
<ul>
<li><strong>知道人们在你的网站上想做什么，并让它们明白简易、清晰明了。</strong></li>
<li><strong>告诉我我想知道的。</strong></li>
<li><strong>尽量减少步骤。</strong></li>
<li><strong>花点心思。</strong></li>
<li><strong>知道我可能有哪些疑问，并且给予解答。</strong></li>
<li><strong>为我提供协助，例如打印友好页面。</strong></li>
<li><strong>容易从错误中恢复。</strong></li>
<li><strong>如有不确定，记得道歉。</strong></li>
</ul>
<hr>
<h3 id="可访问性、级联样式表和你"><a href="#可访问性、级联样式表和你" class="headerlink" title="可访问性、级联样式表和你"></a>可访问性、级联样式表和你</h3><h4 id="正当你觉得已经完成了的时候，一只猫掉了下来，背上捆着涂了奶油的面包"><a href="#正当你觉得已经完成了的时候，一只猫掉了下来，背上捆着涂了奶油的面包" class="headerlink" title="正当你觉得已经完成了的时候，一只猫掉了下来，背上捆着涂了奶油的面包"></a>正当你觉得已经完成了的时候，一只猫掉了下来，背上捆着涂了奶油的面包</h4><p>在页面设计中，可以从下面几个方面有效提高网站的可访问性：</p>
<ul>
<li><strong>为每张图片添加 alt 文本。</strong></li>
<li><strong>让你的表单配合屏幕阅读器。</strong></li>
<li><strong>在每页的最前面增加一个“跳转到主要内容”的链接。</strong></li>
<li><strong>让所有的内容都可以通过键盘访问。</strong></li>
<li><strong>如果没有充分的理由，不要使用 JavaScript。</strong></li>
<li><strong>使用客户端的影像地图。</strong></li>
</ul>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/09/20/BIO-NIO-AIO 三者关系解析/">BIO/NIO/AIO 三者关系解析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-09-20
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在 Java 的 I/O 体系架构中，存在三种截然不同的 I/O 模型，分别为 BIO（Block I/O，阻塞型 I/O）、NIO（New I/O，非阻塞型 I/O）以及 AIO（Asynchronous I/O，异步 I/O）。</p>
<p>下面分析将从基本的术语开始讲解，最后归整讲述不同 I/O 模型的区别。</p>
<hr>
<h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p>同步与异步关注的是<strong>消息通信机制</strong>。</p>
<ul>
<li><strong>同步</strong>是指发送方发出一个 I/O 请求时，在没有得到结果之前，该请求不返回结果。但是一旦请求返回时，就得到了相应的返回值。</li>
<li><strong>异步</strong>是指发送方发出一个 I/O 请求之后，这个请求便立即返回，该请求没有返回结果。直至请求接收方（即被调用者）通过回调的方式来通知发送方，或者发送方主动询问接收方请求结果。</li>
</ul>
<p>举个例子：</p>
<p>晚上我们需要去饭店预定位置，我们会优先打个电话给酒店来预定位置，当我们被告知饭店位置爆满时需要等待时。在同步的通信机制情况下，我们（发送方）只能默默地够保持通话的方式等待饭店（接收方）来通知我们空余位置的结果，不能够做别的事情。</p>
<p>而在异步的通信机制情况下，饭店（接收方）提供了特殊的服务，让我们（发送方）预留手机号码（回调方式），等有位置了可以主动通知你，我们就能够单方面切断通信，等待饭店通过我们预留的手机号码来通知我们，或者我们来主动询问饭店位置的空余情况。</p>
<hr>
<h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>阻塞与非阻塞关注的是<strong>程序在等待调用结果时的状态</strong>。</p>
<ul>
<li><strong>阻塞</strong>是指请求结果返回之前，当前线程会被挂起。请求线程只有在得到结果之后才会返回。此时的线程处于阻塞状态，相当于卡住不动了。</li>
<li><strong>非阻塞</strong>是指请求结果返回之前，当前线程不会被阻塞，可以处理别的任务。</li>
</ul>
<p>同举以上的例子：</p>
<p>当我们打电话给饭店，被告知饭店位置爆满时需要等待时。在阻塞线程的请求方式下，我们（发送方）只能够保持通讯（阻塞），直至饭店（接收方）通知我们空余位置的结果。</p>
<p>而在非阻塞线程的请求方式下，我们（发送方）可以单方面挂掉电话，继续去逛街（非阻塞），直至饭店（接收方）通知我们，亦或者我们主动打电话去询问。</p>
<hr>
<h4 id="同步-异步与阻塞-非阻塞的区别"><a href="#同步-异步与阻塞-非阻塞的区别" class="headerlink" title="同步/异步与阻塞/非阻塞的区别"></a>同步/异步与阻塞/非阻塞的区别</h4><p>在以上的解释当中，同步/异步与阻塞/非阻塞两者之间的关系十分相似，但是它们却存在本质上的区别。</p>
<ul>
<li>同步/异步注重的是<strong>消息的通信机制</strong>，重点在于<strong>消息</strong>本身。</li>
<li>阻塞/非阻塞注重的是<strong>程序在等待调用结果时的状态</strong>，重点在于<strong>程序</strong>本身。</li>
</ul>
<hr>
<h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>BIO（Block I/O）为同步阻塞型 I/O。在服务器端中实现模式为<strong>一个连接一个线程</strong>，即客户端有连接请求时，服务器端就会按需启动一个线程来处理。</p>
<p><img src="http://on83riher.bkt.clouddn.com/BIO.png" alt="BIO"></p>
<p>如果这个连接不做任何事情时，就造成不必要的线程开销，此时可以通过线程池机制来对于空线程进行回收，但是对于线程的创建与销毁等操作，系统所消耗的资源依然很大。</p>
<hr>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>NIO（New I/O）为同步非阻塞型 I/O。在服务器端中实现模式为<strong>一个请求一个线程</strong>，即客户端发送的连接请求都会注册到多路复用器上（Selector），多路复用器轮询到连接有 I/O 请求（Channel）才启动一个线程（Handler）来处理。用户进程也需要时不时地询问 I/O 操作是否就绪。</p>
<p><img src="http://on83riher.bkt.clouddn.com/NIO.png" alt="NIO"></p>
<p>在 NIO 的 I/O 模型上，可以仅通过单线程的方式来处理高并发问题。</p>
<hr>
<h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>AIO（Asynchronous I/O）为异步非阻塞型 I/O。在此种模式下，用户进程只需要发起一个IO操作然后便立即返回，待 I/O 操作真正的完成以后，应用程序会得到I/O操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的 I/O 读写操作，因为真正的 I/O 读取或者写入操作已经由内核完成了。    </p>
<hr>
<p>参考资料：</p>
<p><a href="https://www.zhihu.com/question/19732473" target="_blank" rel="external">怎样理解阻塞非阻塞与同步异步的区别？</a></p>
<p><a href="http://loveshisong.cn/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2016-06-25-%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3BIO-NIO-AIO.html" target="_blank" rel="external">十分钟了解BIO、NIO、AIO</a></p>
<p><a href="http://qindongliang.iteye.com/blog/2018539" target="_blank" rel="external">JAVA 中BIO,NIO,AIO的理解</a></p>
<p><a href="http://blog.csdn.net/liuhaiabc/article/details/64905654" target="_blank" rel="external">对Java BIO、NIO、AIO 学习</a></p>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/3/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    
    
      <a class="next" href="/page/5/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:jianpeng957@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">jianpeng957</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
