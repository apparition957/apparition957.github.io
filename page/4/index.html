<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="沉迷学习无法自拔"/>













  <link rel="alternate" href="/atom.xml" title="APPARITION957">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://apparition957.github.io/page/4/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  
  <script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8bd9b518a8b821a06877823fceed6cab";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>








<meta name="google-site-verification" content="OxwLY0TQSQ2wO159foQs2OK6XTDPDZA_H3N6_pCPnng" />


    <title> APPARITION957 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">APPARITION957</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">APPARITION957</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/11/01/PriorityQueue-源码分析/">PriorityQueue 源码分析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-11-01
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="结构体系"><a href="#结构体系" class="headerlink" title="结构体系"></a>结构体系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div></pre></td></tr></table></figure>
<p><code>PriorityQueue</code>是通过最小堆（？）实现内部元素按一定顺序的队列，也称其为优先队列。从结构体系上看，<code>PriorityQueue</code>是继承自<code>AbstractQueue</code>的，即<code>PriorityQueue</code>实现了基本的队列的操作。但为何<code>PriorityQueue</code>能够实现元素按指定排序存在队列呢，那么我们应该看它的成员变量部分。</p>
<blockquote>
<p>若忘了最大/小堆的概念，可以查看这篇文章<a href="/2017/10/31/堆排序（Heap%20Sort）/">堆排序（Heap Sort）</a></p>
</blockquote>
<h2 id="常量与重要的成员变量"><a href="#常量与重要的成员变量" class="headerlink" title="常量与重要的成员变量"></a>常量与重要的成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 默认容器初始大小</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</div><div class="line"></div><div class="line"><span class="comment">// 容器最大大小</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="comment">// PriorityQueue 真实操作容器(知道最大/小堆性质的，应该不难明白)</span></div><div class="line"><span class="keyword">transient</span> Object[] queue;</div><div class="line"></div><div class="line"><span class="comment">// 记录容器内部实际元素个数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">  * The comparator, or null if priority queue uses elements'</span></div><div class="line"><span class="comment">  * natural ordering.</span></div><div class="line"><span class="comment">  */</span></div><div class="line"><span class="comment">// 上述注释表明comparator若为空时，即使用自然递增的顺序存储元素</span></div><div class="line"><span class="comment">// 那么既然给出了这个comparator，就说明了该comparator可以由用户给定</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</div></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">  	<span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</div><div class="line">  	<span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 关键构造函数，这一步证实了可以由用户传递自定义的comparator来实现自定义顺序容器</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></div><div class="line"><span class="function"><span class="params">                     Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</div><div class="line">  	<span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</div><div class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">  	<span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">  	<span class="keyword">this</span>.comparator = comparator;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="增加操作-——-add"><a href="#增加操作-——-add" class="headerlink" title="增加操作 —— add()"></a>增加操作 —— add()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">  	<span class="keyword">return</span> offer(e);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">      	<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">int</span> i = size;</div><div class="line">  	<span class="comment">// 保证容器能够存储所有元素</span></div><div class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</div><div class="line">      	grow(i + <span class="number">1</span>);</div><div class="line">    size = i + <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</div><div class="line">      	queue[<span class="number">0</span>] = e;</div><div class="line">    <span class="keyword">else</span></div><div class="line">      	<span class="comment">// 实际操作部分</span></div><div class="line">      	siftUp(i, e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关键部分如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这一步就是PriorityQueue的关键部分</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</div><div class="line">  	<span class="comment">// 若comparator不为空，则使用用户给定的comparator，否则则使用元素本身提供的比较器</span></div><div class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</div><div class="line">      	siftUpUsingComparator(k, x);</div><div class="line">    <span class="keyword">else</span></div><div class="line">      	siftUpComparable(k, x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="comment">// comparator为空时调用</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</div><div class="line">  	<span class="comment">// 获取元素本身，并转化为可Comparable类型</span></div><div class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</div><div class="line">  	<span class="comment">// 若k&gt;0，即k未处于根元素位置</span></div><div class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</div><div class="line">      	<span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">      	Object e = queue[parent];</div><div class="line">      	<span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</div><div class="line">       	 	<span class="keyword">break</span>;</div><div class="line">      	queue[k] = e;</div><div class="line">      	k = parent;</div><div class="line">    &#125;</div><div class="line">    queue[k] = key;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="comment">// comparator不为空时调用</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</div><div class="line">      	<span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">      	Object e = queue[parent];</div><div class="line">      	<span class="comment">// 使用用户给定的comparator</span></div><div class="line">      	<span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</div><div class="line">        	<span class="keyword">break</span>;</div><div class="line">      	queue[k] = e;</div><div class="line">      	k = parent;</div><div class="line">    &#125;</div><div class="line">    queue[k] = x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="删除操作-poll"><a href="#删除操作-poll" class="headerlink" title="删除操作 - poll()"></a>删除操作 - poll()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</div><div class="line">      	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> s = --size;</div><div class="line">    modCount++;</div><div class="line">    E result = (E) queue[<span class="number">0</span>];</div><div class="line">    E x = (E) queue[s];</div><div class="line">    queue[s] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</div><div class="line">      	siftDown(<span class="number">0</span>, x);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与add()同理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</div><div class="line">        siftDownUsingComparator(k, x);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        siftDownComparable(k, x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</div><div class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</div><div class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></div><div class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</div><div class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></div><div class="line">        Object c = queue[child];</div><div class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</div><div class="line">            ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</div><div class="line">            c = queue[child = right];</div><div class="line">        <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        queue[k] = c;</div><div class="line">        k = child;</div><div class="line">    &#125;</div><div class="line">    queue[k] = key;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</div><div class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</div><div class="line">        Object c = queue[child];</div><div class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</div><div class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</div><div class="line">            c = queue[child = right];</div><div class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        queue[k] = c;</div><div class="line">        k = child;</div><div class="line">    &#125;</div><div class="line">    queue[k] = x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="查找操作-peek"><a href="#查找操作-peek" class="headerlink" title="查找操作 - peek()"></a>查找操作 - peek()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 时间复杂度O(1)</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line">  	<span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/11/01/《深入理解Java虚拟机》读书笔记 - Java内存分配/">《深入理解Java虚拟机》读书笔记 - Java内存分配</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-11-01
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <blockquote>
<p>此篇为《深入理解Java虚拟机》第二章2.2部分的读书笔记</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对于 Java 程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个 new 操作去写配对的 delete/free 代码，不容易出现内存泄漏和内存溢出问题，由于虚拟机管理内存这一切看起来很美好，不过，也正是因为 Java 程序员将内存控制的权利交给了 Java 虚拟机，一旦出现内存泄漏和溢出问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将是一件异常艰难的工作。</p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间。有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java 虚拟机规范》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示。</p>
<p><div align="center"><br><img src="http://on83riher.bkt.clouddn.com/Java%20%E5%86%85%E5%AD%98%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt=""><br></div></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p><strong>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程执行的字节码的行号指示器。</strong>在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令（类似于操作系统一般），分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。<strong>因此，为了线程切换后能够恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>
<p>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）（因为 Native 所修饰的方法是虚拟机根据当前系统，调用本地应用/库实现的，不归属于任何字节码指令）。<strong>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</strong></p>
<h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p><strong>与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。</strong></p>
<p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。</p>
<p>其中64位长度的 long 和 doule 类型的数据会占用2个局部变量空间（slot），其余的数据类型只占用1个。<strong>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</strong></p>
<p>在 Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p><strong>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong>在虚拟机规范中，对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。与虚拟机栈一样，本地方法栈也会抛出 StackOverflowError 和 OutOfMemoryError 异常。</p>
<h2 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h2><p><strong>对于大多数应用来说，Java 堆（Java Heap）是 Java 虚拟机所管理的内存中最大的一块。Java 堆被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</strong>这一点在 Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。但随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称作“GC 堆”（Garbage Collected Heap）。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等；从内存分配的角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p>
<p>根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p><strong>方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p>
<p>Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或可扩展外，还可以选择不实现垃圾收集。相对来言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如同永生代的名字一样“永远”存在了。</p>
<p><strong>这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收“成绩”比较难令人满意（类似于操作系统中页面的换入换出算法），尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。</strong></p>
<p>根据 Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p><strong>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法等描述信息外，还有一项信息就是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</strong></p>
<p>Java 虚拟机对 Class 文件每一部分（自然也包括常量池）的格式都有严格规定，每一个字节用于存储那种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java 虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p>
<p><strong>运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只有编译器才能产生，也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，类似于 String 类的 intern() 方法。</strong></p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也会被频繁地使用。</p>
<p>在 JDK1.4中新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（ Buffer）的 I/O 方式，<strong>它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 队中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</strong></p>
<p>显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受本机总内存大小以及处理器寻址空间的限制。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/31/Java抽象类与接口/">Java抽象类与接口</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-31
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>抽象类是用来捕捉子类的通用特性的。它不能被实例化，只能被用作子类的超类。可以将抽象类当做是被用来创建继承层级里子类的模板。</p>
<p>接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的所有抽象方法，并需要确保这些方法全部实现，这就像是契约模式一般。接口只是一种形式，接口自身不能做任何事情。</p>
<p>在Java中，一个类只能够继承一个抽象类，但是一个类可以同时实现多个接口。</p>
<h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>从概念上，可知抽象类与接口所设计的目的是不一样的 —— <strong>接口是对动作的抽象，而抽象类是对根源的抽象</strong>。</p>
<p>举个例子而言，在这个世界上存在很多不同的车，跑车、轿车、货车等，那么对于抽象类而言，我们就需要从这些车中提取它们的公共部分，设计出一个更高级别的抽象类——四轮车。</p>
<p>但轿车与货车同为四轮车，但是普遍轿车都存在着自动驾驶功能，如果货车需要自动驾驶功能的话，那么对于接口而言，可以把自动驾驶功能所需的这些方法抽象成接口——自动驾驶。</p>
<h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p>从程序设计中，如何选择抽象类与接口？从我的观点而言，在程序设计中我们需要考虑的是高度抽象化以及程序可扩展性。</p>
<p>因为在Java中只能够继承一个父类，所以定义抽象类的代价比较高。即在程序设计中，需要从自下至上，综合分析所有子类中的共同点，高度抽象化成父类（这里可以联想Object，即使不是抽象类，但它却由始至终贯穿整个java体系）。</p>
<p>但相比于抽象类而言，接口所付出的代价相对的低很多，可扩展性也大大提高了，因为类可以实现多个接口，因此每个接口你只需要将特定的动作抽象到这个接口即可。</p>
<p>举个例子，如<code>LinkedList</code>的继承体系一般。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></div></pre></td></tr></table></figure>
<ul>
<li>抽象类的角度。<code>LinkedList</code>继承自<code>AbstractSequentialList</code>，这说明了<code>LinkedList</code>属于链表这种数据结构的继承体系中，它继承了所有链表的基本操作。</li>
<li>接口的角度。<code>LinkedList</code>实现了<code>Deque</code>接口，这表明了即使是链表，也能够实现双端队列的功能，使程序调用者可以将<code>LinkedList</code>同等视为队列使用。</li>
</ul>
<hr>
<p>参考资料</p>
<p><a href="https://www.zhihu.com/question/20149818/answer/153188511" target="_blank" rel="external">接口和抽象类有什么区别？</a></p>
<p><a href="http://www.importnew.com/12399.html" target="_blank" rel="external">Java抽象类与接口的区别</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/31/Java关键字-final/">Java关键字 - final</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-31
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在Java中，我们可以通过<code>final</code>来表示某个变量、某个方法，甚至是某个类是“不变的”或“无法改变的”。</p>
<h2 id="怎么使用final"><a href="#怎么使用final" class="headerlink" title="怎么使用final"></a>怎么使用final</h2><h3 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h3><p><code>final</code>修饰的变量称之为常量，其主要应用于以下地方：</p>
<ul>
<li>编译器常量，永远不可改变。</li>
<li>运行其初始化时，我们希望它不会被改变。</li>
</ul>
<p>对于编译器常量，它在类加载的过程就已经完成了初始化，所以当类加载完成后是不可改变的。而对于运行时变量，也称为空白<code>final</code>，即代表先声明，后赋值这一过程。</p>
<p>运行时变量可分为基本数据类型与引用数据类型，其中基本数据类型不可变的是内容，而引用数据类型的不可变的是引用，引用所指的对象内容是可变的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String test = <span class="string">"final can't change"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">      	<span class="comment">// 运行期变量，可以根据传递的值来声明不同的常量</span></div><div class="line">        <span class="keyword">this</span>.SIZE = size;</div><div class="line">      	<span class="comment">// 编译器报错，因为test被final修饰，其在编译期间已确定的值，所以不可改变</span></div><div class="line">        <span class="keyword">this</span>.test = <span class="string">"final??"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h3><p>被<code>final</code>修饰的方法都是不能被继承、更改的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"father can't change"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Son().hello();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</div><div class="line">  	<span class="comment">// 编译器报错，因为Father类中的hello()被final修饰，所以子类是不能够重写的</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hhello"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="final参数"><a href="#final参数" class="headerlink" title="final参数"></a>final参数</h3><p>被<code>final</code>修饰的参数都是不可变的，即在函数作用域内，该参数的值都是不可变的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">final</span> String str)</span> </span>&#123;</div><div class="line">	<span class="comment">// 编译出错</span></div><div class="line">  	str = <span class="string">"world"</span>;</div><div class="line">  	System.out.println(str);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h3><p>被<code>final</code>修饰的类是不允许被继承的，所以可视该类为最终类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译出错，Father类不可被继承</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="final能提高性能吗？"><a href="#final能提高性能吗？" class="headerlink" title="final能提高性能吗？"></a>final能提高性能吗？</h2><p>基于<a href="https://www.zhihu.com/question/21762917" target="_blank" rel="external">JVM对于声明为final的局部变量（local var）做了哪些性能优化？</a>与<a href="http://codewenda.com/%E5%9C%A8java%E4%B8%AD%E4%BD%BF%E7%94%A8final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%9A%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E5%90%97%EF%BC%9F/" target="_blank" rel="external">在Java中使用final关键字会提高性能吗？</a>两文，可以归纳总结出<code>final</code>关键字并不会从性能上有很大的提升，甚至可以说是没有。反而要求设计者在程序设计中，不要过分追求性能，需要注重的是代码的可读性与可维护性。</p>
<hr>
<p>参考资料</p>
<p><a href="http://www.cnblogs.com/chenssy/p/3428180.html" target="_blank" rel="external">java提高篇(十五)—–关键字final</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/31/Java关键字-static/">Java关键字 - static</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-31
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在Java中，我们可以通过用<code>static</code>来表示某个字段或者方法为“全局“或者”静态“的意思，当然<code>static</code>也可以修饰代码块。</p>
<h2 id="怎么使用static"><a href="#怎么使用static" class="headerlink" title="怎么使用static"></a>怎么使用static</h2><p><code>static</code>可以用于修饰成员变量和成员方法，我们将其称为静态变量和静态方法，可以直接通过类名进行访问。如下所示：</p>
<ul>
<li>ClassName.propertyName</li>
<li>ClassName.methodName()</li>
</ul>
<p>而<code>static</code>修饰的代码块也称之为静态代码块，当其所属的类被加载时，就会优先先执行这部分代码。</p>
<h3 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h3><p><code>static</code>修饰的变量称之为静态变量，而没有<code>static</code>修饰的变量称之为实例变量。两者的区别在于：</p>
<p>静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问。</p>
<p>但是实例变量则不同，他是伴随着实例的创建而创建，也伴随着实例的消亡而消亡。而且实例变量只能够通过对象进行访问。</p>
<h3 id="static函数"><a href="#static函数" class="headerlink" title="static函数"></a>static函数</h3><p><code>static</code>修饰的方法称之为静态方法，可以直接通过类名对其进行调用。正因为<code>static</code>修饰的函数在类加载的时候就已经存在了，它不依赖于任何实例，所以<code>static</code>方法必须被实现，也就是说它不能够同时与<code>abstract</code>搭配修饰函数。</p>
<p><code>static</code>方法是类中的一种特殊方法，当我们需要这个类下的某个方法完成某个特定的目的而无须将其实例化时，才将这个方法修饰为<code>static</code>。如Math类下的所有方法都是静态<code>static</code>的。</p>
<h3 id="static代码块"><a href="#static代码块" class="headerlink" title="static代码块"></a>static代码块</h3><p><code>static</code>修饰的代码块称之为静态代码块，它会随着类加载的时候一块执行。静态代码块可以放置类中任意地方，且在类加载时，静态代码块按从下到上的顺序依次执行。</p>
<h3 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h3><p><code>static</code>修饰的方法不能够调用非<code>static</code>变量或者非<code>static</code>方法</p>
<p><code>static</code>所修饰的方法是从属于类的，且被由该类实例化出的所有对象所共享。若在<code>static</code>方法中调用了非<code>static</code>变量或非<code>static</code>方法，那么在运行期间，程序则无法确定此时的所调用的非<code>static</code>变量的确切值（因为成员变量的实际值取决于其所属的对象），从而导致程序运行错误。</p>
<h2 id="静态代码块与非静态代码块的初始化顺序"><a href="#静态代码块与非静态代码块的初始化顺序" class="headerlink" title="静态代码块与非静态代码块的初始化顺序"></a>静态代码块与非静态代码块的初始化顺序</h2><p><strong>优先级结论：静态代码块 == 静态变量初始化 &gt; 实例代码块 == 实例变量初始化 &gt; 实例构造器。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> util_test;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"main instance block"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        System.out.println(<span class="string">"main static block"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"main instance constructor"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Son();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"father instance block"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        System.out.println(<span class="string">"father static block"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"father instance constructor"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"son instance block"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        System.out.println(<span class="string">"son static block"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"son instance constructor"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正确的执行顺序如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">main static block</div><div class="line">father static block</div><div class="line">son static block</div><div class="line">father instance block</div><div class="line">father instance constructor</div><div class="line">son instance block</div><div class="line">son instance constructor</div></pre></td></tr></table></figure>
<p>分析上述的代码加载过程。</p>
<ol>
<li>因为<code>main</code>方法在Main类中，所以首先加载Main类，因此会执行Main类中的<code>static</code>代码块。接着执行<code>main</code>方法中的<code>new Son()</code>语句，而此时Son类尚未被加载，因此此时需要加载Son类。在加载Son类的时候，发现Son类是继承自Father类，所以转而去优先加载Father类，所以Father类中的<code>static</code>代码块会被执行，然后再执行Son类中的<code>static代码</code>块。</li>
<li>在所有所需的类加载完毕后，就通过构造器来生成对象。而在生成对象的时候，必须先初始化父类的成员变量以及执行实例代码块。因此先执行Father类中的实例代码块与构造器，最后再执行Son类中实例代码块与构造器。</li>
</ol>
<hr>
<p>参考资料</p>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3799052.html" target="_blank" rel="external">Java中的static关键字解析</a></p>
<p><a href="http://www.cnblogs.com/chenssy/p/3386721.html" target="_blank" rel="external">java提高篇(七)—–关键字static</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/31/堆排序（Heap Sort）/">堆排序（Heap Sort）</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-31
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>堆排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。</p>
<h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p>堆的实现通过构造二叉堆，实为二叉树的一种分支。这种数据结构具有以下性质：</p>
<ul>
<li>任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。</li>
<li>堆总是一个完全二叉树，即除了最底层外，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。</li>
</ul>
<p>将根节点最大的堆叫做最大堆，而将根节点最小的堆叫做最小堆。</p>
<p><img src="http://on83riher.bkt.clouddn.com/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%A0%86.png" alt="图源于维基百科"></p>
<h2 id="堆排序中如何表示堆"><a href="#堆排序中如何表示堆" class="headerlink" title="堆排序中如何表示堆"></a>堆排序中如何表示堆</h2><p>由于<strong>堆总是一个完全二叉树</strong>这一特性，这使得堆可以利用<strong>数组</strong>来表示，如下图所示。</p>
<p><img src="http://on83riher.bkt.clouddn.com/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%88%9D%E5%A7%8B.png" alt=""></p>
<p>对于给定的某个节点的下标i，可以很容易的计算出这个节点的父节点、左右孩子节点的下标：</p>
<ul>
<li><strong>Parent(i) = floor((i - 1) / 2)</strong>，i节点的父节点下标</li>
<li><strong>Left(i) = 2i * 1</strong>，i节点的左子节点下标</li>
<li><strong>Right(i) = 2 * (i - 1)</strong>，i节点的右子节点下标</li>
</ul>
<h2 id="堆排序原理（以最大堆为例）"><a href="#堆排序原理（以最大堆为例）" class="headerlink" title="堆排序原理（以最大堆为例）"></a>堆排序原理（以最大堆为例）</h2><p>堆排序就是把最大堆的堆顶取出，将剩余的堆继续调整为最大堆，再将堆顶的数值取出，不断重复这一过程，直至堆中只剩下一个节点为止。堆中定义以下几种操作：</p>
<ul>
<li><strong>最大堆调整（MaxHeapify）</strong>：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li><strong>创建最大堆（BuildMaxHeap）</strong>：将堆所有数据重新排序</li>
<li><strong>推排序（HeapSort）</strong>：移除在第一个数据的根节点，bin并做最大堆调整的递归运算</li>
</ul>
<h4 id="最大堆调整（MaxHeapify）"><a href="#最大堆调整（MaxHeapify）" class="headerlink" title="最大堆调整（MaxHeapify）"></a>最大堆调整（MaxHeapify）</h4><p>最大堆调整的作用是保持最大堆的性质，是整个算法的核心部分。它内部的算法其实决定了堆到底是最大堆还是最小堆。</p>
<p><img src="http://on83riher.bkt.clouddn.com/MAX_HEAPIFY.png" alt=""></p>
<p>代码部分如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// array代表需要排序的数组部分</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapAdjust</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> largest = index;</div><div class="line">    <span class="comment">// 左右子节点在数组中的位置</span></div><div class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * (index + <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 若左子节点大于父节点</span></div><div class="line">    <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; array[index] &lt; array[left]) &#123;</div><div class="line">        largest = left;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 若右子节点大于父节点</span></div><div class="line">    <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; array[largest] &lt; array[right]) &#123;</div><div class="line">        largest = right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 倘若larget并非指向原节点index时，则证明父节点index小于某个子节点left/right</span></div><div class="line">    <span class="keyword">if</span> (largest != index) &#123;</div><div class="line">        swap(largest, index);</div><div class="line">      	<span class="comment">// 因为largest并非index，所以节点largest的堆结构也发生了变化</span></div><div class="line">        maxHeapAdjust(largest, heapSize);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> tmp = queue[i];</div><div class="line">    queue[i] = queue[j];</div><div class="line">    queue[j] = tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非递归实现版本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapAdjustWhile</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> largest, left, right;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        largest = index;</div><div class="line">        left = <span class="number">2</span> * index + <span class="number">1</span>;</div><div class="line">        right = <span class="number">2</span> * (index + <span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 若左子节点大于父节点</span></div><div class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; queue[index] &lt; queue[left]) &#123;</div><div class="line">          	largest = left;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 若右子节点大于父节点</span></div><div class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; queue[largest] &lt; queue[right]) &#123;</div><div class="line">          	largest = right;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 倘若larget并非指向原节点index时，则证明父节点index小于某个子节点left/right</span></div><div class="line">        <span class="keyword">if</span> (largest != index) &#123;</div><div class="line">          	swap(largest, index);</div><div class="line">          	maxHeapAdjustWhile(largest, heapSize);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          	<span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建最大堆（BuildMaxHeap）"><a href="#创建最大堆（BuildMaxHeap）" class="headerlink" title="创建最大堆（BuildMaxHeap）"></a>创建最大堆（BuildMaxHeap）</h4><p>创建最大堆的作用是将一个数组转换为一个最大堆。倘若堆中有n个元素，那么BuildMaxHeap就从Parent(n)开始（因为Parent(n)的节点刚刚好指向最后一个元素的父节点），从下往上地调用MaxHeapify。</p>
<p><img src="http://on83riher.bkt.clouddn.com/BUILD_MAX_HEAP.png" alt=""></p>
<p>代码结构如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span> heapSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> parent = (heapSize - <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">  	<span class="comment">// 可以参考图思考一下，为什么这样循环递减i</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = parent; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        maxHeapAdjust(i, heapSize);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="推排序（HeapSort）"><a href="#推排序（HeapSort）" class="headerlink" title="推排序（HeapSort）"></a>推排序（HeapSort）</h4><p>堆排序是堆排序算法的接口算法部分，HeapSort先调用BuildMaxHeap将传递来的数组转换为最大堆，然后将最大堆堆顶元素与堆底最后一个元素对换，然后再重新调用MaxHeapify来保证最大堆的性质。</p>
<p><img src="http://on83riher.bkt.clouddn.com/HEAPSORT.png" alt=""></p>
<p>代码结构如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxHeapSort() &#123;</div><div class="line">    <span class="keyword">int</span> heapSize = queue.length;</div><div class="line">    buildMaxHeap(heapSize);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = heapSize - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="comment">// 交换堆顶的最大值放置数组末尾</span></div><div class="line">        swap(<span class="number">0</span>, i);</div><div class="line">        <span class="comment">// 重新整理最大堆，范围缩小至除已排序的节点外</span></div><div class="line">        maxHeapAdjust(<span class="number">0</span>, i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> queue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h2><p>最优时间复杂度为O(nlogn)，最坏时间复杂度O(nlogn)。</p>
<p>总空间复杂度为O(n)，辅助空间复杂度O(1)。</p>
<hr>
<p>参考资料</p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F" target="_blank" rel="external">堆排序</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%A0%86_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="external">堆 (数据结构)</a>)</p>
<p><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="external">常见排序算法 - 堆排序 (Heap Sort)</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/30/Java异常机制分析/">Java异常机制分析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-30
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>异常是指程序在运行期间所发生的错误，如使用了空指针、栈溢出、非法参数等。在程序编写期间，编译器会自动检查代码是否符合规范，并尽可能地帮助程序员将其纠正。但即使是看似正确的代码，也可能会在运行期间抛出一个意想不到的异常。</p>
<p>Java为此提供了异常处理机制，即在程序运行期间，倘若抛出了异常，则可以以适当的方式进行捕获处理，使得程序能够正常的运作下去。</p>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p><img src="http://on83riher.bkt.clouddn.com/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt=""></p>
<p>在Java中所有的异常类都是从<code>java.lang.Throwable</code>类集成的子类。</p>
<p>根类<code>Throwable</code>下（仅）有两个重要的子类——<code>Error</code>与<code>Exception</code>。</p>
<ul>
<li><code>Error</code>代表运行期间JVM（Java虚拟机）出现的异常，这种异常一般来说是无法处理的。</li>
<li><code>Exception</code>代表运行期间程序本身的逻辑出现的异常，这种异常一般是程序本身可以处理的。</li>
</ul>
<p>其中，<code>Exception</code>可分为两类：运行时异常和检查异常。</p>
<ul>
<li>检查异常（CheckedException），是指程序在执行某段代码时，是可以提前知道这段代码是存在潜在异常的，而且<strong>要求程序必须以某种方式来处理</strong>。若不处理这种异常情况时，编译器是不会通过编译的。</li>
</ul>
<ul>
<li>运行时异常（RuntimeException），也称为非检查异常，是指程序在运行期间可能会抛出异常，但不要求程序必须处理该异常。在编译期间，编译器也不会要求用户去处理它。</li>
</ul>
<h2 id="TRY-CATCH会不会性能消耗"><a href="#TRY-CATCH会不会性能消耗" class="headerlink" title="TRY-CATCH会不会性能消耗"></a>TRY-CATCH会不会性能消耗</h2><p>当初的自己觉得如果在<code>try-catch</code>块中大量使用循环的话，想当然的认为会消耗大量的性能。但是通过阅读多篇文章后，得出以下结论：</p>
<ul>
<li>异常如果没发生，也就不会去查异常表，也就是说你写不写<code>try-catch</code>，也就是有没有这个异常表的问题，如果没有发生异常，写<code>try-catch</code>对性能是木有消耗的，所以不会让程序跑得更慢。</li>
<li><code>try-catch</code> 的范围大小其实就是异常表中两个值（开始地址和结束地址）的差异而已，也是不会影响性能的。</li>
</ul>
<p>具体文章如下所示：</p>
<p><a href="http://www.cnblogs.com/isline/archive/2010/04/22/1717837.html" target="_blank" rel="external">Try-Catch真的会影响程序性能吗</a></p>
<p><a href="http://blog.csdn.net/tao_zi7890/article/details/17584813" target="_blank" rel="external">Java上的try catch并不影响性能（转）</a></p>
<h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><p>优化建议这一部分是结合了<a href="http://www.cnblogs.com/dolphin0520/p/3769804.html" target="_blank" rel="external">Java异常处理和设计</a>和<a href="https://www.oschina.net/question/12_37141" target="_blank" rel="external">异常处理的 15 个处理原则</a>两文的精华，小弟只能做个低调的搬运工。</p>
<ul>
<li>只在必要使用异常的地方才使用异常，不要用异常去控制程序的流程</li>
</ul>
<p>即使在上述的说到异常机制不会怎么消耗性能，但这并不代表能够在程序中随处使用<code>try-catch</code>。要在程序中谨慎地使用异常，倘若异常使用过多仍然会很大程度上影响程序的性能。如果在程序中能够用<code>if</code>语句来进行逻辑判断，自然能更清楚地表明出当某个字段处于某个阶段时要进行的逻辑，也可以减少异常的使用，从而避免不必要的异常捕获和处理。</p>
<ul>
<li>切忌使用空<code>catch</code>块</li>
</ul>
<p>倘若程序在捕获了异常之后什么都不做，相当于你直接隐藏了这个异常，这可能会导致后面的程序逻辑出现不可控的执行结果，这是一种相当不负责任的行为。倘若有这种情况发生，不如改变程序本身的代码逻辑，使其变得更加健壮，并用日志的方式记录其异常的状态，方便日后的更新和维护。</p>
<ul>
<li>检查异常与非检查异常的选择</li>
</ul>
<p>当你决定要抛出一个自己新定义的异常，你就要决定以什么形式来处理这个异常。</p>
<p>当有些检查异常对开发人员来说是无法通过合理的手段处理的，例如<code>SQLException</code>，这样就会导致在代码中经常出现的一种情况：逻辑代码很少几行，但是要进行异常捕获和异常处理的代码却有很多行，这会导致逻辑代码阅读起来晦涩难懂，使得代码难以维护。</p>
<p>在检查异常与非检查异常的选择上面，如果存在该异常情况的出现很普遍，需要特别提醒调用者注意处理的话，就是用检查异常，否则就使用非检查异常。</p>
<ul>
<li>注意<code>catch</code>块的顺序</li>
</ul>
<p>切忌将捕获父类异常的<code>catch</code>块放置于捕获子类异常<code>catch</code>块前，否则将永远无法到达程序理想的异常处理逻辑状态中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"d:/a.txt"</span>);</div><div class="line">    <span class="keyword">int</span> ch = inputStream.read();</div><div class="line">    System.out.println(<span class="string">"aaa"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="string">"step1"</span>;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    System.out.println(<span class="string">"io exception"</span>);　　      </div><div class="line">    <span class="keyword">return</span> <span class="string">"step2"</span>;</div><div class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">  	<span class="comment">// 永远到不了这一步，因为catch块是从上到下优先匹配到符合该异常类及其父类</span></div><div class="line">  	<span class="comment">// 由于Exception为FileNotFoundException的父类，所以catch块将在第一次匹配中结束</span></div><div class="line">    System.out.println(<span class="string">"file not found"</span>);　　　　      </div><div class="line">    <span class="keyword">return</span> <span class="string">"step3"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>避免多次在日志信息中记录同一异常</li>
</ul>
<p>很多情况下异常都是层层向上抛出，如果在每次向上抛出异常的时候，都记录到日志中，则会导致冗余的异常重复记录在日志中，不仅大量浪费空间，而且很难查找到异常的根源。</p>
<p>妥当的做法是只在异常最开始发生的地方进行日志信息记录。</p>
<ul>
<li>在<code>finally</code>中释放资源</li>
</ul>
<p>如果在程序中存在文件读取、网络操作以及数据库操作等，需要在<code>finally</code>块中释放资源。这样不仅使得程序占用的资源更少，也会避免由于资源未及时释放而导致的异常情况。</p>
<ul>
<li>不要在<code>finally</code>中使用<code>return</code>语句</li>
</ul>
<p>倘若在正常<code>try</code>块中返回值，又或者是，在捕获异常后打算在<code>catch</code>块中返回值的话，切忌在<code>finally</code>块中再返回值，否则<code>finally</code>的返回值将直接取代<code>catch</code>块中的返回值。这不难想象，因为<code>finally</code>块在<code>try-catch</code>执行完后一定会执行的，所以<code>finally</code>中的操作将会正常执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"d:/a.txt"</span>);</div><div class="line">    <span class="keyword">int</span> ch = inputStream.read();</div><div class="line">    System.out.println(<span class="string">"aaa"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="string">"step1"</span>;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    System.out.println(<span class="string">"io exception"</span>);　　      </div><div class="line">    <span class="keyword">return</span> <span class="string">"step2"</span>;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  	System.out.println(<span class="string">"finally end"</span>);　</div><div class="line">  	<span class="comment">// 程序执行到这，会导致最终的返回值是"step3"，而非"step1"，也不会是"step1"</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"step3"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当方法判断出错该返回时应该抛出异常，而不是返回一些错误值</li>
</ul>
<p>因为错误值在程序逻辑中可能会出现难以理解的情况，并且错误值在描述异常的情况并不直观。在文件找不到的时候，应当抛出类似 FileNotFoundException 异常，而不是返回 -1 或者 -2 之类的错误值。</p>
<hr>
<p>参考资料</p>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3769804.html" target="_blank" rel="external">Java异常处理和设计</a></p>
<p><a href="https://www.oschina.net/question/12_37141" target="_blank" rel="external">异常处理的 15 个处理原则</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/29/ArrayList与LinkedList的循环效率对比/">ArrayList与LinkedList的循环效率对比</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-29
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p><code>for</code>循环遍历存在这两种方式，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++);</div><div class="line"><span class="keyword">for</span> (Object object: objects);</div></pre></td></tr></table></figure>
<p><code>ArrayList</code>与<code>LinkedList</code>两种集合在两种方式的遍历存在着较大的性能差距，下面将以以下测试代码作为范例解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_SIZE = <span class="number">2000000</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testList</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</div><div class="line">            list.get(i);</div><div class="line">        &#125;</div><div class="line">        System.out.println(list.getClass().getSimpleName() + <span class="string">"-普通for-花费时间: "</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</div><div class="line"></div><div class="line">        start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (Integer num: list) &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        System.out.println(list.getClass().getSimpleName() + <span class="string">"-foreach-花费时间: "</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; arrayNums = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        List&lt;Integer&gt; linkNums = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_SIZE; i++) &#123;</div><div class="line">            arrayNums.add(i);</div><div class="line">            linkNums.add(i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        testList(arrayNums);</div><div class="line">        testList(linkNums);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试运行结果可得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ArrayList-普通for-花费时间: 5ms</div><div class="line">ArrayList-foreach-花费时间: 7ms</div><div class="line">LinkedList-普通for-花费时间: 32459ms</div><div class="line">LinkedList-foreach-花费时间: 9ms</div></pre></td></tr></table></figure>
<p>从上述的结果中，可以看出<code>ArrayList</code>在普通for循环上更胜一筹，而在LinkedList在foreach上效率极高。倘若数据量不断上升，那么这个差距只会不断加大。</p>
<p>那么为什么会造成上述情况发生呢？</p>
<h2 id="问题解释"><a href="#问题解释" class="headerlink" title="问题解释"></a>问题解释</h2><p>问题可以从两者的结构体系上分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></div><div class="line"><span class="class">        </span></div><div class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></div></pre></td></tr></table></figure>
<p>在两者对比中，我们可以发现<code>ArrayList</code>中实现了<code>RandomAccess</code>接口，而<code>LinkedList</code>没有实现。仔细查看RandomAccess的注释解释，如果实现该接口的<code>List</code>，在普通for循环遍历的效率上会快于foreach循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Marker interface used by &lt;tt&gt;List&lt;/tt&gt; implementations to indicate that</span></div><div class="line"><span class="comment"> * they support fast (generally constant time) random access.  The primary</span></div><div class="line"><span class="comment"> * purpose of this interface is to allow generic algorithms to alter their</span></div><div class="line"><span class="comment"> * behavior to provide good performance when applied to either random or</span></div><div class="line"><span class="comment"> * sequential access lists.</span></div><div class="line"><span class="comment"> * List实现所使用的标记接口，用来表明实现了这个接口的list支持快速随机访问(通常在常数时</span></div><div class="line"><span class="comment"> * 间内)。这个接口主要目的在于允许一般的算法更改它们的行为，以便在随机或者顺序访问list</span></div><div class="line"><span class="comment"> * 时有更好的性能。</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;p&gt;The best algorithms for manipulating random access lists (such as</span></div><div class="line"><span class="comment"> * &lt;tt&gt;ArrayList&lt;/tt&gt;) can produce quadratic behavior when applied to</span></div><div class="line"><span class="comment"> * sequential access lists (such as &lt;tt&gt;LinkedList&lt;/tt&gt;).  Generic list</span></div><div class="line"><span class="comment"> * algorithms are encouraged to check whether the given list is an</span></div><div class="line"><span class="comment"> * &lt;tt&gt;instanceof&lt;/tt&gt; this interface before applying an algorithm that would</span></div><div class="line"><span class="comment"> * provide poor performance if it were applied to a sequential access list,</span></div><div class="line"><span class="comment"> * and to alter their behavior if necessary to guarantee acceptable</span></div><div class="line"><span class="comment"> * performance.</span></div><div class="line"><span class="comment"> * 操作随机访问列表(如ArrayList)的最佳算法在顺序访问列表(如LinkedList)上应用，会产</span></div><div class="line"><span class="comment"> * 生歧义行为。泛型列表的算法鼓励在将某个算法应用于顺序访问列表可能产生较差的性能之前，</span></div><div class="line"><span class="comment"> * 检查给定的列表是不是这个接口的实现，并在有必要的时候修改它们的行为，以保证提供可接受</span></div><div class="line"><span class="comment"> * 的性能。</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;p&gt;It is recognized that the distinction between random and sequential</span></div><div class="line"><span class="comment"> * access is often fuzzy.  For example, some &lt;tt&gt;List&lt;/tt&gt; implementations</span></div><div class="line"><span class="comment"> * provide asymptotically linear access times if they get huge, but constant</span></div><div class="line"><span class="comment"> * access times in practice.  Such a &lt;tt&gt;List&lt;/tt&gt; implementation</span></div><div class="line"><span class="comment"> * should generally implement this interface.  As a rule of thumb, a</span></div><div class="line"><span class="comment"> * &lt;tt&gt;List&lt;/tt&gt; implementation should implement this interface if,</span></div><div class="line"><span class="comment"> * for typical instances of the class, this loop:</span></div><div class="line"><span class="comment"> * 在界定随机访问与顺序访问的界限一般都是模糊不清的。例如，某些列表在它们拥有大量的数据</span></div><div class="line"><span class="comment"> * 时提供非线性访问时间，但实际上是常量级别的访问时间。这样的接口应该实现该接口。</span></div><div class="line"><span class="comment"> * &lt;pre&gt;</span></div><div class="line"><span class="comment"> *     for (int i=0, n=list.size(); i &amp;lt; n; i++)</span></div><div class="line"><span class="comment"> *         list.get(i);</span></div><div class="line"><span class="comment"> * &lt;/pre&gt;</span></div><div class="line"><span class="comment"> * runs faster than this loop:</span></div><div class="line"><span class="comment"> * 比下面的循环运行速度更快。</span></div><div class="line"><span class="comment"> * &lt;pre&gt;</span></div><div class="line"><span class="comment"> *     for (Iterator i=list.iterator(); i.hasNext(); )</span></div><div class="line"><span class="comment"> *         i.next();</span></div><div class="line"><span class="comment"> * &lt;/pre&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomAccess</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>参考资料</p>
<p><a href="http://www.jianshu.com/p/d5ec2ff72b33" target="_blank" rel="external">Java集合干货系列-（二）LinkedList源码解析</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/29/LinkedList 源码分析/">LinkedList 源码分析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-29
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="结构体系"><a href="#结构体系" class="headerlink" title="结构体系"></a>结构体系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></div></pre></td></tr></table></figure>
<p><code>LinkedList</code>继承自<code>AbstractSequentialList</code>，并同时实现了<code>List</code>、<code>Deque</code>、<code>Cloneable</code>与<code>Serializable</code>接口。从继承体系上与接口上，可以看出<code>LinkedList</code>不仅仅是<strong>双向链表</strong>而已，它可以同时被当做<strong>双向队列</strong>进行操作。</p>
<p>为什么是双向链表呢？后面一小节将会解释。</p>
<h2 id="常量与重要成员"><a href="#常量与重要成员" class="headerlink" title="常量与重要成员"></a>常量与重要成员</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 记录链表上实际装载的节点个数</span></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"><span class="comment">// 指向链表头部的指针</span></div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</div><div class="line"><span class="comment">// 指向链表尾部的指针</span></div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</div></pre></td></tr></table></figure>
<p>在成员变量中，我们可以看到链表所承载的节点是<code>Node</code>，下面看看<code>Node</code>是怎么构成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    E item; <span class="comment">// 节点上承载的值</span></div><div class="line">    Node&lt;E&gt; next; <span class="comment">// 指向前一个节点</span></div><div class="line">    Node&lt;E&gt; prev; <span class="comment">// 指向后一个节点</span></div><div class="line"></div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.item = element;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">        <span class="keyword">this</span>.prev = prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从<code>Node</code>中，不难看出<code>LinkedList</code>就是一个双向链表的集合，如下所示。</p>
<p><img src="http://on83riher.bkt.clouddn.com/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt=""></p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>();</div><div class="line">    addAll(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LinkedList</code>的构造函数可以说是很简约了，毕竟内部不像<code>ArrayList</code>里面还有个数组作支撑，只需头/尾指针即可。</p>
<h2 id="基本操作-node"><a href="#基本操作-node" class="headerlink" title="基本操作 - node()"></a>基本操作 - node()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在LinkedList中，在某些需要在指定节点中进行操作的时候，是怎么通过索引下标的形式找到指定节点的呢</span></div><div class="line"><span class="comment">// LinkedList内部提供了node()方法来实现这一目标。顺便一提node()内部充分使用了头尾节点的好处，将遍历范围缩减到size/2内</span></div><div class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert isElementIndex(index);</span></div><div class="line">	</div><div class="line">  	<span class="comment">// 若index &gt; size/2</span></div><div class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="添加操作-add"><a href="#添加操作-add" class="headerlink" title="添加操作 - add()"></a>添加操作 - add()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    linkLast(e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    checkPositionIndex(index);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (index == size)</div><div class="line">      linkLast(element);</div><div class="line">    <span class="keyword">else</span></div><div class="line">      linkBefore(element, node(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的<code>add()</code>方法均调用了<code>link*（）</code>字样的方法，其实这是<code>LinkedList</code>内部用于对链表的中<strong>单个节点</strong>的操作。相对应的<code>remove()</code>方法也会调用<code>unlink*()</code>字样的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 作为头节点链接到链表中</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</div><div class="line">    first = newNode;</div><div class="line">  	<span class="comment">// 若f为null, 则表明链表为空</span></div><div class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</div><div class="line">        last = newNode;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        f.prev = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 作为尾节点链接到链表中</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</div><div class="line">    last = newNode;</div><div class="line">  	<span class="comment">// 若l为null, 则表明链表为空</span></div><div class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</div><div class="line">        first = newNode;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        l.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将新节点插在指定节点前</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert succ != null;</span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</div><div class="line">    succ.prev = newNode;</div><div class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</div><div class="line">        first = newNode;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        pred.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LinkedList</code>也提供了将一组数据添加入链表中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">  	<span class="comment">// 默认从尾节点后插入</span></div><div class="line">  	<span class="keyword">return</span> addAll(size, c);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    checkPositionIndex(index);</div><div class="line"></div><div class="line">    Object[] a = c.toArray();</div><div class="line">    <span class="keyword">int</span> numNew = a.length;</div><div class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    Node&lt;E&gt; pred, succ;</div><div class="line">  	<span class="comment">// 若指定位置就是尾节点时</span></div><div class="line">    <span class="keyword">if</span> (index == size) &#123;</div><div class="line">      succ = <span class="keyword">null</span>;</div><div class="line">      pred = last;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      succ = node(index);</div><div class="line">      pred = succ.prev;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (Object o : a) &#123;</div><div class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</div><div class="line">      Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</div><div class="line">      <span class="comment">// 确保头节点始终不为空</span></div><div class="line">      <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</div><div class="line">      	first = newNode;</div><div class="line">      <span class="keyword">else</span></div><div class="line">        pred.next = newNode;</div><div class="line">      pred = newNode;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  	<span class="comment">// 确保尾节点不为空</span></div><div class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</div><div class="line">      last = pred;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      pred.next = succ;</div><div class="line">      succ.prev = pred;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    size += numNew;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="删除操作-remove"><a href="#删除操作-remove" class="headerlink" title="删除操作 - remove()"></a>删除操作 - remove()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> removeFirst();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    checkElementIndex(index);</div><div class="line">    <span class="keyword">return</span> unlink(node(index));</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</div><div class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    <span class="keyword">return</span> unlinkFirst(f);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">	<span class="keyword">if</span> (l == <span class="keyword">null</span>)</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">	<span class="keyword">return</span> unlinkLast(l);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>remove()</code>如同<code>add()</code>一样，使用着功能截然相反的<code>unlink*()</code>方法，但逻辑处理难度上较大与<code>link*()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 删除非空头节点</span></div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></div><div class="line">    <span class="keyword">final</span> E element = f.item;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</div><div class="line">    f.item = <span class="keyword">null</span>;</div><div class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// 方便GC进行垃圾回收</span></div><div class="line">    first = next;</div><div class="line">  	<span class="comment">// 若链表中只有单个节点</span></div><div class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</div><div class="line">        last = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        next.prev = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 删除非空尾节点</span></div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></div><div class="line">    <span class="keyword">final</span> E element = l.item;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</div><div class="line">    l.item = <span class="keyword">null</span>;</div><div class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// 方便GC进行垃圾回收</span></div><div class="line">    last = prev;</div><div class="line">  	<span class="comment">// 若链表中只有单个节点</span></div><div class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</div><div class="line">        first = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        prev.next = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 删除指定节点</span></div><div class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert x != null;</span></div><div class="line">    <span class="keyword">final</span> E element = x.item;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</div><div class="line"></div><div class="line">  	<span class="comment">// 若prev指向的上一个节点为空，那么该节点为头节点</span></div><div class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</div><div class="line">        first = next;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        prev.next = next;</div><div class="line">        x.prev = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  	<span class="comment">// 若next指向的下一个节点为空，那么该节点为尾节点</span></div><div class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</div><div class="line">        last = prev;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        next.prev = prev;</div><div class="line">        x.next = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    x.item = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>remove()</code>操作中还提供了根据给定值删除指定节点的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="comment">// 若给定值为null</span></div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">    	<span class="comment">// 在这里就不能缩减范围提高效率了，只能老实的进行从头遍历到尾</span></div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</div><div class="line">              	unlink(x);</div><div class="line">              	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</div><div class="line">              	unlink(x);</div><div class="line">              	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="查询操作-get"><a href="#查询操作-get" class="headerlink" title="查询操作 - get()"></a>查询操作 - get()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    checkElementIndex(index);</div><div class="line">    <span class="keyword">return</span> node(index).item;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">	<span class="keyword">if</span> (f == <span class="keyword">null</span>)</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">	<span class="keyword">return</span> f.item;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">	<span class="keyword">if</span> (l == <span class="keyword">null</span>)</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">	<span class="keyword">return</span> l.item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="修改操作-set"><a href="#修改操作-set" class="headerlink" title="修改操作 - set()"></a>修改操作 - set()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    checkElementIndex(index);</div><div class="line">    Node&lt;E&gt; x = node(index);</div><div class="line">    E oldVal = x.item;</div><div class="line">    x.item = element;</div><div class="line">    <span class="keyword">return</span> oldVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实现了Deque接口的相关操作"><a href="#实现了Deque接口的相关操作" class="headerlink" title="实现了Deque接口的相关操作"></a>实现了Deque接口的相关操作</h2><p>别忘了，LinkedList实现了Deque接口，这说明操作LinkedList也可以像操作双向队列一样。如同<code>*first()</code>以及<code>*last()</code>这种操作也属于Deque要求实现的，下面将列出别的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">	<span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/10/28/Map-Entry 使用解析/">Map.Entry 使用解析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-28
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><code>Map.Entry</code>是<code>Map</code>声明的一个内部接口，此接口为泛型，定义为<code>Entry&lt;K,V&gt;</code>。它可用于 表示Map中的一个键值对。</p>
<p>在<code>Map</code>提供的<code>EntrySet()</code>返回的是<code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code>，是一个<code>Set</code>集合，刺激和类型是<code>Map.Entry</code>。相较于<code>Map</code>所提供的另一个方法<code>keySet()</code>，它所提供的以<code>key</code>值为数据的<code>Set</code>集合。</p>
<h2 id="使用以及对比"><a href="#使用以及对比" class="headerlink" title="使用以及对比"></a>使用以及对比</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// keySet()循环遍历</span></div><div class="line"><span class="keyword">for</span> (Object key: map.keySet()) &#123;</div><div class="line">    Object key = key;</div><div class="line">  	Object value = map.get(key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// entrySet()循环遍历</span></div><div class="line"><span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry: map.entrySet()) &#123;</div><div class="line">    Object = entry.getKey();</div><div class="line">  	Object = entry.getValue();</div><div class="line">  	<span class="comment">// entry.setValue()</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上两种方式中，相较于<code>keySet()</code>遍历<code>Map</code>，<code>entrySet()</code>能够更加清晰的显示<code>Map</code>内部的数据结构，同时<code>entrySet()</code>提供了用于修改<code>Map</code>的值。</p>
<hr>
<p>参考链接</p>
<p><a href="http://www.cnblogs.com/ningvsban/archive/2013/05/06/3062217.html" target="_blank" rel="external">Map.Entry使用详解</a></p>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/3/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    
    
      <a class="next" href="/page/5/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:jianpeng957@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">jianpeng957</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
