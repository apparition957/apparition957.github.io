<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>APPARITION957</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://apparition957.github.io/"/>
  <updated>2018-12-06T12:41:49.000Z</updated>
  <id>http://apparition957.github.io/</id>
  
  <author>
    <name>jianpeng957</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>八日漫游大西环线</title>
    <link href="http://apparition957.github.io/2018/12/06/%E5%85%AB%E6%97%A5%E6%BC%AB%E6%B8%B8%E5%A4%A7%E8%A5%BF%E7%8E%AF%E7%BA%BF/"/>
    <id>http://apparition957.github.io/2018/12/06/八日漫游大西环线/</id>
    <published>2018-12-06T11:27:01.000Z</published>
    <updated>2018-12-06T12:41:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>这次旅行可以认为是一场说走就走的旅行，缘起于朋友的一次不经意的漫谈，到最终构思出大致的计划不过两日，我俩就踏上了旅程，途中边走边规划，要去哪吃，要去哪玩。</p><blockquote><p>这篇记录主要以风景照为主，美食的话没有拍，味道全留在肚子里了。</p></blockquote><h2 id="第一日：成都-兰州"><a href="#第一日：成都-兰州" class="headerlink" title="第一日：成都-兰州"></a>第一日：成都-兰州</h2><p>出发前一天，看到凌晨的机票十分便宜便立马下手，本以为捡到了大便宜，但是成都突如其来的大雾天气导致我们的航班延误了整整5个小时。在等待期间，别的航空公司的飞机由于机型缘故可以在较恶劣的条件下起飞，所以我们只能在同一个登机口眼巴巴地看着他们欢快的登机。</p><blockquote><p>切勿贪小便宜乘坐廉价航空或者机型较小的飞机！</p></blockquote><p><img src="/2018/12/06/八日漫游大西环线/IMG_8018.JPG" alt=""></p><p>到达兰州的时候已经中午12点半了，我们拿着行李就跑去乘坐机场大巴赶去下榻酒店。中川机场到市中心的距离长达68公里之远，所以一般都不会考虑打车去市中心，而是选择两条路线：到隔壁的中川机场高铁站乘坐高铁或者乘坐机场大巴，两条路线的价格和花费时间都相差不多。</p><p>匆忙放完行李后，我们早已肚子饿的不得了，便到楼下的兰州拉面点上了两碗心心念念的牛肉面。</p><p><img src="/2018/12/06/八日漫游大西环线/IMG_8036.JPG" alt=""></p><p>在兰州安排的第一个必游的景点是甘肃省博物馆，主要目的还是奔着镇馆之宝——马踏飞燕走的。但是不得不说，逛完博物馆后整个人都虚脱了，只能回酒店暂作休息。迷迷糊糊睡了会儿，便起身去看看兰州夜景。</p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_17.jpg" alt=""></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_26.jpg" alt=""></p><h2 id="第二日：兰州-西宁"><a href="#第二日：兰州-西宁" class="headerlink" title="第二日：兰州-西宁"></a>第二日：兰州-西宁</h2><p>由于今日的我们没有安排过多的行程，便睡了个回笼觉，睡醒便已经10点钟了。早上我们只安排了一个景点——白塔山公园，虽说是公园，其实就有点像深圳的莲花山公园，还是有点山路的，况且我们还是拿着全副行李，但是想到能够俯瞰兰州全貌，便咬咬牙爬了上去。</p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_2d.jpg" alt=""></p><p>从公园下来已经接近中午，吃了最后一顿美味的牛肉面后又马不停蹄的赶往兰州西站，乘坐高铁前往西宁。在西宁游玩时，给我印象最深的便是较近晚上时前去的东关清真大寺，印象深的并不是里面的建筑，而是里面的穆斯林老人，他们见到你时，会先递给你一张小纸片，上面记录着伊斯兰教中最重要的几句话，然后会十分热情地跟你述说了伊斯兰教的由来、信仰伊斯兰教与其他宗教的不同等等。从我的直觉上看，倘若我们不刻意打断他们（虽然很不礼貌），他们能讲上一整天。</p><h2 id="第三日：西宁-塔尔寺-青海湖"><a href="#第三日：西宁-塔尔寺-青海湖" class="headerlink" title="第三日：西宁-塔尔寺-青海湖"></a>第三日：西宁-塔尔寺-青海湖</h2><p>尽管昨日有过短暂的休息，但是还是忍不住今早早起的哈欠。我们与昨日联系好的小马哥（本次旅行的司机）约好九点半在酒店楼下集合，这一次同行的包括司机在内总共有七人（四男三女），出乎意料的是主要都来自广东。</p><p>后面的文字记录，我就不过多描述旅途中的辛酸了，主要还是以风景为重点进行记录。</p><h3 id="路途风景"><a href="#路途风景" class="headerlink" title="路途风景"></a>路途风景</h3><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_52.jpg" alt="UNADJUSTEDNONRAW_thumb_52"></p><h3 id="塔尔寺"><a href="#塔尔寺" class="headerlink" title="塔尔寺"></a>塔尔寺</h3><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_40.jpg" alt="UNADJUSTEDNONRAW_thumb_40"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_43.jpg" alt="UNADJUSTEDNONRAW_thumb_43"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_46.jpg" alt="UNADJUSTEDNONRAW_thumb_46"></p><h3 id="青海湖"><a href="#青海湖" class="headerlink" title="青海湖"></a>青海湖</h3><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_5a.jpg" alt="UNADJUSTEDNONRAW_thumb_5a"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_5f.jpg" alt="UNADJUSTEDNONRAW_thumb_5f"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_6a.jpg" alt="UNADJUSTEDNONRAW_thumb_6a"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_57.jpg" alt="UNADJUSTEDNONRAW_thumb_57"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_63.jpg" alt="UNADJUSTEDNONRAW_thumb_63"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_65.jpg" alt="UNADJUSTEDNONRAW_thumb_65"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_68.jpg" alt="UNADJUSTEDNONRAW_thumb_68"></p><h2 id="第四日：茶卡盐湖-翡翠湖-柴达木盆地"><a href="#第四日：茶卡盐湖-翡翠湖-柴达木盆地" class="headerlink" title="第四日：茶卡盐湖-翡翠湖-柴达木盆地"></a>第四日：茶卡盐湖-翡翠湖-柴达木盆地</h2><h3 id="清晨的茶卡镇"><a href="#清晨的茶卡镇" class="headerlink" title="清晨的茶卡镇"></a>清晨的茶卡镇</h3><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_6c.jpg" alt="UNADJUSTEDNONRAW_thumb_6c"></p><h3 id="茶卡盐湖"><a href="#茶卡盐湖" class="headerlink" title="茶卡盐湖"></a>茶卡盐湖</h3><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_7e.jpg" alt="UNADJUSTEDNONRAW_thumb_7e"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_75.jpg" alt="UNADJUSTEDNONRAW_thumb_75"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_79.jpg" alt="UNADJUSTEDNONRAW_thumb_79"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_86.jpg" alt="UNADJUSTEDNONRAW_thumb_86"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_7f.jpg" alt="UNADJUSTEDNONRAW_thumb_7f"></p><h3 id="翡翠湖"><a href="#翡翠湖" class="headerlink" title="翡翠湖"></a>翡翠湖</h3><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_93.jpg" alt="UNADJUSTEDNONRAW_thumb_93"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_96.jpg" alt="UNADJUSTEDNONRAW_thumb_96"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_a0.jpg" alt="UNADJUSTEDNONRAW_thumb_a0"></p><h2 id="第五日：雅丹魔鬼城-敦煌"><a href="#第五日：雅丹魔鬼城-敦煌" class="headerlink" title="第五日：雅丹魔鬼城-敦煌"></a>第五日：雅丹魔鬼城-敦煌</h2><h3 id="雅丹魔鬼城"><a href="#雅丹魔鬼城" class="headerlink" title="雅丹魔鬼城"></a>雅丹魔鬼城</h3><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_ac.jpg" alt="UNADJUSTEDNONRAW_thumb_ac"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_ae.jpg" alt="UNADJUSTEDNONRAW_thumb_ae"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_b1.jpg" alt="UNADJUSTEDNONRAW_thumb_b1"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_b2.jpg" alt="UNADJUSTEDNONRAW_thumb_b2"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_b4.jpg" alt="UNADJUSTEDNONRAW_thumb_b4"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_b5.jpg" alt="UNADJUSTEDNONRAW_thumb_b5"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_b6.jpg" alt="UNADJUSTEDNONRAW_thumb_b6"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_bb.jpg" alt="UNADJUSTEDNONRAW_thumb_bb"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_be.jpg" alt="UNADJUSTEDNONRAW_thumb_be"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_c1.jpg" alt="UNADJUSTEDNONRAW_thumb_c1"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_cc.jpg" alt="UNADJUSTEDNONRAW_thumb_cc"></p><h2 id="第六日：敦煌-莫高窟-鸣沙山月牙泉"><a href="#第六日：敦煌-莫高窟-鸣沙山月牙泉" class="headerlink" title="第六日：敦煌-莫高窟-鸣沙山月牙泉"></a>第六日：敦煌-莫高窟-鸣沙山月牙泉</h2><h3 id="莫高窟"><a href="#莫高窟" class="headerlink" title="莫高窟"></a>莫高窟</h3><p>由于景区规定了洞窟内不能摄影，所以就拍了一张外景图。</p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_e2.jpg" alt="UNADJUSTEDNONRAW_thumb_e2"></p><h3 id="鸣沙山月牙泉"><a href="#鸣沙山月牙泉" class="headerlink" title="鸣沙山月牙泉"></a>鸣沙山月牙泉</h3><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_e9.jpg" alt="UNADJUSTEDNONRAW_thumb_e9"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_ec.jpg" alt="UNADJUSTEDNONRAW_thumb_ec"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_ef.jpg" alt="UNADJUSTEDNONRAW_thumb_ef"></p><h2 id="第七日：敦煌-七彩丹霞-张掖"><a href="#第七日：敦煌-七彩丹霞-张掖" class="headerlink" title="第七日：敦煌-七彩丹霞-张掖"></a>第七日：敦煌-七彩丹霞-张掖</h2><h3 id="七彩丹霞"><a href="#七彩丹霞" class="headerlink" title="七彩丹霞"></a>七彩丹霞</h3><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_fa.jpg" alt="UNADJUSTEDNONRAW_thumb_fa"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_fc.jpg" alt="UNADJUSTEDNONRAW_thumb_fc"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_105.jpg" alt="UNADJUSTEDNONRAW_thumb_105"></p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_110.jpg" alt="UNADJUSTEDNONRAW_thumb_110"></p><h3 id="张掖"><a href="#张掖" class="headerlink" title="张掖"></a>张掖</h3><p>在张掖这块地方，不得不提的就是羊肉了，真的可以说得上又便宜又好吃，60块一斤的羊肉肥而不腻，分量十足，加上大蒜以及泡菜，简单美味。</p><h2 id="第八日：张掖-兰州-成都"><a href="#第八日：张掖-兰州-成都" class="headerlink" title="第八日：张掖-兰州-成都"></a>第八日：张掖-兰州-成都</h2><p>为什么第八日的行程看上去那么复杂？主要考虑到从张掖开车返回西宁的话，由于冬天的缘故，预计行程中的油菜花田是没有的，外加雪山封路会导致时间加长，所以我们就打算以高铁的行程直接返回兰州，再从兰州乘飞机返回成都，这样下来所花费的金钱只和西宁到达成都相差无几，但节省了不少时间。</p><p><img src="/2018/12/06/八日漫游大西环线/IMG_8637.JPG" alt="IMG_8637"></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>最后就附上我们这次两人这八天下来所预估的花费清单，淡季出行+学生半价（甚至免票）是一个很棒的结合！</p><p><img src="/2018/12/06/八日漫游大西环线/UNADJUSTEDNONRAW_thumb_111.jpg" alt="UNADJUSTEDNONRAW_thumb_111"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;这次旅行可以认为是一场说走就走的旅行，缘起于朋友的一次不经意的漫谈，到最终构思出大致的计划不过两日，我俩就踏上了旅程，途中边走边规划，要去哪
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>交友？</title>
    <link href="http://apparition957.github.io/2018/11/19/%E4%BA%A4%E5%8F%8B%EF%BC%9F/"/>
    <id>http://apparition957.github.io/2018/11/19/交友？/</id>
    <published>2018-11-18T16:27:35.000Z</published>
    <updated>2018-11-18T16:30:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章纯属自己的有感而发写的。</p></blockquote><p>这段时间也不知怎么回事，做起事来都充满了无力感</p><p>朋友的冷漠 敏感 怀疑自己</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这篇文章纯属自己的有感而发写的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这段时间也不知怎么回事，做起事来都充满了无力感&lt;/p&gt;
&lt;p&gt;朋友的冷漠 敏感 怀疑自己&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>出门走走-贵州岑巩县</title>
    <link href="http://apparition957.github.io/2018/11/12/%E5%87%BA%E9%97%A8%E8%B5%B0%E8%B5%B0-%E8%B4%B5%E5%B7%9E%E5%B2%91%E5%B7%A9%E5%8E%BF/"/>
    <id>http://apparition957.github.io/2018/11/12/出门走走-贵州岑巩县/</id>
    <published>2018-11-12T08:16:05.000Z</published>
    <updated>2018-11-12T09:39:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上周参加了学校组织的扶贫活动，地点位于贵州岑巩县。并不是因为偷懒没写技术博客才去的呀：）</p></blockquote><h2 id="做了什么"><a href="#做了什么" class="headerlink" title="做了什么"></a>做了什么</h2><p>这次扶贫活动的主要是帮助各乡镇进行贫困户的信息录入工作，减少一些他们的工作量，以我前去的平庄镇而言，乡镇的人口基数相较于其他乡镇而言还算比较大的，外加上镇上的干部数量比较少，所以信息录入工作基本就是由一人负责，工作量大而繁琐。</p><p>额外说下的是，因为需要在2021年要达到“两个一百年”中第一个一百年的目标，不知从几年前开始，我所在的镇上所有干部就基本上过着加班的日子，隔三差五就有一个会议要开。值班的日子是以两周为间隔，也就是说至少需要值班两周才能够回家休息这样的一个状态。在平常的时候还需要经常下乡对每家每户进行调研统计，方便后期对各贫困户实施不同的扶贫措施。</p><p><strong>真的感谢你们的辛苦工作！</strong></p><h2 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h2><p>跟同学一起进行贫困户信息录入的这段时间中，我接触了不少致贫原因各不相同的家庭，总结下自己的一些感触吧。</p><h3 id="补助"><a href="#补助" class="headerlink" title="补助"></a>补助</h3><p>在个人收入中，可分为工资性收入、生产性经营收入和各项补助。若家庭中有患有重病或者残疾的人的话，前两项收入往往是较少的，更主要是通过补助的方式维持生活，而各项补助总和的金额却是较少的（1k-10k 浮动）。</p><p>虽然较偏远地区的生活水平较低，但我真的不清楚这些补助金额是否能够维持这些特殊人群的正常生活。</p><h3 id="教育"><a href="#教育" class="headerlink" title="教育"></a>教育</h3><p>不知是否受限于九年义务教育的原因，有不少的人选择了初中毕业后就直接去外地工作，或独闯天下，或与父母一起，家庭总体收入较低且不具有稳定性（即数据相较于去年而言变化较大）。至于为什么选择直接工作也有各种各样的理由，有的人是因为家庭原因，有的人却是因为不想读了（原话）。与上述情况不同的，有些家庭的家长虽然身处外地打工，却依然支持自己的子女上高中上大学。在一些已有大学生的家庭中，我能够感受他们家庭自身的收入在一个中等偏上（相较于全村而言）的水平。</p><p>由于自己只能够通过纸张上的对比表，从家庭各成员学历、工作地、收入来分析他们的情况，所以我没法真真正正了解到他们每一个人的想法与感受。但是有一点我能感受到的是，接受了高等教育的人，能够为自己的家庭贡献出更多的力量。</p><h2 id="美丽岑巩"><a href="#美丽岑巩" class="headerlink" title="美丽岑巩"></a>美丽岑巩</h2><p>身处于城市过久，来乡村的一周时间中，觉得乡村真是一个很不错的地方，虽然在生活设施方面远不及城市，但无论是自然风景，还是饮食，乡村还是有其独特之处。（再次特别感谢每日饭堂的好饭菜！）</p><p><img src="/2018/11/12/出门走走-贵州岑巩县/IMG_7851.JPG" alt=""></p><p><img src="/2018/11/12/出门走走-贵州岑巩县/IMG_7852.JPG" alt=""></p><p><img src="/2018/11/12/出门走走-贵州岑巩县/IMG_7854.JPG" alt=""></p><p><img src="/2018/11/12/出门走走-贵州岑巩县/IMG_7864.JPG" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;上周参加了学校组织的扶贫活动，地点位于贵州岑巩县。并不是因为偷懒没写技术博客才去的呀：）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;做了什么&quot;&gt;&lt;a href=&quot;#做了什么&quot; class=&quot;headerlink&quot; title=&quot;做了什么&quot;
      
    
    </summary>
    
    
      <category term="旅行" scheme="http://apparition957.github.io/tags/%E6%97%85%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>Motan 系列-总体设计</title>
    <link href="http://apparition957.github.io/2018/11/02/Motan-%E7%B3%BB%E5%88%97-%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1/"/>
    <id>http://apparition957.github.io/2018/11/02/Motan-系列-总体设计/</id>
    <published>2018-11-02T06:47:36.000Z</published>
    <updated>2018-11-10T11:15:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Motan 是微博开源的一套基于 Java 研发的 RPC 框架，更加详细的了解可以参考<a href="https://github.com/weibocom/motan/wiki/zh_userguide" target="_blank" rel="external">Motan中文文档</a>，本文内容更多的是关注于总体架构方面的设计。</p><h2 id="架构概述"><a href="#架构概述" class="headerlink" title="架构概述"></a>架构概述</h2><p><img src="/2018/11/02/Motan-系列-总体设计/Motan-总体架构.jpg" alt=""></p><p>上图是 RPC 通信框架中较为通用的架构设计方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;Motan 是微博开源的一套基于 Java 研发的 RPC 框架，更加详细的了解可以参考&lt;a href=&quot;https://github.co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Motan 系列 - 目录</title>
    <link href="http://apparition957.github.io/2018/10/30/Motan%20%E7%B3%BB%E5%88%97-%E7%9B%AE%E5%BD%95/"/>
    <id>http://apparition957.github.io/2018/10/30/Motan 系列-目录/</id>
    <published>2018-10-30T05:08:33.000Z</published>
    <updated>2018-11-02T06:47:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>其实本来想写 Dubbo 的，奈何时间和个人能力都不足以让我从头到尾把 Dubbo 看一遍，所以转而深入理解 Motan 这一小而美的 RPC 框架。</p></blockquote><p>下面是近期想要开始写的 Motan 源码分析系列文章（先自己把坑挖好，后期慢慢把坑填上吧）。</p><ol><li>Motan 系列-总体设计</li><li>Motan 系列-额外知识-SPI 机制</li><li>Motan 系列-额外知识-Spring 事件机制</li><li>Motan 系列-服务提供者-如何提供服务</li><li>Motan 系列-服务提供者-如何响应服务</li><li>Motan 系列-服务消费者-如何连接服务</li><li>Motan 系列-服务消费者-如何消费服务</li><li>Motan 系列-注册中心设计</li><li>Motan 系列-其他特性-心跳机制</li><li>Motan 系列-其他特性-Shutdown 机制</li><li>Motan 系列-其他特性-异步调用</li><li>…..</li></ol><hr><p>以下参考的文章都是在我学习 Motan 的时候提供了很大的帮助，十分感谢他们能写出这么棒的文章。</p><ol><li><a href="http://kriszhang.com/motan-rpc-impl/" target="_blank" rel="external">从motan看RPC框架设计</a></li><li><a href="https://fdx321.github.io/2017/07/19/%E3%80%90Motan%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%911-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/" target="_blank" rel="external">Motan源码学习</a></li><li><a href="http://blog.yannxia.top/2018/06/30/java/motan/motan/" target="_blank" rel="external">Motan源码分析</a></li><li><a href="https://github.com/weibocom/motan/wiki" target="_blank" rel="external">github/Motan-wiki 文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;其实本来想写 Dubbo 的，奈何时间和个人能力都不足以让我从头到尾把 Dubbo 看一遍，所以转而深入理解 Motan 这一小而美的 RPC 框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是近期想要开始写的 Motan 源码分析系列文章（
      
    
    </summary>
    
    
      <category term="Motan" scheme="http://apparition957.github.io/tags/Motan/"/>
    
  </entry>
  
  <entry>
    <title>在小米实习的180天</title>
    <link href="http://apparition957.github.io/2018/07/20/%E5%9C%A8%E5%B0%8F%E7%B1%B3%E5%AE%9E%E4%B9%A0%E7%9A%84180%E5%A4%A9/"/>
    <id>http://apparition957.github.io/2018/07/20/在小米实习的180天/</id>
    <published>2018-07-20T14:46:20.000Z</published>
    <updated>2018-07-20T14:47:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>感恩在小米的这段实习经历，感谢小米身边的每个人。</p><p><img src="http://on83riher.bkt.clouddn.com/WechatIMG17218.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;感恩在小米的这段实习经历，感谢小米身边的每个人。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://on83riher.bkt.clouddn.com/WechatIMG17218.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TCP 协议中 Keep-Alive 特性</title>
    <link href="http://apparition957.github.io/2018/05/27/TCP%20%E5%8D%8F%E8%AE%AE%E4%B8%AD%20Keep-Alive%20%E7%89%B9%E6%80%A7/"/>
    <id>http://apparition957.github.io/2018/05/27/TCP 协议中 Keep-Alive 特性/</id>
    <published>2018-05-27T10:47:59.000Z</published>
    <updated>2018-05-27T10:48:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在腾讯面试的时候问过我基于这个特性的问题，可惜我没答出来:(,以下为原题部分。</p><p>在 TCP 连接中，我们都知道客户端要与服务器端断开连接时需要经过”四次分手”。但如果客户端在未知因素的情况下宕机了，那服务器端会在什么时候认为客户端已掉线，从而服务器端”主动”断开连接呢？</p></blockquote><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>抛弃上面的描述，我们知道在 TCP 协议中，如果客户端不主动断开与服务器端的连接时，服务器端便会一直持有对这个客户端的连接。如果不引入某些有效机制的话，这将会大大地消耗服务器端的资源。</p><p>keep-alive 机制确保了服务器端能够在客户端无消息发送的一段时间后，自主地断开与客户端的连接。</p><h4 id="RFC-中-Keep-Alive-机制"><a href="#RFC-中-Keep-Alive-机制" class="headerlink" title="RFC 中 Keep-Alive 机制"></a>RFC 中 Keep-Alive 机制</h4><p>keep-alive 是 TCP 协议的可选特性（optional feature）。如果操作系统实现了这一特性，就必须保证应用程序能够为每个 TCP 连接打开或关闭该特性，且这一特性必须是默认关闭的。</p><p>keep-alive 的心跳包只能够在从最后一次接收到 ACK 包的时间起，经过一个固定的时间间隔后才能发送。这个时间间隔必须能够被配置，且默认值不能够低于2小时。</p><p>keep-alive 应当在服务器端启用，而客户端不做任何修改。倘若客户端开启了这一特性，当客户端异常崩溃或者出现连接故障的话，将会导致该连接无限期挂起和消耗不必要的资源。</p><p>在 TCP 规范中并不包含 keep-alive 机制的主要原因有三：（1）在短暂的网络故障期间，可能会导致一个良好正常的连接(perfectly good connections)断开。(2)消耗不必要的带宽资源（”if no one is using the                 connection, who cares if it is still good?”）。（3）在以数据包计费的互联网网络中（额外）花费金钱。</p><h4 id="Linux-内核下-Keep-Alive-的重要参数"><a href="#Linux-内核下-Keep-Alive-的重要参数" class="headerlink" title="Linux 内核下 Keep-Alive 的重要参数"></a>Linux 内核下 Keep-Alive 的重要参数</h4><p>在 Linux 内核中，keep-alive 机制涉及到三个重要的参数：</p><ol><li>tcp_keepalive_time。该参数是指最后一次数据包（不包含数据的 ACK 包）发送的时间到第一次发送的心跳包之间的时间间隔。默认值为7200s（2小时）。</li><li>tcp_keepalive_intvl。该参数是指连续两个心跳包之间的时间间隔。默认值为75s。</li><li>tcp_keepalive_probes。该参数是指在服务器端认为该连接失效(dead)并通知用户前，未确认的探测器(unacknowledged probes)发送的数量。默认值为9（次）。</li></ol><p>Linux 的文档还特别声明了即使 keep-alive 这一机制在内核中被配置了，这一行为也不是 Linux 的默认行为。</p><h4 id="面试题的一种合适的解释"><a href="#面试题的一种合适的解释" class="headerlink" title="面试题的一种合适的解释"></a>面试题的一种合适的解释</h4><p>了解了这一特性背后的含义时，我们可以对面试官说到。在 Linux 环境下，如果该连接中 keep-alive 机制已开启时，服务器端会在 7200s + 75s * 9time 后断开与客户端的连接（即在底层清除失效的文件描述符）。</p><h4 id="与-HTTP-中-Keep-Alive-的对比"><a href="#与-HTTP-中-Keep-Alive-的对比" class="headerlink" title="与 HTTP 中 Keep-Alive 的对比"></a>与 HTTP 中 Keep-Alive 的对比</h4><p>HTTP 协议中的 keep-alive 机制是为了通信双方的连接复用，避免消耗太多资源。而  TCP 协议中 keep-alive 机制是为了检验通信双方的是否活着(alive)，保证通信能够正常进行。</p><hr><p>参考资料：</p><ol><li><a href="https://tools.ietf.org/html/rfc1122#page-101" target="_blank" rel="external">https://tools.ietf.org/html/rfc1122#page-101</a></li><li><a href="http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html" target="_blank" rel="external">http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html</a></li><li><a href="http://www.importnew.com/27624.html" target="_blank" rel="external">http://www.importnew.com/27624.html</a></li><li><a href="http://www.cnblogs.com/liuyong/archive/2011/07/01/2095487.html" target="_blank" rel="external">http://www.cnblogs.com/liuyong/archive/2011/07/01/2095487.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在腾讯面试的时候问过我基于这个特性的问题，可惜我没答出来:(,以下为原题部分。&lt;/p&gt;
&lt;p&gt;在 TCP 连接中，我们都知道客户端要与服务器端断开连接时需要经过”四次分手”。但如果客户端在未知因素的情况下宕机了，那服务器端会在什么时候认为客户端已掉
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala - NonLocalReturnControl</title>
    <link href="http://apparition957.github.io/2018/05/22/Scala%20-%20NonLocalReturnControl/"/>
    <id>http://apparition957.github.io/2018/05/22/Scala - NonLocalReturnControl/</id>
    <published>2018-05-22T08:36:18.000Z</published>
    <updated>2018-05-22T08:38:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="状态说明"><a href="#状态说明" class="headerlink" title="状态说明"></a>状态说明</h4><p>今天跑 Spark 作业的时候，刚进入 RUNNING 状态没多久就直接抛出了下面这种异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">User class threw exception: org.apache.spark.SparkException: Task not serializable</div><div class="line">  at org.apache.spark.util.ClosureCleaner$.ensureSerializable(ClosureCleaner.scala:298)</div><div class="line">  at org.apache.spark.util.ClosureCleaner$.org$apache$spark$util$ClosureCleaner$$clean(ClosureCleaner.scala:288)</div><div class="line">  at org.apache.spark.util.ClosureCleaner$.clean(ClosureCleaner.scala:108)</div><div class="line">  at org.apache.spark.SparkContext.clean(SparkContext.scala:2100)</div><div class="line">.....</div><div class="line">Caused by: java.io.NotSerializableException: java.lang.Object</div><div class="line">Serialization stack:</div><div class="line">  - object not serializable (class: java.lang.Object, value: java.lang.Object@65c9e3ee)</div><div class="line">  - field (class: com.xiaomi.search.websearch.hbase.SegTitlePick$$anonfun$1, name: nonLocalReturnKey1$1, type: class java.lang.Object)</div><div class="line">  - object (class com.xiaomi.search.websearch.hbase.SegTitlePick$$anonfun$1, &lt;function1&gt;)</div><div class="line">  at org.apache.spark.serializer.SerializationDebugger$.improveException(SerializationDebugger.scala:40)</div><div class="line">  at org.apache.spark.serializer.JavaSerializationStream.writeObject(JavaSerializer.scala:46)</div><div class="line">  at org.apache.spark.serializer.JavaSerializerInstance.serialize(JavaSerializer.scala:100)</div><div class="line">  at org.apache.spark.util.ClosureCleaner$.ensureSerializable(ClosureCleaner.scala:295)</div></pre></td></tr></table></figure><p>上网一查发现时某个匿名函数里面使用了 return 导致的。</p><h4 id="报错理由是什么呢"><a href="#报错理由是什么呢" class="headerlink" title="报错理由是什么呢"></a>报错理由是什么呢</h4><p>源代码就不贴出来了，我们以一个简单的例子来说明这个问题吧。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> datas = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">    datas.foreach(t =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (t % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="comment">// 运行符合条件时便立刻返回</span></div><div class="line">    &#125;)</div><div class="line">    </div><div class="line">    <span class="comment">// 本例的目标想在遍历完 datas 后便输出该语句，但在实际情况下，return 语句会直接返回并退出当前函数(即 main 函数)，所以以下语句并不会输出结果</span></div><div class="line">    println(<span class="string">"finished!"</span>) </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>让我们查看编译后这段遍历的代码有什么不一样的地方吧？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// scalac -Xprint:explicitouter Test.scala</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">  &lt;synthetic&gt; <span class="keyword">val</span> nonLocalReturnKey1: <span class="type">Object</span> = <span class="keyword">new</span> <span class="type">Object</span>();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">val</span> datas: <span class="type">List</span>[<span class="type">Int</span>] =            scala.collection.immutable.<span class="type">List</span>.apply[<span class="type">Int</span>]  (scala.<span class="type">Predef</span>.wrapIntArray(<span class="type">Array</span>[<span class="type">Int</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;));</div><div class="line">    datas.foreach[<span class="type">Unit</span>](&#123;</div><div class="line">      <span class="keyword">final</span> &lt;artifact&gt; <span class="function"><span class="keyword">def</span> <span class="title">$anonfun$main</span></span>(t: <span class="type">Int</span>): <span class="type">Unit</span> = <span class="keyword">if</span> (t.%(<span class="number">2</span>).==(<span class="number">0</span>))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> scala.runtime.<span class="type">NonLocalReturnControl</span>$mcV$sp(nonLocalReturnKey1, ())</div><div class="line">      <span class="keyword">else</span></div><div class="line">        ();</div><div class="line">      ((t: <span class="type">Int</span>) =&gt; $anonfun$main(t))</div><div class="line">    &#125;);</div><div class="line">    scala.<span class="type">Predef</span>.println(<span class="string">"finished!"</span>)</div><div class="line">  &#125; <span class="keyword">catch</span> &#123;</div><div class="line">    <span class="keyword">case</span> (ex @ (_: scala.runtime.<span class="type">NonLocalReturnControl</span>[<span class="type">Unit</span> <span class="meta">@unchecked</span>])) =&gt; <span class="keyword">if</span> (ex.key().eq(nonLocalReturnKey1))</div><div class="line">      ex.value$mcV$sp()</div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="keyword">throw</span> ex</div><div class="line">  &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>编译后我们可以看到原先匿名函数中的 return 语句被替换成抛出一个<code>NonLocalReturnControl</code>运行时异常，而<code>try-catch</code>环绕着整个 main 函数内部的代码块来尝试捕获这个异常。</p><p>而观察<code>NonLocalReturnControl</code>异常，我们发现这个异常是无法被序列化的，这就解释了之前的作业抛出异常的意思了。</p><h4 id="为什么-return-语句要这么设计呢"><a href="#为什么-return-语句要这么设计呢" class="headerlink" title="为什么 return 语句要这么设计呢"></a>为什么 return 语句要这么设计呢</h4><p>为什么 Scala 要这么做呢？这里有几篇不错的文章来说明，我就偷懒不去翻译了(建议从上往下看)</p><ol><li>介绍什么是 non-local return - <a href="https://www.zhihu.com/question/22240354/answer/64673094" target="_blank" rel="external">https://www.zhihu.com/question/22240354/answer/64673094</a></li><li>前半段介绍 return 语句该什么时候出现，后半段推测出这么做的两个原因 - <a href="https://stackoverflow.com/questions/17754976/scala-return-statements-in-anonymous-functions" target="_blank" rel="external">https://stackoverflow.com/questions/17754976/scala-return-statements-in-anonymous-functions</a></li><li>讨论在 Scala 中 function 和 method 两者概念上的区别 - <a href="https://link.jianshu.com/?t=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F2529184%2Fdifference-between-method-and-function-in-scala" target="_blank" rel="external">https://link.jianshu.com/?t=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F2529184%2Fdifference-between-method-and-function-in-scala</a></li></ol><p>但其实翻阅了网上的资料，并没有真正地说明为什么这么设计。结合上面的几篇文章，我个人认为在 Scala 这一门函数式编程语言里，其更加讲究的是程序执行的结果，而并非执行过程。return 语句影响程序的顺序执行，从而可能会使代码变得复杂，也可能会发生若干次程序执行的结果不一致的情况，那么这将在很大程度上影响了我们对于代码的理解与认识。这也是 Scala 为什么不倡导我们使用 return。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;状态说明&quot;&gt;&lt;a href=&quot;#状态说明&quot; class=&quot;headerlink&quot; title=&quot;状态说明&quot;&gt;&lt;/a&gt;状态说明&lt;/h4&gt;&lt;p&gt;今天跑 Spark 作业的时候，刚进入 RUNNING 状态没多久就直接抛出了下面这种异常。&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala - Iterator vs Stream vs View</title>
    <link href="http://apparition957.github.io/2018/05/19/Scala%20-%20Iterator%20vs%20Stream%20vs%20View/"/>
    <id>http://apparition957.github.io/2018/05/19/Scala - Iterator vs Stream vs View/</id>
    <published>2018-05-19T09:58:10.000Z</published>
    <updated>2018-05-19T09:58:33.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h4><p><a href="https://stackoverflow.com/questions/5159000/stream-vs-views-vs-iterators" target="_blank" rel="external">https://stackoverflow.com/questions/5159000/stream-vs-views-vs-iterators</a></p><h4 id="优秀回答"><a href="#优秀回答" class="headerlink" title="优秀回答"></a>优秀回答</h4><blockquote><p>该篇回答被收录到 Scala 文档中的 F&amp;Q 部分。我尝试跟着这篇回答并对照源码部分去翻译，翻译不好多多谅解。</p></blockquote><p>First, they are all <em>non-strict</em>. That has a particular mathematical meaning related to functions, but, basically, means they are computed on-demand instead of in advance.</p><p>首先，它们都是非严格（即惰性的）的。每个函数都有其特定的数学含义，但是基本上，其数学含义通常都意味着它们是按需计算而非提前计算。</p><p><code>Stream</code> is a lazy list indeed. In fact, in Scala, a <code>Stream</code> is a <code>List</code> whose <code>tail</code> is a <code>lazy val</code>. Once computed, a value stays computed and is reused. Or, as you say, the values are cached.</p><p><code>Stream</code>确实是一个惰性列表。事实上，在 Scala 中，<code>Stream</code>是<code>tail</code>变量为惰性值的列表。一旦开始计算，<code>Stream</code>中的值便保持计算后的状态并被能够被重复使用。或者按照你的说法是，<code>Stream</code>中的值能够被缓存下来。</p><blockquote><p>一篇比较不错的、科普<code>Stream</code>的文章：<a href="http://cuipengfei.me/blog/2014/10/23/scala-stream-application-scenario-and-how-its-implemented/" target="_blank" rel="external">http://cuipengfei.me/blog/2014/10/23/scala-stream-application-scenario-and-how-its-implemented/</a></p></blockquote><p>An <code>Iterator</code> can only be used once because it is a <em>traversal pointer</em> into a collection, and not a collection in itself. What makes it special in Scala is the fact that you can apply transformation such as <code>map</code> and <code>filter</code> and simply get a new <code>Iterator</code> which will only apply these transformations when you ask for the next element.</p><p><code>Iterator</code>只能够被使用一次，因为其是一个<em>可遍历</em>的指针存在于集合当中，而非集合本身存在于<code>Iterator</code>中。让其在 Scala 如此特殊的原因在于你能够使用 transformation 算子，如<code>map</code>或者<code>filter</code>，并且很容易地获得一个新的<code>Iterator</code>。需要注意的是，新的<code>Iterator</code>只有通过获取元素的时候才会应用那些 transformation 算子。</p><p>Scala used to provide iterators which could be reset, but that is very hard to support in a general manner, and they didn’t make version 2.8.0.</p><p>Scala 曾尝试过给那些 iterator 一个可复位的功能，但这很难以一个通用的方式去支持。</p><p>Views are meant to be viewed much like a database view. It is a series of transformation which one applies to a collection to produce a “virtual” collection. As you said, all transformations are re-applied each time you need to fetch elements from it.</p><p>Views 通常意味着元素需要被观察，类似于数据库中的 view。它是原集合通过一系列的 transformation 算子生成的一个”虚构”的集合。如你所说，每当你需要从原集合中获取数据时，都能够重复应用这些 transformation 算子。</p><p>Both <code>Iterator</code> and views have excellent memory characteristics. <code>Stream</code> is nice, but, in Scala, its main benefit is writing infinite sequences (particularly sequences recursively defined). One <em>can</em> avoid keeping all of the <code>Stream</code> in memory, though, by making sure you don’t keep a reference to its <code>head</code> (for example, by using <code>def</code> instead of <code>val</code> to define the <code>Stream</code>).</p><p><code>Iterator</code>和 views 两者都有不错内存（记忆？）特性。<code>Stream</code>也可以，但是在 Scala 中，其主要的好处在于能够保留无限长的序列（特别是那些序列是通过递归定义的[这一点需要通过 Stream 本身特性才能够理解]）当中。不过，你可以避免将所有Stream保留在内存中，其方法是确保不保留那些对 <code>Stream</code>中<code>head</code>的引用。</p><blockquote><p>针对最后提到的例子，<a href="https://stackoverflow.com/questions/13217222/should-i-use-val-or-def-when-defining-a-stream这篇回答有比较好的解释" target="_blank" rel="external">https://stackoverflow.com/questions/13217222/should-i-use-val-or-def-when-defining-a-stream这篇回答有比较好的解释</a></p></blockquote><p>Because of the penalties incurred by views, one should usually <code>force</code> it after applying the transformations, or keep it as a view if only few elements are expected to ever be fetched, compared to the total size of the view.</p><p>由于 views 所带来不良影响（个人认为是这么翻译的），我们通常需要在应用 transformations 后调用<code>force</code>进行计算，或者说如果相比于原 view 中大量元素，新 view 只有少量的元素需要去获取时，可以将其当做新的 view 对待。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;问题来源&quot;&gt;&lt;a href=&quot;#问题来源&quot; class=&quot;headerlink&quot; title=&quot;问题来源&quot;&gt;&lt;/a&gt;问题来源&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/5159000/stream-vs
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala - 有关变量赋值的问题</title>
    <link href="http://apparition957.github.io/2018/05/18/Scala%20-%20%E6%9C%89%E5%85%B3%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://apparition957.github.io/2018/05/18/Scala - 有关变量赋值的问题/</id>
    <published>2018-05-18T15:14:46.000Z</published>
    <updated>2018-05-18T15:15:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="先看个小问题"><a href="#先看个小问题" class="headerlink" title="先看个小问题"></a>先看个小问题</h4><p>先贴下一段<code>Scala</code>代码，看下这段代码是否存在问题？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> persons = <span class="type">List</span>[<span class="type">Person</span>](<span class="type">Person</span>(<span class="string">"tom"</span>), <span class="type">Person</span>(<span class="string">"marry"</span>), <span class="literal">null</span>).iterator</div><div class="line"><span class="keyword">var</span> person: <span class="type">Person</span> = <span class="literal">null</span></div><div class="line"><span class="keyword">while</span> ((person = persons.next()) != <span class="literal">null</span>) &#123;</div><div class="line">  println(<span class="string">"obj name: "</span> + person.name)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果你的答案是<code>这段代码运行不会出任何问题</code>的话，那么你对于 Scala 的变量赋值还是了解太少。</p><hr><h4 id="为什么呢"><a href="#为什么呢" class="headerlink" title="为什么呢"></a>为什么呢</h4><p>在我们一般的认知中，在 Java 和 C++ 中对变量赋值后，其会返回相对应该变量的值，而在 Scala 中，如果对变量赋值后，获取到的返回值却统一是 Unit。</p><blockquote><p>Unit 是表示为无值，其作用与其他语言中的 void 作用相同，用作不返回任何结果的方法的结果类型。</p></blockquote><p>回到刚才那段代码，根据以上说明，如果我们在赋值对<code>person</code>变量的话，那就会导致在每一次循环当中，其实我们一直都是拿 Unit 这个值去与 null 比较，那么就可以换做一个恒等式为<code>Unit != null</code>，这样做的结果就是这个循环不会中断。</p><blockquote><p>在 IDEA 中，如果我们仔细查看代码，发现 IDE 已经提醒我们这个问题的存在了，这这也仅仅只是 Warning 而已。</p><p>若通过编译的方法查看源代码的话，会在编译的过程中，获得这样一句警告（并非错误！）：</p><p><img src="http://on83riher.bkt.clouddn.com/QQ20180518-225838@2x.png" alt=""></p></blockquote><p>有个简单的例子可以检验自己是否明白懂了这个”bug”：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a: <span class="type">Int</span> = <span class="number">0</span></div><div class="line"><span class="keyword">var</span> b: <span class="type">Int</span> = <span class="number">0</span></div><div class="line">a = b = <span class="number">1</span> <span class="comment">// 这行代码能够跑通，在其他语言呢？</span></div></pre></td></tr></table></figure><hr><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>在给出常见的解决方案前，先给出为什么 Scala 要这样设计的理由（Scala 之父亲自解释）：</p><p><a href="https://stackoverflow.com/questions/1998724/what-is-the-motivation-for-scala-assignment-evaluating-to-unit-rather-than-the-v" target="_blank" rel="external">https://stackoverflow.com/questions/1998724/what-is-the-motivation-for-scala-assignment-evaluating-to-unit-rather-than-the-v</a></p><p>常见的解决方案会有以下几种：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// solution 1 - 封装成代码块返回最终值，直观但麻烦</span></div><div class="line"><span class="keyword">var</span> person = <span class="literal">null</span></div><div class="line"><span class="keyword">while</span> (&#123;person = persons.next; person != <span class="literal">null</span>&#125;) &#123;</div><div class="line">  println(<span class="string">"obj name: "</span> + person.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// solution 2 （推荐）- 通过 Scala 的语法特性，使用它的奇淫技巧</span></div><div class="line"><span class="type">Iterator</span>.continually(persons.next())</div><div class="line">  .takeWhile(_ != <span class="literal">null</span>)</div><div class="line">  .foreach(t =&gt; &#123;println(<span class="string">"obj name: "</span> + t.name)&#125;)</div><div class="line"></div><div class="line"><span class="comment">// solution 3 - 这个与 Solution2 的区别仅仅在于使用的类不同，但使用的类不同便意味着这两者之间存在着不同的遍历方式。两者的区别会在博客中更新。</span></div><div class="line"><span class="type">Stream</span>.continually(persons.next())</div><div class="line">  .takeWhile(_ != <span class="literal">null</span>)</div><div class="line">  .foreach(t =&gt; &#123;println(<span class="string">"obj name: "</span> + t.name)&#125;)</div></pre></td></tr></table></figure><p>参考资料：</p><ol><li><a href="https://stackoverflow.com/questions/6881384/why-do-i-get-a-will-always-yield-true-warning-when-translating-the-following-f" target="_blank" rel="external">https://stackoverflow.com/questions/6881384/why-do-i-get-a-will-always-yield-true-warning-when-translating-the-following-f</a></li><li><a href="https://stackoverflow.com/questions/3062804/scala-unit-type" target="_blank" rel="external">https://stackoverflow.com/questions/3062804/scala-unit-type</a></li><li><a href="https://stackoverflow.com/questions/2442318/how-would-i-express-a-chained-assignment-in-scala" target="_blank" rel="external">https://stackoverflow.com/questions/2442318/how-would-i-express-a-chained-assignment-in-scala</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;先看个小问题&quot;&gt;&lt;a href=&quot;#先看个小问题&quot; class=&quot;headerlink&quot; title=&quot;先看个小问题&quot;&gt;&lt;/a&gt;先看个小问题&lt;/h4&gt;&lt;p&gt;先贴下一段&lt;code&gt;Scala&lt;/code&gt;代码，看下这段代码是否存在问题？&lt;/p&gt;
&lt;figure cl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala - 类构造器</title>
    <link href="http://apparition957.github.io/2018/05/14/Scala%20-%20%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8/"/>
    <id>http://apparition957.github.io/2018/05/14/Scala - 类构造器/</id>
    <published>2018-05-14T15:58:37.000Z</published>
    <updated>2018-05-14T15:59:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>Scala 构造器可分为两种，主构造器和辅助构造器。</p><h4 id="主构造器"><a href="#主构造器" class="headerlink" title="主构造器"></a>主构造器</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 无参主构造器</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="comment">// 主构造器的构成部分</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 有参主构造器</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo2</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>) </span>&#123;</div><div class="line">    <span class="comment">// 主构造器的构成部分</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从类的定义开始，花括号的部分为主构造器的构成部分。主构造器在执行时，会执行类中所有的语句。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// example</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">val</span> name = <span class="string">"tom"</span></div><div class="line">    <span class="keyword">val</span> age = <span class="number">18</span></div><div class="line">    </div><div class="line">    doSomething() <span class="comment">// 初始化对象时，会打印 name: tome, age: 18</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doSomething</span></span>() = &#123;</div><div class="line">        println(<span class="string">"name: "</span> + name + <span class="string">", age: "</span> + age)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="辅助构造器"><a href="#辅助构造器" class="headerlink" title="辅助构造器"></a>辅助构造器</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> age = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="comment">// 错误定义!!</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() &#123;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">this</span>()</div><div class="line">        <span class="keyword">this</span>.name = name</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</div><div class="line">        <span class="keyword">this</span>(name)</div><div class="line">        <span class="keyword">this</span>.age = age</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>辅助构造器的名称为<code>this</code>，与 Java 的构造器名称不同（Java 构造器名称是以类名定义的），其代码大致结构为<code>def this(...) {}</code>。若一个类如果没有显式定义主构造器，则编译器会自动生成一个无参的主构造器。</p><p>必须注意的是，每个辅助构造器都必须以一个对先前已定义的其他辅助构造器或者主构造器的调用开始。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Scala 构造器可分为两种，主构造器和辅助构造器。&lt;/p&gt;
&lt;h4 id=&quot;主构造器&quot;&gt;&lt;a href=&quot;#主构造器&quot; class=&quot;headerlink&quot; title=&quot;主构造器&quot;&gt;&lt;/a&gt;主构造器&lt;/h4&gt;&lt;figure class=&quot;highlight scala&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>寻找一种更快更高效的方法</title>
    <link href="http://apparition957.github.io/2018/05/07/%E5%AF%BB%E6%89%BE%E4%B8%80%E7%A7%8D%E6%9B%B4%E5%BF%AB%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://apparition957.github.io/2018/05/07/寻找一种更快更高效的方法/</id>
    <published>2018-05-07T14:35:49.000Z</published>
    <updated>2018-05-07T14:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在对我们开发的模块进行最后的收尾，收尾的工作一般来说都是添加测试用例，测试模块调用时是否有 BUG 等。果不其然，老大还是叫我去做模块的测试。其实还是自己对于 C++了解太少，刚入门一个星期才勉强能够看懂之前的部分源码，而且原有工程十分庞大，还有自己封装好的又或自己开发的工具库。想去调用还得自己上网看看 example 熟悉下，没有 example 的那就苦逼自己慢慢摸索了</p><blockquote><p><strong>做测试没关系，毕竟怎么样都能够学到不一样的知识。</strong></p></blockquote><p>先说下这次测试的内容，就是将之前标注好的数据，利用我们的模块重新跑一遍，检验是否有错漏的地方。这上面说的简单，但其中含杂了大量的人工，这我可不干，所以才有了这一篇文章。</p><h4 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h4><p>404页面错误检验模块（基于 URL 和 Content 两部分），编写爬虫将标注好的数据中 URL 所对应的页面存储于本地（csv文件）</p><h4 id="人工方法"><a href="#人工方法" class="headerlink" title="人工方法"></a>人工方法</h4><p>如果按照人工方法走，就是针对于一个 URL 创建一个 HTML 文件，然后撰写一个测试用例，跑通了我们就往下走，没跑通那就回头重新梳理逻辑。这种方式如果针对于一两个文件还好说，那如果针对于上百个文件那怎么办？如果这还人工一个个弄，那算你厉害</p><h4 id="自动化方法"><a href="#自动化方法" class="headerlink" title="自动化方法"></a>自动化方法</h4><p>自动化方法是否能够运用在于在这过程当中是否存在一定的规律，相信读到这里的我们，可以明白自动化的方法就是在若干个循环当中，重复操作人工的方法，只是在这个过程当中，你需要用代码来证明你的想法，而非你的汗水</p><p>在材料准备中，我们已经有了包含测试数据的 csv 文件，可能读者会理所当然的认为这个自动化测试不就两行代码妥妥的就搞定吗？其实并不然，c++ 中并没有什么第三方库处理 csv 这样的文件（反正我是没找到），如果利用简单的<code>split</code>函数的话，那就会导致原有数据（HTML）的丢失。</p><p>这个时候，我们需要转向文件流，即将若干个 HTML 文件存储下来，并创建一个索引表，记录 URL 与其对应的文件名，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">~/htmls/</div><div class="line">0.html 1.html 2.html index.txt</div><div class="line"></div><div class="line">~/htmls/index.txt</div><div class="line">https://www.baidu.com 0.html</div><div class="line">https://www.taobao.com 1.html</div></pre></td></tr></table></figure><p>然后在实际编写代码过程中，先读取索引表，再利用索引表的信息，读取 HTML 文件然后运行模块，记录运行结果，当所有测试用例结束时，统计最终结果，并根据最终结果，调整内部的策略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两天在对我们开发的模块进行最后的收尾，收尾的工作一般来说都是添加测试用例，测试模块调用时是否有 BUG 等。果不其然，老大还是叫我去做模块的测试。其实还是自己对于 C++了解太少，刚入门一个星期才勉强能够看懂之前的部分源码，而且原有工程十分庞大，还有自己封装好的又或自己开
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>有多少人工就有多少智能</title>
    <link href="http://apparition957.github.io/2018/04/19/%E6%9C%89%E5%A4%9A%E5%B0%91%E4%BA%BA%E5%B7%A5%E5%B0%B1%E6%9C%89%E5%A4%9A%E5%B0%91%E6%99%BA%E8%83%BD/"/>
    <id>http://apparition957.github.io/2018/04/19/有多少人工就有多少智能/</id>
    <published>2018-04-19T15:04:25.000Z</published>
    <updated>2018-04-19T15:04:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个标题其实是来自于<a href="https://blog.csdn.net/dQCFKyQDXYm3F8rB0/article/details/79933707" target="_blank" rel="external">小米小爱团队负责人王刚：语音交互背后，有多少人工就有多少智能</a>这篇文章，虽然我现在的工作与人工智能没关系，但是与我现在的经历息息相关的。</p><p>最近在跟着老大去做页面分析的模块，现阶段有个问题在于怎么去解决网页软404问题。可行的解决方案当然有很多，HTTP 请求码、URL 的正则匹配、内容关键字匹配等。但是这么多的解决方案都需要的一个判断标准，判断跑出来的数据可不可靠，如果不可靠的话那么这个方案可能就行不通。</p><p>那么比较尴尬的部分来了，这个判断的过程是由人工来的，那这个活自然就落在我和其他同事身上啦。虽然知道这个是必然的过程，但是心还是不甘的，不甘于自己要去做人工筛选工作。</p><p><img src="http://on83riher.bkt.clouddn.com/WechatIMG128.jpeg" alt="工作成果"></p><p>其实单单抛弃人工智能这个前提，<strong>“有多少人工就有多少智能”</strong>这句话适用于互联网的各个领域，只要能够投入了足够的人力，那么系统的未来也会有很大的改善，以上是我现阶段的看法。</p><p>经历了这次人工筛选的活后，我还从这句话体会到了一点，<strong>努力提升自己的技术，别让自己成为可取代的人工。</strong>加深自己的技术栈吧，再经历多点磨难，或许能够看见更多未来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个标题其实是来自于&lt;a href=&quot;https://blog.csdn.net/dQCFKyQDXYm3F8rB0/article/details/79933707&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;小米小爱团队负责人王刚：语音交互背后，有多
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spark - take() 算子</title>
    <link href="http://apparition957.github.io/2018/04/14/Spark%20-%20take()%20%E7%AE%97%E5%AD%90/"/>
    <id>http://apparition957.github.io/2018/04/14/Spark - take() 算子/</id>
    <published>2018-04-14T05:41:00.000Z</published>
    <updated>2018-04-14T05:41:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以后遇到不懂的 Spark 算子的话，我都尽可能以笔记的方式去记录它</p></blockquote><h3 id="遇到的情况"><a href="#遇到的情况" class="headerlink" title="遇到的情况"></a>遇到的情况</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rdd.map(...) <span class="comment">// 重要前提：数据量在 TB 级别</span></div><div class="line">   .filter(...)  <span class="comment">// 根据某些条件筛选数据</span></div><div class="line">   .take(<span class="number">100000</span>) <span class="comment">// 取当前数据的前十万条</span></div></pre></td></tr></table></figure><p>当时的程序大致就是这样，我的想法是根据<code>filter()</code>之后的数据直接利用<code>take()</code>拿前十万的数据，感觉方便又省事，但是实际的运行情况却是作业的运行时间很长，让人怀疑人生。而且<code>take()</code>一开始默认的分区是1，而后如果当前任务失败的话，会适当的扩增分区数来读取更多的数据。</p><p><img src="http://on83riher.bkt.clouddn.com/take%20%E7%AE%97%E5%AD%90%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5.png" alt=""></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>废话不多，先贴源码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">  * Take the first num elements of the RDD. It works by first scanning one partition, and use the results from that partition to estimate the number of additional partitions needed to satisfy the limit.</span></div><div class="line"><span class="comment">  *</span></div><div class="line"><span class="comment">  * @note This method should only be used if the resulting array is expected to be small, as all the data is loaded into the driver's memory.</span></div><div class="line"><span class="comment">  * 此方法被使用时期望目标数组的大小比较小，即其数组中所有数据都能够存储在 driver 的内存当中。这里的函数解释当中提及到了处理的数据量应当较小，但是没说如果处理了比较大的数据时会怎么样，还得看看继续往下看</span></div><div class="line"><span class="comment">  *</span></div><div class="line"><span class="comment">  * @note Due to complications in the internal implementation, this method will raise</span></div><div class="line"><span class="comment">  * an exception if called on an RDD of `Nothing` or `Null`.</span></div><div class="line"><span class="comment">  */</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">take</span></span>(num: <span class="type">Int</span>): <span class="type">Array</span>[<span class="type">T</span>] = withScope &#123;</div><div class="line">  <span class="comment">// scaleUpFactor 字面意思是扩增因子，看到这里我们可以结合上图的例子，不难看出分区的扩增是按照一定的倍数增长的</span></div><div class="line">  <span class="keyword">val</span> scaleUpFactor = <span class="type">Math</span>.max(conf.getInt(<span class="string">"spark.rdd.limit.scaleUpFactor"</span>, <span class="number">4</span>), <span class="number">2</span>)</div><div class="line">  <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">T</span>](<span class="number">0</span>)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">val</span> buf = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">T</span>]</div><div class="line">    <span class="keyword">val</span> totalParts = <span class="keyword">this</span>.partitions.length</div><div class="line">    <span class="keyword">var</span> partsScanned = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="comment">// 这个循环是为什么 take 失败会进行重试的关键</span></div><div class="line">    <span class="keyword">while</span> (buf.size &lt; num &amp;&amp; partsScanned &lt; totalParts) &#123;</div><div class="line">      <span class="comment">// The number of partitions to try in this iteration. It is ok for this number to be</span></div><div class="line">      <span class="comment">// greater than totalParts because we actually cap it at totalParts in runJob.</span></div><div class="line">      <span class="comment">// numPartsToTry - 此次循环迭代的分区个数，默认为1。</span></div><div class="line">      <span class="keyword">var</span> numPartsToTry = <span class="number">1</span>L</div><div class="line">      <span class="keyword">val</span> left = num - buf.size</div><div class="line">      <span class="keyword">if</span> (partsScanned &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// If we didn't find any rows after the previous iteration, quadruple and retry.</span></div><div class="line">        <span class="comment">// Otherwise, interpolate the number of partitions we need to try, but overestimate</span></div><div class="line">        <span class="comment">// it by 50%. We also cap the estimation in the end.</span></div><div class="line">        <span class="comment">// 重点！当在上一次迭代当中，我们没有找到任何满足条件的 row 时(至少是不满足指定数量时)，有规律的重试(quadruple and retry，翻译水平有限)</span></div><div class="line">        <span class="keyword">if</span> (buf.isEmpty) &#123;</div><div class="line">          numPartsToTry = partsScanned * scaleUpFactor</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// As left &gt; 0, numPartsToTry is always &gt;= 1</span></div><div class="line">          numPartsToTry = <span class="type">Math</span>.ceil(<span class="number">1.5</span> * left * partsScanned / buf.size).toInt</div><div class="line">          numPartsToTry = <span class="type">Math</span>.min(numPartsToTry, partsScanned * scaleUpFactor)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">val</span> p = partsScanned.until(math.min(partsScanned + numPartsToTry, totalParts).toInt)</div><div class="line">      <span class="keyword">val</span> res = sc.runJob(<span class="keyword">this</span>, (it: <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; it.take(left).toArray, p)</div><div class="line"></div><div class="line">      <span class="comment">// 每一次循环迭代都会获取新的数据加到 buf 当中，所以并不是每一次重试都是从头对数据进行遍历，那这样会没完没了</span></div><div class="line">      res.foreach(buf ++= _.take(num - buf.size))</div><div class="line">      partsScanned += p.size</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这里才是我们最终的结果</span></div><div class="line">    buf.toArray</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>take()</code>算子使用的场景是当数据量规模较小的情况，亦或者说搭配<code>filter()</code>时，<code>filter()</code>能够较快的筛选出数据来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;以后遇到不懂的 Spark 算子的话，我都尽可能以笔记的方式去记录它&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;遇到的情况&quot;&gt;&lt;a href=&quot;#遇到的情况&quot; class=&quot;headerlink&quot; title=&quot;遇到的情况&quot;&gt;&lt;/a&gt;遇到
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spark - 由 foreach 引发的思考</title>
    <link href="http://apparition957.github.io/2018/04/01/Spark%20-%20%E7%94%B1%20foreach%20%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://apparition957.github.io/2018/04/01/Spark - 由 foreach 引发的思考/</id>
    <published>2018-03-31T17:34:32.000Z</published>
    <updated>2018-03-31T17:34:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>废话不说，先贴代码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> numbers = sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>))</div><div class="line"><span class="keyword">val</span> map = scala.collection.mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Int</span>]()</div><div class="line"></div><div class="line">numbers.foreach(l =&gt; &#123;map.put(l,l)&#125;)</div><div class="line">println(map.size) <span class="comment">// 此时 map 的存储了几个键值对</span></div></pre></td></tr></table></figure><hr><p>首先我们先说个概念 —— <strong>闭包</strong></p><p>闭包是 Scala 中的特性，用通俗易懂的话讲就是函数内部的运算或者说函数返回值可由外部的变量所控制，用个例子解释就是：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> factor = <span class="number">10</span></div><div class="line"><span class="comment">// multiplier 函数的返回值有有两个决定因素，输入参数变量 i 以及外部变量 factor。输入参数变量 i 是由我们调用该函数时决定的，相较于 factor 是可控的，而 factor 则是外部变量所定义，相较于 i 是不可控的</span></div><div class="line"><span class="keyword">val</span> multiplier = (i: <span class="type">Int</span>) =&gt; i * factor </div><div class="line">println(multiplier(<span class="number">1</span>)) <span class="comment">// 10</span></div><div class="line"></div><div class="line">factor = <span class="number">20</span></div><div class="line">println(multiplier(<span class="number">1</span>)) <span class="comment">// 20</span></div></pre></td></tr></table></figure><p>根据上述提及的闭包可知，刚才所写的代码中<code>l =&gt; {map.put(1,1)}</code>其所定义的函数就是一个闭包</p><hr><p>既然标题中提到了 Spark，那就要说明闭包与 Spark 的关系了</p><p>在 Spark 中，用户自定义闭包函数并传递给相应的 RDD 所定义好的方法（如<code>foreach</code>、<code>map</code>）。<strong>Spark 在运行作业时会检查 DAG 中每个 RDD 所涉及的闭包，如是否可序列化、是否引用外部变量等。若存在引用外部变量的情况，则会将它们的副本复制到相应的工作节点上，保证程序运行的一致性</strong></p><blockquote><p>下面是 Spark 文档中解释的：</p><h3 id="Shared-Variables"><a href="#Shared-Variables" class="headerlink" title="Shared Variables"></a>Shared Variables</h3><p>Normally, when a function passed to a Spark operation (such as <code>map</code> or <code>reduce</code>) is executed on a remote cluster node, it works on separate copies of all the variables used in the function. These variables are copied to each machine, and no updates to the variables on the remote machine are propagated back to the driver program. Supporting general, read-write shared variables across tasks would be inefficient. However, Spark does provide two limited types of <em>shared variables</em> for two common usage patterns: broadcast variables and accumulators.</p><h3 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h3><p>通常情况下，当有函数传递给在远端集群节点上执行的 Spark 的算子（如<code>map</code>或<code>reduce</code>）时，Spark 会将所有在该函数内部所需要的用到的变量分别复制到相应的节点上。这些副本变量会被复制到每个节点上，且在算子执行结束后这些变量并不会回传给驱动程序（driver program）。</p><p>Normally, when a function passed to a Spark operation (such as <code>map</code> or <code>reduce</code>) is executed on a remote cluster node, it works on separate copies of all the variables used in the function. These variables are copied to each machine, and no updates to the variables on the remote machine are propagated back to the driver program. </p></blockquote><hr><p>总结，如果直接运行一开始所提及的程序时，那么所获得的答案是0，因为我们知道<code>map</code>变量会被拷贝多份至不同的工作节点上，而我们操作的也仅仅只是副本罢了</p><p>从编译器的角度来说，这段代码是一个闭包函数，而其调用了外部变量，代码上没问题。但是从运行结果中，这是错误操作方式，因为 Spark 会将其所调用的外部变量进行拷贝，并复制到相应的工作节点中，而不会对真正的变量产生任何影响</p><p>相应的解决方案有</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> numbers = sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>))</div><div class="line"><span class="keyword">val</span> map = scala.collection.mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Int</span>]()</div><div class="line"></div><div class="line">numbers.collect().foreach(l =&gt; &#123;map.put(l,l)&#125;)</div><div class="line">println(map.size)</div></pre></td></tr></table></figure><hr><p>参考资料：</p><ol><li><a href="http://spark.apache.org/docs/2.1.0/programming-guide.html#shared-variables" target="_blank" rel="external">http://spark.apache.org/docs/2.1.0/programming-guide.html#shared-variables</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;废话不说，先贴代码&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>列式存储 - HBase vs Parquet</title>
    <link href="http://apparition957.github.io/2018/03/24/%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8%20-%20HBase%20vs%20Parquet/"/>
    <id>http://apparition957.github.io/2018/03/24/列式存储 - HBase vs Parquet/</id>
    <published>2018-03-24T07:05:48.000Z</published>
    <updated>2018-03-24T07:06:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>虽然两者在使用场景上没有可比性，HBase 是非关系型数据库，而 Parquet 是数据存储格式，但是两者却存在相似的概念——列式存储。我在了解 Parquet 的时候，因为列式存储这个概念与 HBase 混淆时，所以特意坐下笔记，记录两者的区别</p></blockquote><p>让我们直入正题，什么是列式存储？相比行式存储又有什么优势呢？</p><p><img src="http://on83riher.bkt.clouddn.com/%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%A1%8C%E5%BC%8F%E5%AD%98%E5%82%A8%20%E5%AF%B9%E6%AF%94%E5%9B%BE.png" alt=""></p><blockquote><p>图源来自 <a href="http://zhuanlan.51cto.com/art/201703/535729.htm" target="_blank" rel="external">http://zhuanlan.51cto.com/art/201703/535729.htm</a></p></blockquote><hr><p>首选先从 HBase 开始讲述。HBase是一个分布式的、面向列的非关系型数据库。它的架构设计如下：</p><p><img src="http://on83riher.bkt.clouddn.com/HBase%20%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt=""></p><p>简单说明一下：</p><ul><li>HMaster：HBase 主/从架构的主节点。通常在一个 HBase 集群中允许存在多个 HMaster 节点，其中一个节点被选举为 Active Master，而剩余节点为 Backup Master。其主要作用在于：<ul><li>管理和分配 HRegionServer 中的 Region</li><li>管理 HRegionServer 的负载均衡</li></ul></li><li>HRegionServer：HBase 主/从架构的从节点。主要负责响应 Client 端的 I/O 请求，并向底层文件存储系统 HDFS 中读写数据</li><li>HRegion：HBase 通过表中的 RowKey 将表进行水平切割后，会生成多个 HRegion。每个 HRegion 都会被安排到 HRegionServer 中</li><li>Store：每一个 HRegion 有一个或多个 Store 组成，Store 相对应表中的 Column Family（列族）。每个 Store 都由一个 MemStore 以及多个 StoreFile 组成</li><li>MemStore：MemStore 是一块内存区域，其将 Client 对 Store 的所有操作进行存储，并到达一定的阈值时会进行 flush 操作</li><li>StoreFile：MemStore 中的数据写入文件后就成为了 StoreFile，而 StoreFile 底层是以 HFile 为存储格式进行保存的</li><li>HFile：HBase 中 Key-Value 数据的存储格式，是 Hadoop 的二进制文件。其中 Key-Value 的格式为（Table, RowKey, Family, Qualifier, Timestamp）- Value</li></ul><p>HBase 的主要读写方式可以通过以下流程进行：</p><p><img src="http://on83riher.bkt.clouddn.com/HBase%20%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.png" alt=""></p><p>可以从上述的架构讲述看出，HBase 并非严格意义上的列式存储，而是基于“列族”存储的，所以其是列族的角度进行列式存储。</p><hr><p>Parquet 是面向分析型业务的列式存储格式，其不与某一特定语言绑定，也不与任何一种数据处理框架绑定在一起，其性质类似于 JSON。</p><p>Parquet 相较于 HBase 对数据的处理方式，其将数据当做成一种嵌套数据的模型，并将其结构定义为 schema。每一个数据模型的 schema 包含多个字段，而每个字段又可以包含多个字段。每一字段都有三个属性：repetition、type 和 name，其中 repetition 可以是以下三种：required（出现1次）、optional（出现0次或1次）、repeated（出现0次或多次），而 type 可以是 group（嵌套类型）或者是 primitive（原生类型）。</p><p>举一个典型的例子：</p><p><img src="http://on83riher.bkt.clouddn.com/Parquet%20%E4%BE%8B%E5%AD%90.png" alt=""></p><p>在 Parquet 格式的存储当中，一个 schema 的树结构有几个叶子节点，在实际存储中就有多少个 column。例如上面 schema 的数据存储实际上有四个 column，如下所示：</p><p><img src="http://on83riher.bkt.clouddn.com/Parquet%20%E4%BE%8B%E5%AD%902.png" alt=""></p><p>从上面的图看来，与 HBase 好像没有什么区别，但这只是为了让用户更好的了解数据才这样表示，其内部实现的机制与 HBase 完全不同，而且 Parquet 是真正的基于列式存储。其能够进行列式存储归功于 Striping/Assembly 算法。</p><p>算法我就不详细说了，<a href="http://www.infoq.com/cn/articles/in-depth-analysis-of-parquet-column-storage-format" target="_blank" rel="external">这篇文章</a>讲的很详细，我就不献丑了。</p><hr><p>参考资料：</p><ol><li>HBase 权威指南</li><li><a href="http://blog.javachen.com/2013/06/15/hbase-note-about-data-structure.html" target="_blank" rel="external">HBase笔记：存储结构</a></li><li><a href="http://www.infoq.com/cn/articles/in-depth-analysis-of-parquet-column-storage-format" target="_blank" rel="external">深入分析Parquet列式存储格式</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;虽然两者在使用场景上没有可比性，HBase 是非关系型数据库，而 Parquet 是数据存储格式，但是两者却存在相似的概念——列式存储。我在了解 Parquet 的时候，因为列式存储这个概念与 HBase 混淆时，所以特意坐下笔记，记录两者的区别&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala - identity() 函数</title>
    <link href="http://apparition957.github.io/2018/03/19/Scala%20-%20identity()%20%E5%87%BD%E6%95%B0/"/>
    <id>http://apparition957.github.io/2018/03/19/Scala - identity() 函数/</id>
    <published>2018-03-19T12:51:59.000Z</published>
    <updated>2018-03-19T12:52:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写 Spark 作业的时候，使用到了 <code>groupBy</code>和<code>sortBy</code>，在查找文档的时候，发现有的文档中的代码有着<code>groupBy(identity)</code>这样奇怪的写法。</p><p>在 Scala 文档中，<a href="http://www.scala-lang.org/api/current/scala/Predef$.html#identityA:A" target="_blank" rel="external">identity 函数</a>的作用就是将传入的参数“直接”当做返回值回传给调用者，这在正常使用中，可以说是毫无作用，但他在<code>groupBy</code>和<code>sortBy</code>等函数中的作用，在于避免程序员书写相同且容易出错的逻辑，原因如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 前提条件：</span></div><div class="line"><span class="keyword">val</span> array = <span class="type">Array</span>(<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">// 统计 array 中每个元素出现的次数</span></div><div class="line"><span class="comment">// 正常逻辑：</span></div><div class="line">array.groupBy(n =&gt; n)</div><div class="line"><span class="comment">// scala.collection.immutable.Map[Int,Array[Int]] = Map(5 -&gt; Array(5), 1 -&gt; Array(1, 1), 6 -&gt; Array(6), 9 -&gt; Array(9, 9), 2 -&gt; Array(2, 2), 7 -&gt; Array(7), 3 -&gt; Array(3), 4 -&gt; Array(4))</span></div><div class="line"></div><div class="line"><span class="comment">// 使用 identity</span></div><div class="line">array.groupBy(identity)</div><div class="line"></div><div class="line"><span class="comment">// 将 array 进行排序(升序)</span></div><div class="line"><span class="comment">// 正常逻辑：</span></div><div class="line">array.sortBy(n =&gt; n)</div><div class="line"><span class="comment">// Array[Int] = Array(1, 1, 2, 2, 3, 4, 5, 6, 7, 9, 9)</span></div><div class="line"></div><div class="line"><span class="comment">// 使用 identity 或者简化版本</span></div><div class="line">array.sortBy(identity)</div><div class="line">array.sorted</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在写 Spark 作业的时候，使用到了 &lt;code&gt;groupBy&lt;/code&gt;和&lt;code&gt;sortBy&lt;/code&gt;，在查找文档的时候，发现有的文档中的代码有着&lt;code&gt;groupBy(identity)&lt;/code&gt;这样奇怪的写法。&lt;/p&gt;
&lt;p&gt;在 Scala
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式爬虫架构</title>
    <link href="http://apparition957.github.io/2018/03/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E6%9E%B6%E6%9E%84/"/>
    <id>http://apparition957.github.io/2018/03/06/分布式爬虫架构/</id>
    <published>2018-03-06T14:53:55.000Z</published>
    <updated>2018-03-06T14:54:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近突然对爬虫框架很感兴趣，但一直无奈于没有服务器能让我捣鼓捣鼓，所以脑子就一直想如何去设计这个框架。翻了很多篇资料，总结了挺多经验，然后就画了下面这张架构图。个人认为很不成熟，但毕竟也是一种想法。希望能力提升后能够想到更加全面完善的架构。</p><p><img src="http://on83riher.bkt.clouddn.com/%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E6%9E%B6%E6%9E%84.png" alt="分布式爬虫架构"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近突然对爬虫框架很感兴趣，但一直无奈于没有服务器能让我捣鼓捣鼓，所以脑子就一直想如何去设计这个框架。翻了很多篇资料，总结了挺多经验，然后就画了下面这张架构图。个人认为很不成熟，但毕竟也是一种想法。希望能力提升后能够想到更加全面完善的架构。&lt;/p&gt;
&lt;p&gt;&lt;img src=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大三上学期总结</title>
    <link href="http://apparition957.github.io/2018/01/22/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    <id>http://apparition957.github.io/2018/01/22/大三上学期总结/</id>
    <published>2018-01-22T14:30:09.000Z</published>
    <updated>2018-01-22T14:30:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>今天是周一（2018/01/22），是我正式作为小米实习生的第一天，也是我第一次远离熟悉的地方来到北京闯荡。</strong>经历过这学期磨人的课程后，经历过让人背书背的头大的毛概后，经历过曾经一度让人绝望的面试后，经历过令人心寒的租房后，终于可以安下心来好好写我的学期总结。</p><p>下面我就这学期的比较重要的方向进行总结吧。</p><ul><li><strong>学习</strong></li></ul><p>这学期课程真的比以往的多，几乎每天都要上至少两节课，甚至还得上整天，真让人疲惫不堪，但是真正觉得心累的，还是宿舍的氛围，还是像大二那样过一天是一天，不到找工作/临近考试的时候不会去努力。这学期我就尝试着每晚都去图书馆，但是就算是十点半回到宿舍还是无法得到一片宁静，因为十点半的时候，有个宿友准点吃鸡，而且很吵，吵到连看美剧都没心情。当时也怪自己没肯直说吧，暂时不说了，不想开始就写一长篇的抱怨。</p><p>虽然这学期很累，但是过得也算充实，毕竟我认清自己的学习方向了，之前在大二中我接触的是Web开发，偏向于云计算/微服务方面，但是每次接触的工程都只是学习工具，学习如何使用，然后反复造轮子，跟着规整的MVC架构来搭建项目，我对这一过程心生厌恶，觉得自己不能这样。于是乎我寻找了另一个兴趣点——大数据进行学习。大数据既是现在的热点，也是我最感兴趣的地方，每次都能借好多书走，学习到很多新的内容，新的架构。</p><p>这也是为什么我在找岗位的时候，想要寻找大数据方面的职位，一是充实自己，提高技能；二是在实际开发工程中，切身体会到如何真正的运用大数据来进行对数据分析。</p><ul><li><strong>简历</strong></li></ul><p>当初写简历的时候觉得还很自信，秉持着简约的风格的简历外加上整齐规格的排版，一定能够在一月份前拿到一份心满意足的offer。经历过整整三个星期都没有一通面试电话时，我真的很绝望，发自心底的绝望，认为这三年学的东西是不是白学了。后来经过很多同学的指点过后，<strong>我才发现一份简约的简历，要遵循以下几个点：</strong></p><ul><li>只能是一页纸，不能够再多</li><li>只写有用的话（姓名，联系电话，工作/校园经历）</li><li>排版要规整，粗细得体</li></ul><p>在这里真的要讲一句真心话，在正式修改了简历后，过没两天实习僧上的公司就真的给我面试电话通知了，而且后面陆陆续续也来了不少电话。</p><ul><li><strong>租房（注意粗体部分）</strong></li></ul><p>租房是个出来漂的首要大事啊，自从拿到offer后我就投入了租房这件事了，但是租房并不像想象中那么容易（除非你运气真的超级超级棒）。<strong>既要小心租房中遇到的中介/二房东/代理，还要小心合同中会不会收取额外的费用（中介费/物业管理费/燃气费/服务费），更要小心同住的人是否有良好的习惯。</strong>我几乎每晚回到宿舍都要花上二十分钟到半个小时，<strong>途径有豆瓣/自如（等各大互联网租房平台）/闲鱼/暖房（自动爬虫机制的网站，感觉还行）</strong>，其中遇到了有让人觉得恶心的中介，也遇到了聊得上天的转租大哥，但是由于自己不在北京的缘故，无法确切的看到实际房子的状况，所以一直犹豫着要不要直接租房（实际原因是没看到让人一眼看中的房子，或者碍于价格太高了）。</p><p>出于以上原因，我决定了考完试后联系好之前找好的中介/转租房东一一探寻房子。当时我是提前购买了凌晨到北京的机票，打算在机场中睡一觉就赶过去，所以我就在前一天晚上急忙去联系人预约看房，等到凌晨6点时就赶了过去，从西二旗地铁口出发后，暴走3公里后到达下榻酒店（暴走的原因是因为<strong>要亲自熟悉周边的环境，才好对房子进行更加深刻的评估</strong>），放下行李就跟着中介出去跑了。</p><p>真的是比较幸运，在早上十点钟时，中介带我找到了一个不错的房子，房子空间很大，内部装饰还行，价格中等偏上（相当于拿出一半的实习工资还多）。自己当时就想下定决心去签合同，不过出于谨慎，还是与家里人详细沟通了一下。在得到家里人的赞成后，我当时就和中介签的合同了（还是很<strong>比较谨慎的，看了好多回合同才肯签字，生怕有什么坑自己没注意</strong>）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;今天是周一（2018/01/22），是我正式作为小米实习生的第一天，也是我第一次远离熟悉的地方来到北京闯荡。&lt;/strong&gt;经历过这学期磨人的课程后，经历过让人背书背的头大的毛概后，经历过曾经一度让人绝望的面试后，经历过令人心寒的租房后，终于可以安下心来好
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊聊log4j</title>
    <link href="http://apparition957.github.io/2017/11/27/%E8%81%8A%E8%81%8Alog4j/"/>
    <id>http://apparition957.github.io/2017/11/27/聊聊log4j/</id>
    <published>2017-11-27T06:53:55.000Z</published>
    <updated>2017-11-27T07:03:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><blockquote><p>最近在学习 Zookeeper 的时候，遇到了不少问题，想要在控制台中查看日志但是记录却死活不显示，于是找到了 /etc/zookeeper/log4j.properties 文件，但发现配置选项看不懂，想到之前在写 Web 应用的时候也是拿来就用，都没涉及到日志配置文件这一层面，所以打算整理一番。</p></blockquote><p>log4j 是一个用 Java 编写的可靠，快速和灵活的日志框架（API），它在 Apache 软件许可下发布。log4j 是高度可配置的，并可通过在运行时的外部文件配置。它根据记录的优先级别，并提供机制，以指示记录信息到许多的目的地，诸如：数据库，文件，控制台，UNIX 系统日志等。</p><h2 id="与-slf4j-的关系"><a href="#与-slf4j-的关系" class="headerlink" title="与 slf4j 的关系"></a>与 slf4j 的关系</h2><p>在实际开发当中，常常有人提醒我们，要使用 slf4j 来记录日志，为什么呢？</p><p>下面是 sl4fj 官网的介绍。</p><blockquote><p>The Simple Logging Facade for Java (SLF4J) serves as a simple facade or abstraction for various logging frameworks (e.g. java.util.logging, logback, log4j) allowing the end user to plug in the desired logging framework at deployment time.</p></blockquote><p>slf4j（Simple Logging Facade For Java，Java 简易日志门面）是一套封装 Logging 框架的抽象层，而 log4j 是 slf4j 下一个具体实现的日志框架，其中还有许许多多的成熟的日志框架，如 logback 等，也是从属于 slf4j。</p><p>使用 slf4j 可以在应用层中屏蔽底层的日志框架，而不需理会过多的日志配置、管理等操作。</p><h2 id="如何配置"><a href="#如何配置" class="headerlink" title="如何配置"></a>如何配置</h2><p>log4j 配置文件的基本格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#配置根Logger</div><div class="line">log4j.rootLogger = [level], appenderName1, appenderName2, ...</div><div class="line"></div><div class="line">#配置日志信息输出目的地 Appender</div><div class="line">log4j.appender.appenderName = fully.qualified.name.of.appender.class </div><div class="line">log4j.appender.appenderName.option1 = value1 </div><div class="line">log4j.appender.appenderName.optionN = valueN </div><div class="line"></div><div class="line">#配置日志信息的格式（布局）</div><div class="line">log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class</div><div class="line">log4j.appender.appenderName.layout.option1 = value1 </div><div class="line">log4j.appender.appenderName.layout.optionN = valueN</div></pre></td></tr></table></figure><p>其中：</p><ul><li>[level] - 日志输出级别，可分为以下级别（级别程度从上到下递增）：</li></ul><table><thead><tr><th>级别</th><th>描述</th></tr></thead><tbody><tr><td><strong>ALL</strong></td><td>所有级别，包括定制级别。</td></tr><tr><td><strong>TRACE</strong></td><td>比 DEBUG 级别的粒度更细。</td></tr><tr><td><strong>DEBUG</strong></td><td>指明细致的事件信息，对调试应用最有用。</td></tr><tr><td><strong>INFO</strong></td><td>指明描述信息，从粗粒度上描述了应用运行过程。</td></tr><tr><td><strong>WARN</strong></td><td>指明潜在的有害状况。</td></tr><tr><td><strong>ERROR</strong></td><td>指明错误事件，但应用可能还能继续运行。</td></tr><tr><td><strong>FATAL</strong></td><td>指明非常严重的错误事件，可能会导致应用终止执行。</td></tr><tr><td><strong>OFF</strong></td><td>最高级别，用于关闭日志。</td></tr></tbody></table><ul><li>Appender - 日志输出目的地，常用的 Appender 有以下几种：</li></ul><table><thead><tr><th>Appender</th><th>作用</th></tr></thead><tbody><tr><td><strong>org.apache.log4j.ConsoleAppender</strong></td><td>输出至控制台</td></tr><tr><td><strong>org.apache.log4j.FileAppender</strong></td><td>输出至文件</td></tr><tr><td><strong>org.apache.log4j.DailyRollingFileAppender</strong></td><td>每天产生一个日志文件</td></tr><tr><td><strong>org.apache.log4j.RollingFileAppender</strong></td><td>文件容量到达指定大小时产生一个新的文件</td></tr><tr><td><strong>org.apache.log4j.WriterAppender</strong></td><td>将日志信息以输出流格式发送到任意指定地方</td></tr></tbody></table><ul><li>Layout - 日志输出格式，常用的 Layout 有以下几种：</li></ul><table><thead><tr><th>Layout</th><th>作用</th></tr></thead><tbody><tr><td><strong>org.apache.log4j.HTMLLayout</strong></td><td>以 HTML 表格形式布局</td></tr><tr><td><strong>org.apache.log4j.PatternLauout</strong>（常用）</td><td>以格式化的方式定制布局</td></tr><tr><td><strong>org.apache.log4j.SimpleLayout</strong></td><td>包含日志信息的级别和信息字符串</td></tr><tr><td><strong>org.apache.log4j.TTCCLayout</strong></td><td>包含日志所在线程、产生时间、类名和日志内容等</td></tr></tbody></table><ul><li>打印参数（格式化输出格式，一般对应于 org.apache.log4j.PatternLauout）</li></ul><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><strong>%m</strong></td><td>输出代码中指定的消息</td></tr><tr><td><strong>%p</strong></td><td>输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL</td></tr><tr><td><strong>%r</strong></td><td>输出自应用启动到输出该log信息耗费的毫秒数</td></tr><tr><td><strong>%c</strong></td><td>输出所属的类目，通常就是所在类的全名。%c{1} 可取当前类名称</td></tr><tr><td><strong>%t</strong></td><td>输出产生该日志事件的线程名</td></tr><tr><td><strong>%n </strong></td><td>输出一个回车换行符，Windows平台为“\r\n”，Unix平台为“\n”</td></tr><tr><td><strong>%d</strong></td><td>输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式。标准格式为 %d{yyyy-MM-dd HH:mm:ss}</td></tr><tr><td><strong>%l </strong></td><td>输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。</td></tr></tbody></table><ul><li>option - 可选配置。一般来说每个 Appender 或者 Layout 都有默认配置，用户使用自定义日志配置，如指定输出地点等。常用的 option 有以下几种：</li></ul><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><strong>file</strong></td><td>日志输出至指定文件</td></tr><tr><td><strong>thresold</strong></td><td>定制日志消息的输出在不同 level 时的行为，</td></tr><tr><td><strong>append</strong></td><td>是否追加至日志文件中</td></tr></tbody></table><hr><p>参考资料：</p><p><a href="http://wiki.jikexueyuan.com/project/log4j/overview.html" target="_blank" rel="external">Log4J 教程 - 极客学院</a></p><p><a href="http://www.cnblogs.com/ITEagle/archive/2010/04/23/1718365.html" target="_blank" rel="external">log4j.properties配置详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最近在学习 Zookeeper 的时候，遇到了不少问题，想要在控制台中查看日志但是记录却死活不显示，于是找到了 /
      
    
    </summary>
    
    
      <category term="log4j" scheme="http://apparition957.github.io/tags/log4j/"/>
    
  </entry>
  
</feed>
