<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>APPARITION957</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://apparition957.github.io/"/>
  <updated>2018-11-12T09:31:01.000Z</updated>
  <id>http://apparition957.github.io/</id>
  
  <author>
    <name>jianpeng957</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>出门走走-贵州岑巩县</title>
    <link href="http://apparition957.github.io/2018/11/12/%E5%87%BA%E9%97%A8%E8%B5%B0%E8%B5%B0-%E8%B4%B5%E5%B7%9E%E5%B2%91%E5%B7%A9%E5%8E%BF/"/>
    <id>http://apparition957.github.io/2018/11/12/出门走走-贵州岑巩县/</id>
    <published>2018-11-12T08:16:05.000Z</published>
    <updated>2018-11-12T09:31:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上周参加了学校组织的扶贫活动，地点位于贵州岑巩县。并不是因为偷懒没写技术博客才去的呀：）</p></blockquote><h2 id="做了什么"><a href="#做了什么" class="headerlink" title="做了什么"></a>做了什么</h2><p>这次扶贫活动的主要是帮助各乡镇进行贫困户的信息录入工作，减少一些他们的工作量，以我前去的平庄镇而言，乡镇的人口基数相较于其他乡镇而言还算比较大的，外加上镇上的干部数量比较少，所以信息录入工作基本就是由一人负责，工作量大而繁琐。</p><p>额外说下的是，因为需要在2021年要达到“两个一百年”中第一个一百年的目标，不知从几年前开始，我所在的镇上所有干部就基本上过着加班的日子，隔三差五就有一个会议要开。值班的日子是以两周为间隔，也就是说至少需要值班两周才能够回家休息这样的一个状态。在平常的时候还需要经常下乡对每家每户进行调研统计，方便后期对各贫困户实施不同的扶贫措施。</p><p><strong>真的感谢你们的辛苦工作！</strong></p><h2 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h2><p>跟同学一起进行贫困户信息录入的这段时间中，我接触了不少致贫原因各不相同的家庭，总结下自己的一些感触吧。</p><h3 id="补助"><a href="#补助" class="headerlink" title="补助"></a>补助</h3><p>在个人收入中，可分为工资性收入、生产性经营收入和各项补助。若家庭中有患有重病或者残疾的人的话，前两项收入往往是较少的，更主要是通过补助的方式维持生活，而各项补助总和的金额却是较少的（1k-10k 浮动）。</p><p>虽然较偏远地区的生活水平较低，但我真的不清楚这些补助金额是否能够维持这些特殊人群的正常生活。</p><h3 id="教育"><a href="#教育" class="headerlink" title="教育"></a>教育</h3><p>不知是否受限于九年义务教育的原因，有不少的人选择了初中毕业后就直接去外地工作，或独闯天下，或与父母一起，家庭总体收入较低且不具有稳定性（即数据相较于去年而言变化较大）。至于为什么选择直接工作也有各种各样的理由，有的人是因为家庭原因，有的人却是因为不想读了（原话）。与上述情况不同的，有些家庭的家长虽然身处外地打工，却依然支持自己的子女上高中上大学。在一些已有大学生的家庭中，我能够感受他们家庭自身的收入在一个中等偏上（相较于全村而言）的水平。</p><p>由于自己只能够通过纸张上的对比表，从家庭各成员学历、工作地、收入来分析他们的情况，所以我没法真真正正了解到他们每一个人的想法与感受。但是有一点我能感受到的是，接受了高等教育的人，能够为自己的家庭贡献出更多的力量。</p><h2 id="美丽岑巩"><a href="#美丽岑巩" class="headerlink" title="美丽岑巩"></a>美丽岑巩</h2><p>身处于城市过久，来乡村的一周时间中，觉得乡村真是一个很不错的地方，虽然在生活设施方面远不及城市，但无论是自然风景，还是饮食，乡村还是有其独特之处。（再次特别感谢每日饭堂的好饭菜！）</p><p><img src="/2018/11/12/出门走走-贵州岑巩县/Users/jianpeng/Documents/hexo/source/_posts/出门走走-贵州岑巩县/IMG_7851.JPG" alt=""></p><p><img src="/2018/11/12/出门走走-贵州岑巩县/Users/jianpeng/Documents/hexo/source/_posts/出门走走-贵州岑巩县/IMG_7852.JPG" alt=""></p><p><img src="/2018/11/12/出门走走-贵州岑巩县/Users/jianpeng/Documents/hexo/source/_posts/出门走走-贵州岑巩县/IMG_7854.JPG" alt=""></p><p><img src="/2018/11/12/出门走走-贵州岑巩县/Users/jianpeng/Documents/hexo/source/_posts/出门走走-贵州岑巩县/IMG_7864.JPG" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;上周参加了学校组织的扶贫活动，地点位于贵州岑巩县。并不是因为偷懒没写技术博客才去的呀：）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;做了什么&quot;&gt;&lt;a href=&quot;#做了什么&quot; class=&quot;headerlink&quot; title=&quot;做了什么&quot;
      
    
    </summary>
    
    
      <category term="旅行" scheme="http://apparition957.github.io/tags/%E6%97%85%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>Motan 系列-总体设计</title>
    <link href="http://apparition957.github.io/2018/11/02/Motan-%E7%B3%BB%E5%88%97-%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1/"/>
    <id>http://apparition957.github.io/2018/11/02/Motan-系列-总体设计/</id>
    <published>2018-11-02T06:47:36.000Z</published>
    <updated>2018-11-10T11:15:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Motan 是微博开源的一套基于 Java 研发的 RPC 框架，更加详细的了解可以参考<a href="https://github.com/weibocom/motan/wiki/zh_userguide" target="_blank" rel="external">Motan中文文档</a>，本文内容更多的是关注于总体架构方面的设计。</p><h2 id="架构概述"><a href="#架构概述" class="headerlink" title="架构概述"></a>架构概述</h2><p><img src="/2018/11/02/Motan-系列-总体设计/Motan-总体架构.jpg" alt=""></p><p>上图是 RPC 通信框架中较为通用的架构设计方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;Motan 是微博开源的一套基于 Java 研发的 RPC 框架，更加详细的了解可以参考&lt;a href=&quot;https://github.co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Motan 系列 - 目录</title>
    <link href="http://apparition957.github.io/2018/10/30/Motan%20%E7%B3%BB%E5%88%97-%E7%9B%AE%E5%BD%95/"/>
    <id>http://apparition957.github.io/2018/10/30/Motan 系列-目录/</id>
    <published>2018-10-30T05:08:33.000Z</published>
    <updated>2018-11-02T06:47:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>其实本来想写 Dubbo 的，奈何时间和个人能力都不足以让我从头到尾把 Dubbo 看一遍，所以转而深入理解 Motan 这一小而美的 RPC 框架。</p></blockquote><p>下面是近期想要开始写的 Motan 源码分析系列文章（先自己把坑挖好，后期慢慢把坑填上吧）。</p><ol><li>Motan 系列-总体设计</li><li>Motan 系列-额外知识-SPI 机制</li><li>Motan 系列-额外知识-Spring 事件机制</li><li>Motan 系列-服务提供者-如何提供服务</li><li>Motan 系列-服务提供者-如何响应服务</li><li>Motan 系列-服务消费者-如何连接服务</li><li>Motan 系列-服务消费者-如何消费服务</li><li>Motan 系列-注册中心设计</li><li>Motan 系列-其他特性-心跳机制</li><li>Motan 系列-其他特性-Shutdown 机制</li><li>Motan 系列-其他特性-异步调用</li><li>…..</li></ol><hr><p>以下参考的文章都是在我学习 Motan 的时候提供了很大的帮助，十分感谢他们能写出这么棒的文章。</p><ol><li><a href="http://kriszhang.com/motan-rpc-impl/" target="_blank" rel="external">从motan看RPC框架设计</a></li><li><a href="https://fdx321.github.io/2017/07/19/%E3%80%90Motan%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%911-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/" target="_blank" rel="external">Motan源码学习</a></li><li><a href="http://blog.yannxia.top/2018/06/30/java/motan/motan/" target="_blank" rel="external">Motan源码分析</a></li><li><a href="https://github.com/weibocom/motan/wiki" target="_blank" rel="external">github/Motan-wiki 文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;其实本来想写 Dubbo 的，奈何时间和个人能力都不足以让我从头到尾把 Dubbo 看一遍，所以转而深入理解 Motan 这一小而美的 RPC 框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是近期想要开始写的 Motan 源码分析系列文章（
      
    
    </summary>
    
    
      <category term="Motan" scheme="http://apparition957.github.io/tags/Motan/"/>
    
  </entry>
  
  <entry>
    <title>在小米实习的180天</title>
    <link href="http://apparition957.github.io/2018/07/20/%E5%9C%A8%E5%B0%8F%E7%B1%B3%E5%AE%9E%E4%B9%A0%E7%9A%84180%E5%A4%A9/"/>
    <id>http://apparition957.github.io/2018/07/20/在小米实习的180天/</id>
    <published>2018-07-20T14:46:20.000Z</published>
    <updated>2018-07-20T14:47:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>感恩在小米的这段实习经历，感谢小米身边的每个人。</p><p><img src="http://on83riher.bkt.clouddn.com/WechatIMG17218.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;感恩在小米的这段实习经历，感谢小米身边的每个人。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://on83riher.bkt.clouddn.com/WechatIMG17218.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TCP 协议中 Keep-Alive 特性</title>
    <link href="http://apparition957.github.io/2018/05/27/TCP%20%E5%8D%8F%E8%AE%AE%E4%B8%AD%20Keep-Alive%20%E7%89%B9%E6%80%A7/"/>
    <id>http://apparition957.github.io/2018/05/27/TCP 协议中 Keep-Alive 特性/</id>
    <published>2018-05-27T10:47:59.000Z</published>
    <updated>2018-05-27T10:48:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在腾讯面试的时候问过我基于这个特性的问题，可惜我没答出来:(,以下为原题部分。</p><p>在 TCP 连接中，我们都知道客户端要与服务器端断开连接时需要经过”四次分手”。但如果客户端在未知因素的情况下宕机了，那服务器端会在什么时候认为客户端已掉线，从而服务器端”主动”断开连接呢？</p></blockquote><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>抛弃上面的描述，我们知道在 TCP 协议中，如果客户端不主动断开与服务器端的连接时，服务器端便会一直持有对这个客户端的连接。如果不引入某些有效机制的话，这将会大大地消耗服务器端的资源。</p><p>keep-alive 机制确保了服务器端能够在客户端无消息发送的一段时间后，自主地断开与客户端的连接。</p><h4 id="RFC-中-Keep-Alive-机制"><a href="#RFC-中-Keep-Alive-机制" class="headerlink" title="RFC 中 Keep-Alive 机制"></a>RFC 中 Keep-Alive 机制</h4><p>keep-alive 是 TCP 协议的可选特性（optional feature）。如果操作系统实现了这一特性，就必须保证应用程序能够为每个 TCP 连接打开或关闭该特性，且这一特性必须是默认关闭的。</p><p>keep-alive 的心跳包只能够在从最后一次接收到 ACK 包的时间起，经过一个固定的时间间隔后才能发送。这个时间间隔必须能够被配置，且默认值不能够低于2小时。</p><p>keep-alive 应当在服务器端启用，而客户端不做任何修改。倘若客户端开启了这一特性，当客户端异常崩溃或者出现连接故障的话，将会导致该连接无限期挂起和消耗不必要的资源。</p><p>在 TCP 规范中并不包含 keep-alive 机制的主要原因有三：（1）在短暂的网络故障期间，可能会导致一个良好正常的连接(perfectly good connections)断开。(2)消耗不必要的带宽资源（”if no one is using the                 connection, who cares if it is still good?”）。（3）在以数据包计费的互联网网络中（额外）花费金钱。</p><h4 id="Linux-内核下-Keep-Alive-的重要参数"><a href="#Linux-内核下-Keep-Alive-的重要参数" class="headerlink" title="Linux 内核下 Keep-Alive 的重要参数"></a>Linux 内核下 Keep-Alive 的重要参数</h4><p>在 Linux 内核中，keep-alive 机制涉及到三个重要的参数：</p><ol><li>tcp_keepalive_time。该参数是指最后一次数据包（不包含数据的 ACK 包）发送的时间到第一次发送的心跳包之间的时间间隔。默认值为7200s（2小时）。</li><li>tcp_keepalive_intvl。该参数是指连续两个心跳包之间的时间间隔。默认值为75s。</li><li>tcp_keepalive_probes。该参数是指在服务器端认为该连接失效(dead)并通知用户前，未确认的探测器(unacknowledged probes)发送的数量。默认值为9（次）。</li></ol><p>Linux 的文档还特别声明了即使 keep-alive 这一机制在内核中被配置了，这一行为也不是 Linux 的默认行为。</p><h4 id="面试题的一种合适的解释"><a href="#面试题的一种合适的解释" class="headerlink" title="面试题的一种合适的解释"></a>面试题的一种合适的解释</h4><p>了解了这一特性背后的含义时，我们可以对面试官说到。在 Linux 环境下，如果该连接中 keep-alive 机制已开启时，服务器端会在 7200s + 75s * 9time 后断开与客户端的连接（即在底层清除失效的文件描述符）。</p><h4 id="与-HTTP-中-Keep-Alive-的对比"><a href="#与-HTTP-中-Keep-Alive-的对比" class="headerlink" title="与 HTTP 中 Keep-Alive 的对比"></a>与 HTTP 中 Keep-Alive 的对比</h4><p>HTTP 协议中的 keep-alive 机制是为了通信双方的连接复用，避免消耗太多资源。而  TCP 协议中 keep-alive 机制是为了检验通信双方的是否活着(alive)，保证通信能够正常进行。</p><hr><p>参考资料：</p><ol><li><a href="https://tools.ietf.org/html/rfc1122#page-101" target="_blank" rel="external">https://tools.ietf.org/html/rfc1122#page-101</a></li><li><a href="http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html" target="_blank" rel="external">http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html</a></li><li><a href="http://www.importnew.com/27624.html" target="_blank" rel="external">http://www.importnew.com/27624.html</a></li><li><a href="http://www.cnblogs.com/liuyong/archive/2011/07/01/2095487.html" target="_blank" rel="external">http://www.cnblogs.com/liuyong/archive/2011/07/01/2095487.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在腾讯面试的时候问过我基于这个特性的问题，可惜我没答出来:(,以下为原题部分。&lt;/p&gt;
&lt;p&gt;在 TCP 连接中，我们都知道客户端要与服务器端断开连接时需要经过”四次分手”。但如果客户端在未知因素的情况下宕机了，那服务器端会在什么时候认为客户端已掉
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala - NonLocalReturnControl</title>
    <link href="http://apparition957.github.io/2018/05/22/Scala%20-%20NonLocalReturnControl/"/>
    <id>http://apparition957.github.io/2018/05/22/Scala - NonLocalReturnControl/</id>
    <published>2018-05-22T08:36:18.000Z</published>
    <updated>2018-05-22T08:38:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="状态说明"><a href="#状态说明" class="headerlink" title="状态说明"></a>状态说明</h4><p>今天跑 Spark 作业的时候，刚进入 RUNNING 状态没多久就直接抛出了下面这种异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">User class threw exception: org.apache.spark.SparkException: Task not serializable</div><div class="line">  at org.apache.spark.util.ClosureCleaner$.ensureSerializable(ClosureCleaner.scala:298)</div><div class="line">  at org.apache.spark.util.ClosureCleaner$.org$apache$spark$util$ClosureCleaner$$clean(ClosureCleaner.scala:288)</div><div class="line">  at org.apache.spark.util.ClosureCleaner$.clean(ClosureCleaner.scala:108)</div><div class="line">  at org.apache.spark.SparkContext.clean(SparkContext.scala:2100)</div><div class="line">.....</div><div class="line">Caused by: java.io.NotSerializableException: java.lang.Object</div><div class="line">Serialization stack:</div><div class="line">  - object not serializable (class: java.lang.Object, value: java.lang.Object@65c9e3ee)</div><div class="line">  - field (class: com.xiaomi.search.websearch.hbase.SegTitlePick$$anonfun$1, name: nonLocalReturnKey1$1, type: class java.lang.Object)</div><div class="line">  - object (class com.xiaomi.search.websearch.hbase.SegTitlePick$$anonfun$1, &lt;function1&gt;)</div><div class="line">  at org.apache.spark.serializer.SerializationDebugger$.improveException(SerializationDebugger.scala:40)</div><div class="line">  at org.apache.spark.serializer.JavaSerializationStream.writeObject(JavaSerializer.scala:46)</div><div class="line">  at org.apache.spark.serializer.JavaSerializerInstance.serialize(JavaSerializer.scala:100)</div><div class="line">  at org.apache.spark.util.ClosureCleaner$.ensureSerializable(ClosureCleaner.scala:295)</div></pre></td></tr></table></figure><p>上网一查发现时某个匿名函数里面使用了 return 导致的。</p><h4 id="报错理由是什么呢"><a href="#报错理由是什么呢" class="headerlink" title="报错理由是什么呢"></a>报错理由是什么呢</h4><p>源代码就不贴出来了，我们以一个简单的例子来说明这个问题吧。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> datas = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">    datas.foreach(t =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (t % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="comment">// 运行符合条件时便立刻返回</span></div><div class="line">    &#125;)</div><div class="line">    </div><div class="line">    <span class="comment">// 本例的目标想在遍历完 datas 后便输出该语句，但在实际情况下，return 语句会直接返回并退出当前函数(即 main 函数)，所以以下语句并不会输出结果</span></div><div class="line">    println(<span class="string">"finished!"</span>) </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>让我们查看编译后这段遍历的代码有什么不一样的地方吧？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// scalac -Xprint:explicitouter Test.scala</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">  &lt;synthetic&gt; <span class="keyword">val</span> nonLocalReturnKey1: <span class="type">Object</span> = <span class="keyword">new</span> <span class="type">Object</span>();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">val</span> datas: <span class="type">List</span>[<span class="type">Int</span>] =            scala.collection.immutable.<span class="type">List</span>.apply[<span class="type">Int</span>]  (scala.<span class="type">Predef</span>.wrapIntArray(<span class="type">Array</span>[<span class="type">Int</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;));</div><div class="line">    datas.foreach[<span class="type">Unit</span>](&#123;</div><div class="line">      <span class="keyword">final</span> &lt;artifact&gt; <span class="function"><span class="keyword">def</span> <span class="title">$anonfun$main</span></span>(t: <span class="type">Int</span>): <span class="type">Unit</span> = <span class="keyword">if</span> (t.%(<span class="number">2</span>).==(<span class="number">0</span>))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> scala.runtime.<span class="type">NonLocalReturnControl</span>$mcV$sp(nonLocalReturnKey1, ())</div><div class="line">      <span class="keyword">else</span></div><div class="line">        ();</div><div class="line">      ((t: <span class="type">Int</span>) =&gt; $anonfun$main(t))</div><div class="line">    &#125;);</div><div class="line">    scala.<span class="type">Predef</span>.println(<span class="string">"finished!"</span>)</div><div class="line">  &#125; <span class="keyword">catch</span> &#123;</div><div class="line">    <span class="keyword">case</span> (ex @ (_: scala.runtime.<span class="type">NonLocalReturnControl</span>[<span class="type">Unit</span> <span class="meta">@unchecked</span>])) =&gt; <span class="keyword">if</span> (ex.key().eq(nonLocalReturnKey1))</div><div class="line">      ex.value$mcV$sp()</div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="keyword">throw</span> ex</div><div class="line">  &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>编译后我们可以看到原先匿名函数中的 return 语句被替换成抛出一个<code>NonLocalReturnControl</code>运行时异常，而<code>try-catch</code>环绕着整个 main 函数内部的代码块来尝试捕获这个异常。</p><p>而观察<code>NonLocalReturnControl</code>异常，我们发现这个异常是无法被序列化的，这就解释了之前的作业抛出异常的意思了。</p><h4 id="为什么-return-语句要这么设计呢"><a href="#为什么-return-语句要这么设计呢" class="headerlink" title="为什么 return 语句要这么设计呢"></a>为什么 return 语句要这么设计呢</h4><p>为什么 Scala 要这么做呢？这里有几篇不错的文章来说明，我就偷懒不去翻译了(建议从上往下看)</p><ol><li>介绍什么是 non-local return - <a href="https://www.zhihu.com/question/22240354/answer/64673094" target="_blank" rel="external">https://www.zhihu.com/question/22240354/answer/64673094</a></li><li>前半段介绍 return 语句该什么时候出现，后半段推测出这么做的两个原因 - <a href="https://stackoverflow.com/questions/17754976/scala-return-statements-in-anonymous-functions" target="_blank" rel="external">https://stackoverflow.com/questions/17754976/scala-return-statements-in-anonymous-functions</a></li><li>讨论在 Scala 中 function 和 method 两者概念上的区别 - <a href="https://link.jianshu.com/?t=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F2529184%2Fdifference-between-method-and-function-in-scala" target="_blank" rel="external">https://link.jianshu.com/?t=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F2529184%2Fdifference-between-method-and-function-in-scala</a></li></ol><p>但其实翻阅了网上的资料，并没有真正地说明为什么这么设计。结合上面的几篇文章，我个人认为在 Scala 这一门函数式编程语言里，其更加讲究的是程序执行的结果，而并非执行过程。return 语句影响程序的顺序执行，从而可能会使代码变得复杂，也可能会发生若干次程序执行的结果不一致的情况，那么这将在很大程度上影响了我们对于代码的理解与认识。这也是 Scala 为什么不倡导我们使用 return。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;状态说明&quot;&gt;&lt;a href=&quot;#状态说明&quot; class=&quot;headerlink&quot; title=&quot;状态说明&quot;&gt;&lt;/a&gt;状态说明&lt;/h4&gt;&lt;p&gt;今天跑 Spark 作业的时候，刚进入 RUNNING 状态没多久就直接抛出了下面这种异常。&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala - Iterator vs Stream vs View</title>
    <link href="http://apparition957.github.io/2018/05/19/Scala%20-%20Iterator%20vs%20Stream%20vs%20View/"/>
    <id>http://apparition957.github.io/2018/05/19/Scala - Iterator vs Stream vs View/</id>
    <published>2018-05-19T09:58:10.000Z</published>
    <updated>2018-05-19T09:58:33.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h4><p><a href="https://stackoverflow.com/questions/5159000/stream-vs-views-vs-iterators" target="_blank" rel="external">https://stackoverflow.com/questions/5159000/stream-vs-views-vs-iterators</a></p><h4 id="优秀回答"><a href="#优秀回答" class="headerlink" title="优秀回答"></a>优秀回答</h4><blockquote><p>该篇回答被收录到 Scala 文档中的 F&amp;Q 部分。我尝试跟着这篇回答并对照源码部分去翻译，翻译不好多多谅解。</p></blockquote><p>First, they are all <em>non-strict</em>. That has a particular mathematical meaning related to functions, but, basically, means they are computed on-demand instead of in advance.</p><p>首先，它们都是非严格（即惰性的）的。每个函数都有其特定的数学含义，但是基本上，其数学含义通常都意味着它们是按需计算而非提前计算。</p><p><code>Stream</code> is a lazy list indeed. In fact, in Scala, a <code>Stream</code> is a <code>List</code> whose <code>tail</code> is a <code>lazy val</code>. Once computed, a value stays computed and is reused. Or, as you say, the values are cached.</p><p><code>Stream</code>确实是一个惰性列表。事实上，在 Scala 中，<code>Stream</code>是<code>tail</code>变量为惰性值的列表。一旦开始计算，<code>Stream</code>中的值便保持计算后的状态并被能够被重复使用。或者按照你的说法是，<code>Stream</code>中的值能够被缓存下来。</p><blockquote><p>一篇比较不错的、科普<code>Stream</code>的文章：<a href="http://cuipengfei.me/blog/2014/10/23/scala-stream-application-scenario-and-how-its-implemented/" target="_blank" rel="external">http://cuipengfei.me/blog/2014/10/23/scala-stream-application-scenario-and-how-its-implemented/</a></p></blockquote><p>An <code>Iterator</code> can only be used once because it is a <em>traversal pointer</em> into a collection, and not a collection in itself. What makes it special in Scala is the fact that you can apply transformation such as <code>map</code> and <code>filter</code> and simply get a new <code>Iterator</code> which will only apply these transformations when you ask for the next element.</p><p><code>Iterator</code>只能够被使用一次，因为其是一个<em>可遍历</em>的指针存在于集合当中，而非集合本身存在于<code>Iterator</code>中。让其在 Scala 如此特殊的原因在于你能够使用 transformation 算子，如<code>map</code>或者<code>filter</code>，并且很容易地获得一个新的<code>Iterator</code>。需要注意的是，新的<code>Iterator</code>只有通过获取元素的时候才会应用那些 transformation 算子。</p><p>Scala used to provide iterators which could be reset, but that is very hard to support in a general manner, and they didn’t make version 2.8.0.</p><p>Scala 曾尝试过给那些 iterator 一个可复位的功能，但这很难以一个通用的方式去支持。</p><p>Views are meant to be viewed much like a database view. It is a series of transformation which one applies to a collection to produce a “virtual” collection. As you said, all transformations are re-applied each time you need to fetch elements from it.</p><p>Views 通常意味着元素需要被观察，类似于数据库中的 view。它是原集合通过一系列的 transformation 算子生成的一个”虚构”的集合。如你所说，每当你需要从原集合中获取数据时，都能够重复应用这些 transformation 算子。</p><p>Both <code>Iterator</code> and views have excellent memory characteristics. <code>Stream</code> is nice, but, in Scala, its main benefit is writing infinite sequences (particularly sequences recursively defined). One <em>can</em> avoid keeping all of the <code>Stream</code> in memory, though, by making sure you don’t keep a reference to its <code>head</code> (for example, by using <code>def</code> instead of <code>val</code> to define the <code>Stream</code>).</p><p><code>Iterator</code>和 views 两者都有不错内存（记忆？）特性。<code>Stream</code>也可以，但是在 Scala 中，其主要的好处在于能够保留无限长的序列（特别是那些序列是通过递归定义的[这一点需要通过 Stream 本身特性才能够理解]）当中。不过，你可以避免将所有Stream保留在内存中，其方法是确保不保留那些对 <code>Stream</code>中<code>head</code>的引用。</p><blockquote><p>针对最后提到的例子，<a href="https://stackoverflow.com/questions/13217222/should-i-use-val-or-def-when-defining-a-stream这篇回答有比较好的解释" target="_blank" rel="external">https://stackoverflow.com/questions/13217222/should-i-use-val-or-def-when-defining-a-stream这篇回答有比较好的解释</a></p></blockquote><p>Because of the penalties incurred by views, one should usually <code>force</code> it after applying the transformations, or keep it as a view if only few elements are expected to ever be fetched, compared to the total size of the view.</p><p>由于 views 所带来不良影响（个人认为是这么翻译的），我们通常需要在应用 transformations 后调用<code>force</code>进行计算，或者说如果相比于原 view 中大量元素，新 view 只有少量的元素需要去获取时，可以将其当做新的 view 对待。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;问题来源&quot;&gt;&lt;a href=&quot;#问题来源&quot; class=&quot;headerlink&quot; title=&quot;问题来源&quot;&gt;&lt;/a&gt;问题来源&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/5159000/stream-vs
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala - 有关变量赋值的问题</title>
    <link href="http://apparition957.github.io/2018/05/18/Scala%20-%20%E6%9C%89%E5%85%B3%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://apparition957.github.io/2018/05/18/Scala - 有关变量赋值的问题/</id>
    <published>2018-05-18T15:14:46.000Z</published>
    <updated>2018-05-18T15:15:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="先看个小问题"><a href="#先看个小问题" class="headerlink" title="先看个小问题"></a>先看个小问题</h4><p>先贴下一段<code>Scala</code>代码，看下这段代码是否存在问题？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> persons = <span class="type">List</span>[<span class="type">Person</span>](<span class="type">Person</span>(<span class="string">"tom"</span>), <span class="type">Person</span>(<span class="string">"marry"</span>), <span class="literal">null</span>).iterator</div><div class="line"><span class="keyword">var</span> person: <span class="type">Person</span> = <span class="literal">null</span></div><div class="line"><span class="keyword">while</span> ((person = persons.next()) != <span class="literal">null</span>) &#123;</div><div class="line">  println(<span class="string">"obj name: "</span> + person.name)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果你的答案是<code>这段代码运行不会出任何问题</code>的话，那么你对于 Scala 的变量赋值还是了解太少。</p><hr><h4 id="为什么呢"><a href="#为什么呢" class="headerlink" title="为什么呢"></a>为什么呢</h4><p>在我们一般的认知中，在 Java 和 C++ 中对变量赋值后，其会返回相对应该变量的值，而在 Scala 中，如果对变量赋值后，获取到的返回值却统一是 Unit。</p><blockquote><p>Unit 是表示为无值，其作用与其他语言中的 void 作用相同，用作不返回任何结果的方法的结果类型。</p></blockquote><p>回到刚才那段代码，根据以上说明，如果我们在赋值对<code>person</code>变量的话，那就会导致在每一次循环当中，其实我们一直都是拿 Unit 这个值去与 null 比较，那么就可以换做一个恒等式为<code>Unit != null</code>，这样做的结果就是这个循环不会中断。</p><blockquote><p>在 IDEA 中，如果我们仔细查看代码，发现 IDE 已经提醒我们这个问题的存在了，这这也仅仅只是 Warning 而已。</p><p>若通过编译的方法查看源代码的话，会在编译的过程中，获得这样一句警告（并非错误！）：</p><p><img src="http://on83riher.bkt.clouddn.com/QQ20180518-225838@2x.png" alt=""></p></blockquote><p>有个简单的例子可以检验自己是否明白懂了这个”bug”：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a: <span class="type">Int</span> = <span class="number">0</span></div><div class="line"><span class="keyword">var</span> b: <span class="type">Int</span> = <span class="number">0</span></div><div class="line">a = b = <span class="number">1</span> <span class="comment">// 这行代码能够跑通，在其他语言呢？</span></div></pre></td></tr></table></figure><hr><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>在给出常见的解决方案前，先给出为什么 Scala 要这样设计的理由（Scala 之父亲自解释）：</p><p><a href="https://stackoverflow.com/questions/1998724/what-is-the-motivation-for-scala-assignment-evaluating-to-unit-rather-than-the-v" target="_blank" rel="external">https://stackoverflow.com/questions/1998724/what-is-the-motivation-for-scala-assignment-evaluating-to-unit-rather-than-the-v</a></p><p>常见的解决方案会有以下几种：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// solution 1 - 封装成代码块返回最终值，直观但麻烦</span></div><div class="line"><span class="keyword">var</span> person = <span class="literal">null</span></div><div class="line"><span class="keyword">while</span> (&#123;person = persons.next; person != <span class="literal">null</span>&#125;) &#123;</div><div class="line">  println(<span class="string">"obj name: "</span> + person.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// solution 2 （推荐）- 通过 Scala 的语法特性，使用它的奇淫技巧</span></div><div class="line"><span class="type">Iterator</span>.continually(persons.next())</div><div class="line">  .takeWhile(_ != <span class="literal">null</span>)</div><div class="line">  .foreach(t =&gt; &#123;println(<span class="string">"obj name: "</span> + t.name)&#125;)</div><div class="line"></div><div class="line"><span class="comment">// solution 3 - 这个与 Solution2 的区别仅仅在于使用的类不同，但使用的类不同便意味着这两者之间存在着不同的遍历方式。两者的区别会在博客中更新。</span></div><div class="line"><span class="type">Stream</span>.continually(persons.next())</div><div class="line">  .takeWhile(_ != <span class="literal">null</span>)</div><div class="line">  .foreach(t =&gt; &#123;println(<span class="string">"obj name: "</span> + t.name)&#125;)</div></pre></td></tr></table></figure><p>参考资料：</p><ol><li><a href="https://stackoverflow.com/questions/6881384/why-do-i-get-a-will-always-yield-true-warning-when-translating-the-following-f" target="_blank" rel="external">https://stackoverflow.com/questions/6881384/why-do-i-get-a-will-always-yield-true-warning-when-translating-the-following-f</a></li><li><a href="https://stackoverflow.com/questions/3062804/scala-unit-type" target="_blank" rel="external">https://stackoverflow.com/questions/3062804/scala-unit-type</a></li><li><a href="https://stackoverflow.com/questions/2442318/how-would-i-express-a-chained-assignment-in-scala" target="_blank" rel="external">https://stackoverflow.com/questions/2442318/how-would-i-express-a-chained-assignment-in-scala</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;先看个小问题&quot;&gt;&lt;a href=&quot;#先看个小问题&quot; class=&quot;headerlink&quot; title=&quot;先看个小问题&quot;&gt;&lt;/a&gt;先看个小问题&lt;/h4&gt;&lt;p&gt;先贴下一段&lt;code&gt;Scala&lt;/code&gt;代码，看下这段代码是否存在问题？&lt;/p&gt;
&lt;figure cl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala - 类构造器</title>
    <link href="http://apparition957.github.io/2018/05/14/Scala%20-%20%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8/"/>
    <id>http://apparition957.github.io/2018/05/14/Scala - 类构造器/</id>
    <published>2018-05-14T15:58:37.000Z</published>
    <updated>2018-05-14T15:59:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>Scala 构造器可分为两种，主构造器和辅助构造器。</p><h4 id="主构造器"><a href="#主构造器" class="headerlink" title="主构造器"></a>主构造器</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 无参主构造器</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="comment">// 主构造器的构成部分</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 有参主构造器</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo2</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>) </span>&#123;</div><div class="line">    <span class="comment">// 主构造器的构成部分</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从类的定义开始，花括号的部分为主构造器的构成部分。主构造器在执行时，会执行类中所有的语句。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// example</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">val</span> name = <span class="string">"tom"</span></div><div class="line">    <span class="keyword">val</span> age = <span class="number">18</span></div><div class="line">    </div><div class="line">    doSomething() <span class="comment">// 初始化对象时，会打印 name: tome, age: 18</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doSomething</span></span>() = &#123;</div><div class="line">        println(<span class="string">"name: "</span> + name + <span class="string">", age: "</span> + age)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="辅助构造器"><a href="#辅助构造器" class="headerlink" title="辅助构造器"></a>辅助构造器</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> age = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="comment">// 错误定义!!</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() &#123;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">this</span>()</div><div class="line">        <span class="keyword">this</span>.name = name</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</div><div class="line">        <span class="keyword">this</span>(name)</div><div class="line">        <span class="keyword">this</span>.age = age</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>辅助构造器的名称为<code>this</code>，与 Java 的构造器名称不同（Java 构造器名称是以类名定义的），其代码大致结构为<code>def this(...) {}</code>。若一个类如果没有显式定义主构造器，则编译器会自动生成一个无参的主构造器。</p><p>必须注意的是，每个辅助构造器都必须以一个对先前已定义的其他辅助构造器或者主构造器的调用开始。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Scala 构造器可分为两种，主构造器和辅助构造器。&lt;/p&gt;
&lt;h4 id=&quot;主构造器&quot;&gt;&lt;a href=&quot;#主构造器&quot; class=&quot;headerlink&quot; title=&quot;主构造器&quot;&gt;&lt;/a&gt;主构造器&lt;/h4&gt;&lt;figure class=&quot;highlight scala&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>寻找一种更快更高效的方法</title>
    <link href="http://apparition957.github.io/2018/05/07/%E5%AF%BB%E6%89%BE%E4%B8%80%E7%A7%8D%E6%9B%B4%E5%BF%AB%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://apparition957.github.io/2018/05/07/寻找一种更快更高效的方法/</id>
    <published>2018-05-07T14:35:49.000Z</published>
    <updated>2018-05-07T14:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在对我们开发的模块进行最后的收尾，收尾的工作一般来说都是添加测试用例，测试模块调用时是否有 BUG 等。果不其然，老大还是叫我去做模块的测试。其实还是自己对于 C++了解太少，刚入门一个星期才勉强能够看懂之前的部分源码，而且原有工程十分庞大，还有自己封装好的又或自己开发的工具库。想去调用还得自己上网看看 example 熟悉下，没有 example 的那就苦逼自己慢慢摸索了</p><blockquote><p><strong>做测试没关系，毕竟怎么样都能够学到不一样的知识。</strong></p></blockquote><p>先说下这次测试的内容，就是将之前标注好的数据，利用我们的模块重新跑一遍，检验是否有错漏的地方。这上面说的简单，但其中含杂了大量的人工，这我可不干，所以才有了这一篇文章。</p><h4 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h4><p>404页面错误检验模块（基于 URL 和 Content 两部分），编写爬虫将标注好的数据中 URL 所对应的页面存储于本地（csv文件）</p><h4 id="人工方法"><a href="#人工方法" class="headerlink" title="人工方法"></a>人工方法</h4><p>如果按照人工方法走，就是针对于一个 URL 创建一个 HTML 文件，然后撰写一个测试用例，跑通了我们就往下走，没跑通那就回头重新梳理逻辑。这种方式如果针对于一两个文件还好说，那如果针对于上百个文件那怎么办？如果这还人工一个个弄，那算你厉害</p><h4 id="自动化方法"><a href="#自动化方法" class="headerlink" title="自动化方法"></a>自动化方法</h4><p>自动化方法是否能够运用在于在这过程当中是否存在一定的规律，相信读到这里的我们，可以明白自动化的方法就是在若干个循环当中，重复操作人工的方法，只是在这个过程当中，你需要用代码来证明你的想法，而非你的汗水</p><p>在材料准备中，我们已经有了包含测试数据的 csv 文件，可能读者会理所当然的认为这个自动化测试不就两行代码妥妥的就搞定吗？其实并不然，c++ 中并没有什么第三方库处理 csv 这样的文件（反正我是没找到），如果利用简单的<code>split</code>函数的话，那就会导致原有数据（HTML）的丢失。</p><p>这个时候，我们需要转向文件流，即将若干个 HTML 文件存储下来，并创建一个索引表，记录 URL 与其对应的文件名，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">~/htmls/</div><div class="line">0.html 1.html 2.html index.txt</div><div class="line"></div><div class="line">~/htmls/index.txt</div><div class="line">https://www.baidu.com 0.html</div><div class="line">https://www.taobao.com 1.html</div></pre></td></tr></table></figure><p>然后在实际编写代码过程中，先读取索引表，再利用索引表的信息，读取 HTML 文件然后运行模块，记录运行结果，当所有测试用例结束时，统计最终结果，并根据最终结果，调整内部的策略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两天在对我们开发的模块进行最后的收尾，收尾的工作一般来说都是添加测试用例，测试模块调用时是否有 BUG 等。果不其然，老大还是叫我去做模块的测试。其实还是自己对于 C++了解太少，刚入门一个星期才勉强能够看懂之前的部分源码，而且原有工程十分庞大，还有自己封装好的又或自己开
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>有多少人工就有多少智能</title>
    <link href="http://apparition957.github.io/2018/04/19/%E6%9C%89%E5%A4%9A%E5%B0%91%E4%BA%BA%E5%B7%A5%E5%B0%B1%E6%9C%89%E5%A4%9A%E5%B0%91%E6%99%BA%E8%83%BD/"/>
    <id>http://apparition957.github.io/2018/04/19/有多少人工就有多少智能/</id>
    <published>2018-04-19T15:04:25.000Z</published>
    <updated>2018-04-19T15:04:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个标题其实是来自于<a href="https://blog.csdn.net/dQCFKyQDXYm3F8rB0/article/details/79933707" target="_blank" rel="external">小米小爱团队负责人王刚：语音交互背后，有多少人工就有多少智能</a>这篇文章，虽然我现在的工作与人工智能没关系，但是与我现在的经历息息相关的。</p><p>最近在跟着老大去做页面分析的模块，现阶段有个问题在于怎么去解决网页软404问题。可行的解决方案当然有很多，HTTP 请求码、URL 的正则匹配、内容关键字匹配等。但是这么多的解决方案都需要的一个判断标准，判断跑出来的数据可不可靠，如果不可靠的话那么这个方案可能就行不通。</p><p>那么比较尴尬的部分来了，这个判断的过程是由人工来的，那这个活自然就落在我和其他同事身上啦。虽然知道这个是必然的过程，但是心还是不甘的，不甘于自己要去做人工筛选工作。</p><p><img src="http://on83riher.bkt.clouddn.com/WechatIMG128.jpeg" alt="工作成果"></p><p>其实单单抛弃人工智能这个前提，<strong>“有多少人工就有多少智能”</strong>这句话适用于互联网的各个领域，只要能够投入了足够的人力，那么系统的未来也会有很大的改善，以上是我现阶段的看法。</p><p>经历了这次人工筛选的活后，我还从这句话体会到了一点，<strong>努力提升自己的技术，别让自己成为可取代的人工。</strong>加深自己的技术栈吧，再经历多点磨难，或许能够看见更多未来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个标题其实是来自于&lt;a href=&quot;https://blog.csdn.net/dQCFKyQDXYm3F8rB0/article/details/79933707&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;小米小爱团队负责人王刚：语音交互背后，有多
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spark - take() 算子</title>
    <link href="http://apparition957.github.io/2018/04/14/Spark%20-%20take()%20%E7%AE%97%E5%AD%90/"/>
    <id>http://apparition957.github.io/2018/04/14/Spark - take() 算子/</id>
    <published>2018-04-14T05:41:00.000Z</published>
    <updated>2018-04-14T05:41:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以后遇到不懂的 Spark 算子的话，我都尽可能以笔记的方式去记录它</p></blockquote><h3 id="遇到的情况"><a href="#遇到的情况" class="headerlink" title="遇到的情况"></a>遇到的情况</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rdd.map(...) <span class="comment">// 重要前提：数据量在 TB 级别</span></div><div class="line">   .filter(...)  <span class="comment">// 根据某些条件筛选数据</span></div><div class="line">   .take(<span class="number">100000</span>) <span class="comment">// 取当前数据的前十万条</span></div></pre></td></tr></table></figure><p>当时的程序大致就是这样，我的想法是根据<code>filter()</code>之后的数据直接利用<code>take()</code>拿前十万的数据，感觉方便又省事，但是实际的运行情况却是作业的运行时间很长，让人怀疑人生。而且<code>take()</code>一开始默认的分区是1，而后如果当前任务失败的话，会适当的扩增分区数来读取更多的数据。</p><p><img src="http://on83riher.bkt.clouddn.com/take%20%E7%AE%97%E5%AD%90%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5.png" alt=""></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>废话不多，先贴源码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">  * Take the first num elements of the RDD. It works by first scanning one partition, and use the results from that partition to estimate the number of additional partitions needed to satisfy the limit.</span></div><div class="line"><span class="comment">  *</span></div><div class="line"><span class="comment">  * @note This method should only be used if the resulting array is expected to be small, as all the data is loaded into the driver's memory.</span></div><div class="line"><span class="comment">  * 此方法被使用时期望目标数组的大小比较小，即其数组中所有数据都能够存储在 driver 的内存当中。这里的函数解释当中提及到了处理的数据量应当较小，但是没说如果处理了比较大的数据时会怎么样，还得看看继续往下看</span></div><div class="line"><span class="comment">  *</span></div><div class="line"><span class="comment">  * @note Due to complications in the internal implementation, this method will raise</span></div><div class="line"><span class="comment">  * an exception if called on an RDD of `Nothing` or `Null`.</span></div><div class="line"><span class="comment">  */</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">take</span></span>(num: <span class="type">Int</span>): <span class="type">Array</span>[<span class="type">T</span>] = withScope &#123;</div><div class="line">  <span class="comment">// scaleUpFactor 字面意思是扩增因子，看到这里我们可以结合上图的例子，不难看出分区的扩增是按照一定的倍数增长的</span></div><div class="line">  <span class="keyword">val</span> scaleUpFactor = <span class="type">Math</span>.max(conf.getInt(<span class="string">"spark.rdd.limit.scaleUpFactor"</span>, <span class="number">4</span>), <span class="number">2</span>)</div><div class="line">  <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">T</span>](<span class="number">0</span>)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">val</span> buf = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">T</span>]</div><div class="line">    <span class="keyword">val</span> totalParts = <span class="keyword">this</span>.partitions.length</div><div class="line">    <span class="keyword">var</span> partsScanned = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="comment">// 这个循环是为什么 take 失败会进行重试的关键</span></div><div class="line">    <span class="keyword">while</span> (buf.size &lt; num &amp;&amp; partsScanned &lt; totalParts) &#123;</div><div class="line">      <span class="comment">// The number of partitions to try in this iteration. It is ok for this number to be</span></div><div class="line">      <span class="comment">// greater than totalParts because we actually cap it at totalParts in runJob.</span></div><div class="line">      <span class="comment">// numPartsToTry - 此次循环迭代的分区个数，默认为1。</span></div><div class="line">      <span class="keyword">var</span> numPartsToTry = <span class="number">1</span>L</div><div class="line">      <span class="keyword">val</span> left = num - buf.size</div><div class="line">      <span class="keyword">if</span> (partsScanned &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// If we didn't find any rows after the previous iteration, quadruple and retry.</span></div><div class="line">        <span class="comment">// Otherwise, interpolate the number of partitions we need to try, but overestimate</span></div><div class="line">        <span class="comment">// it by 50%. We also cap the estimation in the end.</span></div><div class="line">        <span class="comment">// 重点！当在上一次迭代当中，我们没有找到任何满足条件的 row 时(至少是不满足指定数量时)，有规律的重试(quadruple and retry，翻译水平有限)</span></div><div class="line">        <span class="keyword">if</span> (buf.isEmpty) &#123;</div><div class="line">          numPartsToTry = partsScanned * scaleUpFactor</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// As left &gt; 0, numPartsToTry is always &gt;= 1</span></div><div class="line">          numPartsToTry = <span class="type">Math</span>.ceil(<span class="number">1.5</span> * left * partsScanned / buf.size).toInt</div><div class="line">          numPartsToTry = <span class="type">Math</span>.min(numPartsToTry, partsScanned * scaleUpFactor)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">val</span> p = partsScanned.until(math.min(partsScanned + numPartsToTry, totalParts).toInt)</div><div class="line">      <span class="keyword">val</span> res = sc.runJob(<span class="keyword">this</span>, (it: <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; it.take(left).toArray, p)</div><div class="line"></div><div class="line">      <span class="comment">// 每一次循环迭代都会获取新的数据加到 buf 当中，所以并不是每一次重试都是从头对数据进行遍历，那这样会没完没了</span></div><div class="line">      res.foreach(buf ++= _.take(num - buf.size))</div><div class="line">      partsScanned += p.size</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这里才是我们最终的结果</span></div><div class="line">    buf.toArray</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>take()</code>算子使用的场景是当数据量规模较小的情况，亦或者说搭配<code>filter()</code>时，<code>filter()</code>能够较快的筛选出数据来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;以后遇到不懂的 Spark 算子的话，我都尽可能以笔记的方式去记录它&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;遇到的情况&quot;&gt;&lt;a href=&quot;#遇到的情况&quot; class=&quot;headerlink&quot; title=&quot;遇到的情况&quot;&gt;&lt;/a&gt;遇到
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spark - 由 foreach 引发的思考</title>
    <link href="http://apparition957.github.io/2018/04/01/Spark%20-%20%E7%94%B1%20foreach%20%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://apparition957.github.io/2018/04/01/Spark - 由 foreach 引发的思考/</id>
    <published>2018-03-31T17:34:32.000Z</published>
    <updated>2018-03-31T17:34:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>废话不说，先贴代码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> numbers = sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>))</div><div class="line"><span class="keyword">val</span> map = scala.collection.mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Int</span>]()</div><div class="line"></div><div class="line">numbers.foreach(l =&gt; &#123;map.put(l,l)&#125;)</div><div class="line">println(map.size) <span class="comment">// 此时 map 的存储了几个键值对</span></div></pre></td></tr></table></figure><hr><p>首先我们先说个概念 —— <strong>闭包</strong></p><p>闭包是 Scala 中的特性，用通俗易懂的话讲就是函数内部的运算或者说函数返回值可由外部的变量所控制，用个例子解释就是：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> factor = <span class="number">10</span></div><div class="line"><span class="comment">// multiplier 函数的返回值有有两个决定因素，输入参数变量 i 以及外部变量 factor。输入参数变量 i 是由我们调用该函数时决定的，相较于 factor 是可控的，而 factor 则是外部变量所定义，相较于 i 是不可控的</span></div><div class="line"><span class="keyword">val</span> multiplier = (i: <span class="type">Int</span>) =&gt; i * factor </div><div class="line">println(multiplier(<span class="number">1</span>)) <span class="comment">// 10</span></div><div class="line"></div><div class="line">factor = <span class="number">20</span></div><div class="line">println(multiplier(<span class="number">1</span>)) <span class="comment">// 20</span></div></pre></td></tr></table></figure><p>根据上述提及的闭包可知，刚才所写的代码中<code>l =&gt; {map.put(1,1)}</code>其所定义的函数就是一个闭包</p><hr><p>既然标题中提到了 Spark，那就要说明闭包与 Spark 的关系了</p><p>在 Spark 中，用户自定义闭包函数并传递给相应的 RDD 所定义好的方法（如<code>foreach</code>、<code>map</code>）。<strong>Spark 在运行作业时会检查 DAG 中每个 RDD 所涉及的闭包，如是否可序列化、是否引用外部变量等。若存在引用外部变量的情况，则会将它们的副本复制到相应的工作节点上，保证程序运行的一致性</strong></p><blockquote><p>下面是 Spark 文档中解释的：</p><h3 id="Shared-Variables"><a href="#Shared-Variables" class="headerlink" title="Shared Variables"></a>Shared Variables</h3><p>Normally, when a function passed to a Spark operation (such as <code>map</code> or <code>reduce</code>) is executed on a remote cluster node, it works on separate copies of all the variables used in the function. These variables are copied to each machine, and no updates to the variables on the remote machine are propagated back to the driver program. Supporting general, read-write shared variables across tasks would be inefficient. However, Spark does provide two limited types of <em>shared variables</em> for two common usage patterns: broadcast variables and accumulators.</p><h3 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h3><p>通常情况下，当有函数传递给在远端集群节点上执行的 Spark 的算子（如<code>map</code>或<code>reduce</code>）时，Spark 会将所有在该函数内部所需要的用到的变量分别复制到相应的节点上。这些副本变量会被复制到每个节点上，且在算子执行结束后这些变量并不会回传给驱动程序（driver program）。</p><p>Normally, when a function passed to a Spark operation (such as <code>map</code> or <code>reduce</code>) is executed on a remote cluster node, it works on separate copies of all the variables used in the function. These variables are copied to each machine, and no updates to the variables on the remote machine are propagated back to the driver program. </p></blockquote><hr><p>总结，如果直接运行一开始所提及的程序时，那么所获得的答案是0，因为我们知道<code>map</code>变量会被拷贝多份至不同的工作节点上，而我们操作的也仅仅只是副本罢了</p><p>从编译器的角度来说，这段代码是一个闭包函数，而其调用了外部变量，代码上没问题。但是从运行结果中，这是错误操作方式，因为 Spark 会将其所调用的外部变量进行拷贝，并复制到相应的工作节点中，而不会对真正的变量产生任何影响</p><p>相应的解决方案有</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> numbers = sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>))</div><div class="line"><span class="keyword">val</span> map = scala.collection.mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Int</span>]()</div><div class="line"></div><div class="line">numbers.collect().foreach(l =&gt; &#123;map.put(l,l)&#125;)</div><div class="line">println(map.size)</div></pre></td></tr></table></figure><hr><p>参考资料：</p><ol><li><a href="http://spark.apache.org/docs/2.1.0/programming-guide.html#shared-variables" target="_blank" rel="external">http://spark.apache.org/docs/2.1.0/programming-guide.html#shared-variables</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;废话不说，先贴代码&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>列式存储 - HBase vs Parquet</title>
    <link href="http://apparition957.github.io/2018/03/24/%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8%20-%20HBase%20vs%20Parquet/"/>
    <id>http://apparition957.github.io/2018/03/24/列式存储 - HBase vs Parquet/</id>
    <published>2018-03-24T07:05:48.000Z</published>
    <updated>2018-03-24T07:06:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>虽然两者在使用场景上没有可比性，HBase 是非关系型数据库，而 Parquet 是数据存储格式，但是两者却存在相似的概念——列式存储。我在了解 Parquet 的时候，因为列式存储这个概念与 HBase 混淆时，所以特意坐下笔记，记录两者的区别</p></blockquote><p>让我们直入正题，什么是列式存储？相比行式存储又有什么优势呢？</p><p><img src="http://on83riher.bkt.clouddn.com/%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E8%A1%8C%E5%BC%8F%E5%AD%98%E5%82%A8%20%E5%AF%B9%E6%AF%94%E5%9B%BE.png" alt=""></p><blockquote><p>图源来自 <a href="http://zhuanlan.51cto.com/art/201703/535729.htm" target="_blank" rel="external">http://zhuanlan.51cto.com/art/201703/535729.htm</a></p></blockquote><hr><p>首选先从 HBase 开始讲述。HBase是一个分布式的、面向列的非关系型数据库。它的架构设计如下：</p><p><img src="http://on83riher.bkt.clouddn.com/HBase%20%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt=""></p><p>简单说明一下：</p><ul><li>HMaster：HBase 主/从架构的主节点。通常在一个 HBase 集群中允许存在多个 HMaster 节点，其中一个节点被选举为 Active Master，而剩余节点为 Backup Master。其主要作用在于：<ul><li>管理和分配 HRegionServer 中的 Region</li><li>管理 HRegionServer 的负载均衡</li></ul></li><li>HRegionServer：HBase 主/从架构的从节点。主要负责响应 Client 端的 I/O 请求，并向底层文件存储系统 HDFS 中读写数据</li><li>HRegion：HBase 通过表中的 RowKey 将表进行水平切割后，会生成多个 HRegion。每个 HRegion 都会被安排到 HRegionServer 中</li><li>Store：每一个 HRegion 有一个或多个 Store 组成，Store 相对应表中的 Column Family（列族）。每个 Store 都由一个 MemStore 以及多个 StoreFile 组成</li><li>MemStore：MemStore 是一块内存区域，其将 Client 对 Store 的所有操作进行存储，并到达一定的阈值时会进行 flush 操作</li><li>StoreFile：MemStore 中的数据写入文件后就成为了 StoreFile，而 StoreFile 底层是以 HFile 为存储格式进行保存的</li><li>HFile：HBase 中 Key-Value 数据的存储格式，是 Hadoop 的二进制文件。其中 Key-Value 的格式为（Table, RowKey, Family, Qualifier, Timestamp）- Value</li></ul><p>HBase 的主要读写方式可以通过以下流程进行：</p><p><img src="http://on83riher.bkt.clouddn.com/HBase%20%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.png" alt=""></p><p>可以从上述的架构讲述看出，HBase 并非严格意义上的列式存储，而是基于“列族”存储的，所以其是列族的角度进行列式存储。</p><hr><p>Parquet 是面向分析型业务的列式存储格式，其不与某一特定语言绑定，也不与任何一种数据处理框架绑定在一起，其性质类似于 JSON。</p><p>Parquet 相较于 HBase 对数据的处理方式，其将数据当做成一种嵌套数据的模型，并将其结构定义为 schema。每一个数据模型的 schema 包含多个字段，而每个字段又可以包含多个字段。每一字段都有三个属性：repetition、type 和 name，其中 repetition 可以是以下三种：required（出现1次）、optional（出现0次或1次）、repeated（出现0次或多次），而 type 可以是 group（嵌套类型）或者是 primitive（原生类型）。</p><p>举一个典型的例子：</p><p><img src="http://on83riher.bkt.clouddn.com/Parquet%20%E4%BE%8B%E5%AD%90.png" alt=""></p><p>在 Parquet 格式的存储当中，一个 schema 的树结构有几个叶子节点，在实际存储中就有多少个 column。例如上面 schema 的数据存储实际上有四个 column，如下所示：</p><p><img src="http://on83riher.bkt.clouddn.com/Parquet%20%E4%BE%8B%E5%AD%902.png" alt=""></p><p>从上面的图看来，与 HBase 好像没有什么区别，但这只是为了让用户更好的了解数据才这样表示，其内部实现的机制与 HBase 完全不同，而且 Parquet 是真正的基于列式存储。其能够进行列式存储归功于 Striping/Assembly 算法。</p><p>算法我就不详细说了，<a href="http://www.infoq.com/cn/articles/in-depth-analysis-of-parquet-column-storage-format" target="_blank" rel="external">这篇文章</a>讲的很详细，我就不献丑了。</p><hr><p>参考资料：</p><ol><li>HBase 权威指南</li><li><a href="http://blog.javachen.com/2013/06/15/hbase-note-about-data-structure.html" target="_blank" rel="external">HBase笔记：存储结构</a></li><li><a href="http://www.infoq.com/cn/articles/in-depth-analysis-of-parquet-column-storage-format" target="_blank" rel="external">深入分析Parquet列式存储格式</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;虽然两者在使用场景上没有可比性，HBase 是非关系型数据库，而 Parquet 是数据存储格式，但是两者却存在相似的概念——列式存储。我在了解 Parquet 的时候，因为列式存储这个概念与 HBase 混淆时，所以特意坐下笔记，记录两者的区别&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala - identity() 函数</title>
    <link href="http://apparition957.github.io/2018/03/19/Scala%20-%20identity()%20%E5%87%BD%E6%95%B0/"/>
    <id>http://apparition957.github.io/2018/03/19/Scala - identity() 函数/</id>
    <published>2018-03-19T12:51:59.000Z</published>
    <updated>2018-03-19T12:52:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写 Spark 作业的时候，使用到了 <code>groupBy</code>和<code>sortBy</code>，在查找文档的时候，发现有的文档中的代码有着<code>groupBy(identity)</code>这样奇怪的写法。</p><p>在 Scala 文档中，<a href="http://www.scala-lang.org/api/current/scala/Predef$.html#identityA:A" target="_blank" rel="external">identity 函数</a>的作用就是将传入的参数“直接”当做返回值回传给调用者，这在正常使用中，可以说是毫无作用，但他在<code>groupBy</code>和<code>sortBy</code>等函数中的作用，在于避免程序员书写相同且容易出错的逻辑，原因如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 前提条件：</span></div><div class="line"><span class="keyword">val</span> array = <span class="type">Array</span>(<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">// 统计 array 中每个元素出现的次数</span></div><div class="line"><span class="comment">// 正常逻辑：</span></div><div class="line">array.groupBy(n =&gt; n)</div><div class="line"><span class="comment">// scala.collection.immutable.Map[Int,Array[Int]] = Map(5 -&gt; Array(5), 1 -&gt; Array(1, 1), 6 -&gt; Array(6), 9 -&gt; Array(9, 9), 2 -&gt; Array(2, 2), 7 -&gt; Array(7), 3 -&gt; Array(3), 4 -&gt; Array(4))</span></div><div class="line"></div><div class="line"><span class="comment">// 使用 identity</span></div><div class="line">array.groupBy(identity)</div><div class="line"></div><div class="line"><span class="comment">// 将 array 进行排序(升序)</span></div><div class="line"><span class="comment">// 正常逻辑：</span></div><div class="line">array.sortBy(n =&gt; n)</div><div class="line"><span class="comment">// Array[Int] = Array(1, 1, 2, 2, 3, 4, 5, 6, 7, 9, 9)</span></div><div class="line"></div><div class="line"><span class="comment">// 使用 identity 或者简化版本</span></div><div class="line">array.sortBy(identity)</div><div class="line">array.sorted</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在写 Spark 作业的时候，使用到了 &lt;code&gt;groupBy&lt;/code&gt;和&lt;code&gt;sortBy&lt;/code&gt;，在查找文档的时候，发现有的文档中的代码有着&lt;code&gt;groupBy(identity)&lt;/code&gt;这样奇怪的写法。&lt;/p&gt;
&lt;p&gt;在 Scala
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式爬虫架构</title>
    <link href="http://apparition957.github.io/2018/03/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E6%9E%B6%E6%9E%84/"/>
    <id>http://apparition957.github.io/2018/03/06/分布式爬虫架构/</id>
    <published>2018-03-06T14:53:55.000Z</published>
    <updated>2018-03-06T14:54:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近突然对爬虫框架很感兴趣，但一直无奈于没有服务器能让我捣鼓捣鼓，所以脑子就一直想如何去设计这个框架。翻了很多篇资料，总结了挺多经验，然后就画了下面这张架构图。个人认为很不成熟，但毕竟也是一种想法。希望能力提升后能够想到更加全面完善的架构。</p><p><img src="http://on83riher.bkt.clouddn.com/%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E6%9E%B6%E6%9E%84.png" alt="分布式爬虫架构"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近突然对爬虫框架很感兴趣，但一直无奈于没有服务器能让我捣鼓捣鼓，所以脑子就一直想如何去设计这个框架。翻了很多篇资料，总结了挺多经验，然后就画了下面这张架构图。个人认为很不成熟，但毕竟也是一种想法。希望能力提升后能够想到更加全面完善的架构。&lt;/p&gt;
&lt;p&gt;&lt;img src=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大三上学期总结</title>
    <link href="http://apparition957.github.io/2018/01/22/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    <id>http://apparition957.github.io/2018/01/22/大三上学期总结/</id>
    <published>2018-01-22T14:30:09.000Z</published>
    <updated>2018-01-22T14:30:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>今天是周一（2018/01/22），是我正式作为小米实习生的第一天，也是我第一次远离熟悉的地方来到北京闯荡。</strong>经历过这学期磨人的课程后，经历过让人背书背的头大的毛概后，经历过曾经一度让人绝望的面试后，经历过令人心寒的租房后，终于可以安下心来好好写我的学期总结。</p><p>下面我就这学期的比较重要的方向进行总结吧。</p><ul><li><strong>学习</strong></li></ul><p>这学期课程真的比以往的多，几乎每天都要上至少两节课，甚至还得上整天，真让人疲惫不堪，但是真正觉得心累的，还是宿舍的氛围，还是像大二那样过一天是一天，不到找工作/临近考试的时候不会去努力。这学期我就尝试着每晚都去图书馆，但是就算是十点半回到宿舍还是无法得到一片宁静，因为十点半的时候，有个宿友准点吃鸡，而且很吵，吵到连看美剧都没心情。当时也怪自己没肯直说吧，暂时不说了，不想开始就写一长篇的抱怨。</p><p>虽然这学期很累，但是过得也算充实，毕竟我认清自己的学习方向了，之前在大二中我接触的是Web开发，偏向于云计算/微服务方面，但是每次接触的工程都只是学习工具，学习如何使用，然后反复造轮子，跟着规整的MVC架构来搭建项目，我对这一过程心生厌恶，觉得自己不能这样。于是乎我寻找了另一个兴趣点——大数据进行学习。大数据既是现在的热点，也是我最感兴趣的地方，每次都能借好多书走，学习到很多新的内容，新的架构。</p><p>这也是为什么我在找岗位的时候，想要寻找大数据方面的职位，一是充实自己，提高技能；二是在实际开发工程中，切身体会到如何真正的运用大数据来进行对数据分析。</p><ul><li><strong>简历</strong></li></ul><p>当初写简历的时候觉得还很自信，秉持着简约的风格的简历外加上整齐规格的排版，一定能够在一月份前拿到一份心满意足的offer。经历过整整三个星期都没有一通面试电话时，我真的很绝望，发自心底的绝望，认为这三年学的东西是不是白学了。后来经过很多同学的指点过后，<strong>我才发现一份简约的简历，要遵循以下几个点：</strong></p><ul><li>只能是一页纸，不能够再多</li><li>只写有用的话（姓名，联系电话，工作/校园经历）</li><li>排版要规整，粗细得体</li></ul><p>在这里真的要讲一句真心话，在正式修改了简历后，过没两天实习僧上的公司就真的给我面试电话通知了，而且后面陆陆续续也来了不少电话。</p><ul><li><strong>租房（注意粗体部分）</strong></li></ul><p>租房是个出来漂的首要大事啊，自从拿到offer后我就投入了租房这件事了，但是租房并不像想象中那么容易（除非你运气真的超级超级棒）。<strong>既要小心租房中遇到的中介/二房东/代理，还要小心合同中会不会收取额外的费用（中介费/物业管理费/燃气费/服务费），更要小心同住的人是否有良好的习惯。</strong>我几乎每晚回到宿舍都要花上二十分钟到半个小时，<strong>途径有豆瓣/自如（等各大互联网租房平台）/闲鱼/暖房（自动爬虫机制的网站，感觉还行）</strong>，其中遇到了有让人觉得恶心的中介，也遇到了聊得上天的转租大哥，但是由于自己不在北京的缘故，无法确切的看到实际房子的状况，所以一直犹豫着要不要直接租房（实际原因是没看到让人一眼看中的房子，或者碍于价格太高了）。</p><p>出于以上原因，我决定了考完试后联系好之前找好的中介/转租房东一一探寻房子。当时我是提前购买了凌晨到北京的机票，打算在机场中睡一觉就赶过去，所以我就在前一天晚上急忙去联系人预约看房，等到凌晨6点时就赶了过去，从西二旗地铁口出发后，暴走3公里后到达下榻酒店（暴走的原因是因为<strong>要亲自熟悉周边的环境，才好对房子进行更加深刻的评估</strong>），放下行李就跟着中介出去跑了。</p><p>真的是比较幸运，在早上十点钟时，中介带我找到了一个不错的房子，房子空间很大，内部装饰还行，价格中等偏上（相当于拿出一半的实习工资还多）。自己当时就想下定决心去签合同，不过出于谨慎，还是与家里人详细沟通了一下。在得到家里人的赞成后，我当时就和中介签的合同了（还是很<strong>比较谨慎的，看了好多回合同才肯签字，生怕有什么坑自己没注意</strong>）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;今天是周一（2018/01/22），是我正式作为小米实习生的第一天，也是我第一次远离熟悉的地方来到北京闯荡。&lt;/strong&gt;经历过这学期磨人的课程后，经历过让人背书背的头大的毛概后，经历过曾经一度让人绝望的面试后，经历过令人心寒的租房后，终于可以安下心来好
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊聊log4j</title>
    <link href="http://apparition957.github.io/2017/11/27/%E8%81%8A%E8%81%8Alog4j/"/>
    <id>http://apparition957.github.io/2017/11/27/聊聊log4j/</id>
    <published>2017-11-27T06:53:55.000Z</published>
    <updated>2017-11-27T07:03:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><blockquote><p>最近在学习 Zookeeper 的时候，遇到了不少问题，想要在控制台中查看日志但是记录却死活不显示，于是找到了 /etc/zookeeper/log4j.properties 文件，但发现配置选项看不懂，想到之前在写 Web 应用的时候也是拿来就用，都没涉及到日志配置文件这一层面，所以打算整理一番。</p></blockquote><p>log4j 是一个用 Java 编写的可靠，快速和灵活的日志框架（API），它在 Apache 软件许可下发布。log4j 是高度可配置的，并可通过在运行时的外部文件配置。它根据记录的优先级别，并提供机制，以指示记录信息到许多的目的地，诸如：数据库，文件，控制台，UNIX 系统日志等。</p><h2 id="与-slf4j-的关系"><a href="#与-slf4j-的关系" class="headerlink" title="与 slf4j 的关系"></a>与 slf4j 的关系</h2><p>在实际开发当中，常常有人提醒我们，要使用 slf4j 来记录日志，为什么呢？</p><p>下面是 sl4fj 官网的介绍。</p><blockquote><p>The Simple Logging Facade for Java (SLF4J) serves as a simple facade or abstraction for various logging frameworks (e.g. java.util.logging, logback, log4j) allowing the end user to plug in the desired logging framework at deployment time.</p></blockquote><p>slf4j（Simple Logging Facade For Java，Java 简易日志门面）是一套封装 Logging 框架的抽象层，而 log4j 是 slf4j 下一个具体实现的日志框架，其中还有许许多多的成熟的日志框架，如 logback 等，也是从属于 slf4j。</p><p>使用 slf4j 可以在应用层中屏蔽底层的日志框架，而不需理会过多的日志配置、管理等操作。</p><h2 id="如何配置"><a href="#如何配置" class="headerlink" title="如何配置"></a>如何配置</h2><p>log4j 配置文件的基本格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#配置根Logger</div><div class="line">log4j.rootLogger = [level], appenderName1, appenderName2, ...</div><div class="line"></div><div class="line">#配置日志信息输出目的地 Appender</div><div class="line">log4j.appender.appenderName = fully.qualified.name.of.appender.class </div><div class="line">log4j.appender.appenderName.option1 = value1 </div><div class="line">log4j.appender.appenderName.optionN = valueN </div><div class="line"></div><div class="line">#配置日志信息的格式（布局）</div><div class="line">log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class</div><div class="line">log4j.appender.appenderName.layout.option1 = value1 </div><div class="line">log4j.appender.appenderName.layout.optionN = valueN</div></pre></td></tr></table></figure><p>其中：</p><ul><li>[level] - 日志输出级别，可分为以下级别（级别程度从上到下递增）：</li></ul><table><thead><tr><th>级别</th><th>描述</th></tr></thead><tbody><tr><td><strong>ALL</strong></td><td>所有级别，包括定制级别。</td></tr><tr><td><strong>TRACE</strong></td><td>比 DEBUG 级别的粒度更细。</td></tr><tr><td><strong>DEBUG</strong></td><td>指明细致的事件信息，对调试应用最有用。</td></tr><tr><td><strong>INFO</strong></td><td>指明描述信息，从粗粒度上描述了应用运行过程。</td></tr><tr><td><strong>WARN</strong></td><td>指明潜在的有害状况。</td></tr><tr><td><strong>ERROR</strong></td><td>指明错误事件，但应用可能还能继续运行。</td></tr><tr><td><strong>FATAL</strong></td><td>指明非常严重的错误事件，可能会导致应用终止执行。</td></tr><tr><td><strong>OFF</strong></td><td>最高级别，用于关闭日志。</td></tr></tbody></table><ul><li>Appender - 日志输出目的地，常用的 Appender 有以下几种：</li></ul><table><thead><tr><th>Appender</th><th>作用</th></tr></thead><tbody><tr><td><strong>org.apache.log4j.ConsoleAppender</strong></td><td>输出至控制台</td></tr><tr><td><strong>org.apache.log4j.FileAppender</strong></td><td>输出至文件</td></tr><tr><td><strong>org.apache.log4j.DailyRollingFileAppender</strong></td><td>每天产生一个日志文件</td></tr><tr><td><strong>org.apache.log4j.RollingFileAppender</strong></td><td>文件容量到达指定大小时产生一个新的文件</td></tr><tr><td><strong>org.apache.log4j.WriterAppender</strong></td><td>将日志信息以输出流格式发送到任意指定地方</td></tr></tbody></table><ul><li>Layout - 日志输出格式，常用的 Layout 有以下几种：</li></ul><table><thead><tr><th>Layout</th><th>作用</th></tr></thead><tbody><tr><td><strong>org.apache.log4j.HTMLLayout</strong></td><td>以 HTML 表格形式布局</td></tr><tr><td><strong>org.apache.log4j.PatternLauout</strong>（常用）</td><td>以格式化的方式定制布局</td></tr><tr><td><strong>org.apache.log4j.SimpleLayout</strong></td><td>包含日志信息的级别和信息字符串</td></tr><tr><td><strong>org.apache.log4j.TTCCLayout</strong></td><td>包含日志所在线程、产生时间、类名和日志内容等</td></tr></tbody></table><ul><li>打印参数（格式化输出格式，一般对应于 org.apache.log4j.PatternLauout）</li></ul><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><strong>%m</strong></td><td>输出代码中指定的消息</td></tr><tr><td><strong>%p</strong></td><td>输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL</td></tr><tr><td><strong>%r</strong></td><td>输出自应用启动到输出该log信息耗费的毫秒数</td></tr><tr><td><strong>%c</strong></td><td>输出所属的类目，通常就是所在类的全名。%c{1} 可取当前类名称</td></tr><tr><td><strong>%t</strong></td><td>输出产生该日志事件的线程名</td></tr><tr><td><strong>%n </strong></td><td>输出一个回车换行符，Windows平台为“\r\n”，Unix平台为“\n”</td></tr><tr><td><strong>%d</strong></td><td>输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式。标准格式为 %d{yyyy-MM-dd HH:mm:ss}</td></tr><tr><td><strong>%l </strong></td><td>输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。</td></tr></tbody></table><ul><li>option - 可选配置。一般来说每个 Appender 或者 Layout 都有默认配置，用户使用自定义日志配置，如指定输出地点等。常用的 option 有以下几种：</li></ul><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><strong>file</strong></td><td>日志输出至指定文件</td></tr><tr><td><strong>thresold</strong></td><td>定制日志消息的输出在不同 level 时的行为，</td></tr><tr><td><strong>append</strong></td><td>是否追加至日志文件中</td></tr></tbody></table><hr><p>参考资料：</p><p><a href="http://wiki.jikexueyuan.com/project/log4j/overview.html" target="_blank" rel="external">Log4J 教程 - 极客学院</a></p><p><a href="http://www.cnblogs.com/ITEagle/archive/2010/04/23/1718365.html" target="_blank" rel="external">log4j.properties配置详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最近在学习 Zookeeper 的时候，遇到了不少问题，想要在控制台中查看日志但是记录却死活不显示，于是找到了 /
      
    
    </summary>
    
    
      <category term="log4j" scheme="http://apparition957.github.io/tags/log4j/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC源码分析 - DispatcherServlet请求处理过程</title>
    <link href="http://apparition957.github.io/2017/11/26/SpringMVC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-DispatcherServlet%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/"/>
    <id>http://apparition957.github.io/2017/11/26/SpringMVC源码分析-DispatcherServlet请求处理过程/</id>
    <published>2017-11-26T15:58:23.000Z</published>
    <updated>2017-11-26T15:59:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><img src="http://on83riher.bkt.clouddn.com/DispatcherServlet%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A6%81.png" alt=""></p><blockquote><p>这张图在网上搜到的，但是实际的来源处实在找不到了，如果后面找到一定补上链接。</p></blockquote><p>上图的流程可用以下文字进行描述：</p><ol><li>DispatcherServelt 作为前端控制器，拦截所有的请求。</li><li>DispatcherServlet 接收到 http 请求之后， 根据访问的路由以及 HandlerMapping，获取一个 HandlerExecutionChain 对象。</li><li>DispatcherServlet 将 Handler 对象交由 HandlerAdapter，调用处理器 Controller 对应功能处理方法。</li><li>HandlerAdapter 返回 ModelAndView 对象，DispatcherServlet 将 view 交由 ViewResolver 进行解析，得到相应的视图，并用 Model 对 View 进行渲染。</li><li>返回响应结果。</li></ol><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>源码部分我打算通过流程图的形式来分析，源代码部分还是根据流程图来一步步看会更好，否则会被陌生且复杂的源代码给搞混（欲哭无泪）。</p><p><img src="http://on83riher.bkt.clouddn.com/DispatcherServlet%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82.png" alt=""></p><blockquote><p>DEBUG大法是真的好！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://on83riher.bkt.clouddn.com/DispatcherServlet%E6%A1%86%
      
    
    </summary>
    
    
      <category term="SpringMVC" scheme="http://apparition957.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC源码分析 - DispatcherServlet初始化过程</title>
    <link href="http://apparition957.github.io/2017/11/26/SpringMVC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-DispatcherServlet%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <id>http://apparition957.github.io/2017/11/26/SpringMVC源码分析-DispatcherServlet初始化过程/</id>
    <published>2017-11-26T15:58:09.000Z</published>
    <updated>2017-11-26T15:58:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h2><p><img src="http://on83riher.bkt.clouddn.com/DispatcherServlet%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB.png" alt=""></p><p>从 DispatcherServlet 继承体系来看（蓝色部分），DispatcherServlet 继承自 FrameworkServlet，而 FrameworkServlet 又继承自 HttpServletBean ，最终 HttpSevletBean 继承了 HttpServlet 。通过这一步步继承封装之后，才构成了如今的 DispatcherSevlet 架构基础。</p><p>下面将自上到下来说明 DispatcherServlet 的初始化过程。</p><h2 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h2><p>HttpServletBean 继承自 Servlet 架构中的 HttpServlet 类，并重写了<code>init()</code>方法。</p><blockquote><p>Servlet 生命周期从创建到销毁的过程中，有三个重要的方法：</p><ul><li>init() - 负责初始化 Servlet 对象。在 Servlet 生命周期中只会调用一次。</li><li>service() - 负责响应客户的请求。每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service 方法中两个参数，分别是 ServletRequest 和 ServletResponse，用于传递 http 请求和回写。</li><li>destory() - 负责销毁 Servlet 对象。在 Servlet 生命周期中只会调用一次。</li></ul></blockquote><p>从 Servlet 的生命周期可知，在 <code>init()</code>方法中，我们可以进行初始化工作，HttpServletBean 正是也做了这样的工作。源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">      logger.debug(<span class="string">"Initializing servlet '"</span> + getServletName() + <span class="string">"'"</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// Set bean properties from init parameters.</span></div><div class="line">   <span class="comment">// 加载 Servlet 的配置文件(一般指 web.xml)</span></div><div class="line">   PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</div><div class="line">   <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">         BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</div><div class="line">         ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</div><div class="line">         bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</div><div class="line">         initBeanWrapper(bw); <span class="comment">// 上面做了这么多的工作，到这里却是一个空方法，而它的子类都没有去重写这个方法，个人认为这是想让开发者自定义如何管理 Servlet 配置吧</span></div><div class="line">         bw.setPropertyValues(pvs, <span class="keyword">true</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</div><div class="line">         <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</div><div class="line">            logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">throw</span> ex;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// Let subclasses do whatever initialization they like.</span></div><div class="line">   <span class="comment">// 交由子类(FrameworkServlet)来进行其特有的初始化工作</span></div><div class="line">   initServletBean();</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">      logger.debug(<span class="string">"Servlet '"</span> + getServletName() + <span class="string">"' configured successfully"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h2><p>FrameworkServlet 继承自 HttpServletBean，实现了<code>initServletBean()</code>方法。FrameworkServlet 在继承体系结构中，在 Servlet 与 SpringMVC 起到了承上启下的作用，它负责初始化 WebApplicationContext，还负责重写了 Servlet 生命周期中另外两个重要方法——<code>service()</code>和<code>destory()</code>，并改写了<code>doGet()</code>、<code>doPost()</code>等 http 方法，统一调用<code>processHandler()</code>方法来处理所有 http 请求。</p><blockquote><p>ApplicationContext 是 Spring 的核心，相当于 Spring 环境中的上下文。而在WebApplicationContext 继承自 ApplicationContext，充当了在 Web 环境中使用 Spring 的上下文。在 Web 环境中，WebApplicationContext 实例需要 ServletContext，即它必须拥有 Web 容器才能够完成启动的工作。</p></blockquote><p>下面重点讲<code>initServletBean()</code>方法，源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">   <span class="comment">// do sth</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// 初始化 WebApplicationContext</span></div><div class="line">      <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</div><div class="line">      initFrameworkServlet();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">catch</span> (ServletException ex) &#123;</div><div class="line">      <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</div><div class="line">      <span class="keyword">throw</span> ex;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">catch</span> (RuntimeException ex) &#123;</div><div class="line">      <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</div><div class="line">      <span class="keyword">throw</span> ex;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// initServletBean()转而调用了initWebApplicationContext()，所以重点工作在这里</span></div><div class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</div><div class="line">   WebApplicationContext rootContext =</div><div class="line">         WebApplicationContextUtils.getWebApplicationContext(getServletContext());</div><div class="line">   WebApplicationContext wac = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// A context instance was injected at construction time -&gt; use it</span></div><div class="line">      wac = <span class="keyword">this</span>.webApplicationContext;</div><div class="line">      <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</div><div class="line">         ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</div><div class="line">         <span class="keyword">if</span> (!cwac.isActive()) &#123;</div><div class="line">            <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</div><div class="line">               cwac.setParent(rootContext);</div><div class="line">            &#125;</div><div class="line">            configureAndRefreshWebApplicationContext(cwac);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></div><div class="line">      <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></div><div class="line">      <span class="comment">// that the parent context (if any) has already been set and that the</span></div><div class="line">      <span class="comment">// user has performed any initialization such as setting the context id</span></div><div class="line">      wac = findWebApplicationContext();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></div><div class="line">      wac = createWebApplicationContext(rootContext);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</div><div class="line">      <span class="comment">// DispatcherSevlet 初始化工作的入口就在这里！</span></div><div class="line">      onRefresh(wac);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// do sth</span></div><div class="line">   <span class="keyword">return</span> wac;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p>在进行下一步代码分析之前，先看下 DispatcherSevrlet 的静态代码块部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_STRATEGIES_PATH = <span class="string">"DispatcherServlet.properties"</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">   <span class="comment">// Load default strategy implementations from properties file.</span></div><div class="line">   <span class="comment">// This is currently strictly internal and not meant to be customized</span></div><div class="line">   <span class="comment">// by application developers.</span></div><div class="line">   <span class="comment">// 加载所有默认配置，用于后面的初始化工作</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">      ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);</div><div class="line">      defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not load '"</span> + DEFAULT_STRATEGIES_PATH + <span class="string">"': "</span> + ex.getMessage());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>DispatcherServlet.properties</code>配置文件中定义了DispatcherServlet各组件中的配置实现形式，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># Default implementation classes for DispatcherServlet&apos;s strategy interfaces.</div><div class="line"># Used as fallback when no matching beans are found in the DispatcherServlet context.</div><div class="line"># Not meant to be customized by application developers.</div><div class="line"></div><div class="line">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</div><div class="line">   org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</div><div class="line"></div><div class="line">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</div><div class="line">   org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</div><div class="line">   org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</div><div class="line"></div><div class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\</div><div class="line">   org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</div><div class="line">   org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</div><div class="line"></div><div class="line">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</div></pre></td></tr></table></figure><p>回到正题，在<code>onRefresh()</code>方法，调用了<code>initStrategies()</code>，所以重点部分就在于<code>initStrategies()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">   initStrategies(context);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">  <span class="comment">// 初始化多媒体解析器</span></div><div class="line">    initMultipartResolver(context);</div><div class="line">    <span class="comment">// 初始化位置解析器</span></div><div class="line">    initLocaleResolver(context);</div><div class="line">  <span class="comment">// 初始化主题解析器</span></div><div class="line">    initThemeResolver(context);</div><div class="line">  <span class="comment">// 初始化 HandlerMappings</span></div><div class="line">    initHandlerMappings(context);</div><div class="line">  <span class="comment">// 初始化 HandlerAdapters</span></div><div class="line">    initHandlerAdapters(context);</div><div class="line">  <span class="comment">// 初始化异常处理解析器</span></div><div class="line">    initHandlerExceptionResolvers(context);</div><div class="line">  <span class="comment">// 初始化请求到视图名转换器</span></div><div class="line">    initRequestToViewNameTranslator(context);</div><div class="line">  <span class="comment">// 初始化视图解析器</span></div><div class="line">    initViewResolvers(context);</div><div class="line">  <span class="comment">// 初始化 FlashMapManager</span></div><div class="line">    initFlashMapManager(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面以<code>initHandlerMappings()</code>方法为例，分析如何加载 HandlerMapping。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.handlerMappings = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;</div><div class="line">      <span class="comment">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span></div><div class="line">      Map&lt;String, HandlerMapping&gt; matchingBeans =</div><div class="line">            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">      <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</div><div class="line">         <span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());</div><div class="line">         <span class="comment">// We keep HandlerMappings in sorted order.</span></div><div class="line">         AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">         HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</div><div class="line">         <span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</div><div class="line">         <span class="comment">// Ignore, we'll add a default HandlerMapping later.</span></div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// Ensure we have at least one HandlerMapping, by registering</span></div><div class="line">   <span class="comment">// a default HandlerMapping if no other mappings are found.</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</div><div class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">         logger.debug(<span class="string">"No HandlerMappings found in servlet '"</span> + getServletName() + <span class="string">"': using default"</span>);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的源码注释解释的十分清楚了，值得注意一点的是，为了确保 DispatcherServlet 中至少有一个 HandlerMapping，它会从上面所述的默认配置项中加载所有默认组件，如 HandlerMapping 默认组件为 BeanNameUrlHandlerMapping、RequestMappingHandlerMapping。</p><hr><p>参考资料：</p><p><a href="http://www.cnblogs.com/klguang/p/4748922.html" target="_blank" rel="external">servlet清晰理解</a></p><p><a href="http://blog.csdn.net/zhulinu/article/details/7305247" target="_blank" rel="external">WebApplicationContext初始化</a></p><p><a href="http://wujiu.iteye.com/blog/2170778" target="_blank" rel="external">Spring MVC之DispatcherServlet初始化</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;继承体系&quot;&gt;&lt;a href=&quot;#继承体系&quot; class=&quot;headerlink&quot; title=&quot;继承体系&quot;&gt;&lt;/a&gt;继承体系&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://on83riher.bkt.clouddn.com/DispatcherServlet%E
      
    
    </summary>
    
    
      <category term="SpringMVC" scheme="http://apparition957.github.io/tags/SpringMVC/"/>
    
  </entry>
  
</feed>
